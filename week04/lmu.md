# Chapter 4. 데이터 관리 패턴

## 4.1. 데이터 아키텍쳐
- 데이터 소스: 사용자 입력이나 센서 측정 값과 같이 클라우드 네이티브 어플리케이션으로 데이터를 입력하는 곳
- 데이터 인제스천 시스템: 메시지 브로커와 같은 데이터를 입력을 받는 시스템, 데이터소스로부터 들어온다.
- 데이터 스토어: 데이터 아키텍쳐의 핵심적인 부분. 다양한 형태의 데이터를 저장하고, 확장할수 있다.
- 실시간/스트림 프로세싱 시스템: 이벤트를 그때그때 처리하는 경우
- 배치 프로세싱 시스템

## 4.2. 데이터의 타입과 형태
- 입력데이터: 사용자 또는 클라이언트를 통해 입려되는 메시지. 많은 경우 json, xml 과 같은 형태, gRPC, Thirft 와 같은 이진 데이터 형태로도 입력된다.
	- 이건 오역인듯, gRPC가 아니라 protobuf라고 말해야지 올바르다.
- 설정 데이터: 환경 등과 관련된 값을 변수 형태로 받는다. 클라우드 네이티브 어플리케이션 분야에서는 yaml 이 사실상 표준 상태
- 상태 데이터: 어플리케이션 자체가 현재 메시지나 이벤트 등에 기반한 상태를 기록하고 저장하는 데이터

- Stateless 어플리케이션
- Stateful 어플리케이션

- 클라우드 어플리케이션의 데이터 처리에 따른 분류 3가지
	- 정형 데이터: 미리 정의한 스키마에 잘 맞는 데이터
	- 반정형 데이터: 일부 구조적이지만, 모든 데이터가 같은 구조이거나 특정 필드를 가지고 있다고 보장하기 어려운 데이터, json, xml yaml 로 표현되기 쉬움
	- 비정형 데이터: 참조를 위한 의미있는 필드가 아예 없는 경우. 이미지, 비디오, 저수준 텍스트 콘텐츠

## 4.3. 데이터 스토어
### 4.3.1. 관계형 데이터 베이스
- SQL 을 사용해서 데이터를 처리하고 저장하고 접근할 수 있다.
- schema on write 정책을 따른다.
- 관계형 데이터베이스는 ACID
	- Atomicity, Consistency, Isolation, Durability
- 관계형 데이터베이스는 반정형 데이터에 잘 맞지 않는다.
	- 반 정형 데이터를 관계형 데이버테이스의 blob이나 텍스트 형태로 저장해서 읽기 성능을 향상시킬수도 있다. 다만 이럴 경우 비용과 저장 공간 소비 정도를 고려해야한다.
- 관계형 데이터베이스는 클라우드 네이티브 어플리케이션 데이터 저장에도 사용할수 있는 좋은 선택지이다.
	- 하지만, 그 설계 구조상 확장성이 떨어진다.
	- Primary, Secondary 구조밖에 지원하지 않는 경우가 많고, 단 하나의 노드에서만 쓰기가 가능한 경우가 많다.
	- 저장해야하는 레코드 수가 데이터베이스가 효과적으로 처리할 수 있는 수를 넘지 않을 때만 사용하는 것이 좋다.
	- 이보다 데이터가 많은 경우 다른 데이터 스토어를 사용하는 것이 좋다.

### 4.3.2. NoSQL 데이터 베이스
- Not Only SQL 이 더 정확한 표현이다.
- Schema on Read, 데이터를 읽고 처리하는 시점에 데이터 대한 스키마가 정의되어 있어야 하는 정책을 따른다.
- 구분
	- Key-Value Store: Redis, Memcached, Ehcache 가 널리 사용된다.
	- Column Store: 여러 개의 키 값 쌍을 저장한다. 데이터를 읽어올 때는 원하는 컬럼만 명시한다. Cassandr, HBase가 대표적인 케이스
	- Document Store: json이나 xml 도큐먼트와 같은 반정형 데이터를 저장할 수 있다. MongoDB, CouchDB, CouchBase 가 주로 사용된다.
	- Graph Store: 데이터를 노드로 저장하고 Edge를 통해 데이터 노드 간 관계를 표현한다. 저장되는 데이터는 다차원 형태이며, Neo4j 가 가장 널리 쓰인다.
- Object Store나 TTime-Series데이터 스토어와 같은 다른 유형의 NoSQL 데이터베이스들은 특정 목적을 가지고 사용하는 데이터를 저장하고 질의할 때 많이 사용된다.
- NoSQL 데이터베이스는 기본적으로 분산 동작하기 때문에, CAP이론을 적용할 수 있다.
	- Consistency, Avaibility, Partition Toleration
- 우선시하는 특성별 NoSQL 데이터 스토어 분류

|                 | 일관성 우선                       | 가용성 우선              |
| --------------- | ---------------------------- | ------------------- |
| Key-Value Store | Redis, Memcached             | DynamoDB, Voldemort |
| Column Store    | Google Cloud BigTable, HBase | Cassandra           |
| Document Store  | MongoDB, Terastore           | CouchDB, SimpleDB   |
| Graph Store     | Cosmos DB                    | Neo4j               |
### 4.3.3. 파일 시스템 스토리지
- 파일 시스템 스토리지는 클라우드 네이티브 어플리케이션에서 비정형 데이터를 저장할때 쓸 수 있는 가장 좋은 방법이다.
- 가장 저렴한 방법이지만, 텍스트나 반정형 데이터를 저장하기에는 좋지 않을수 있다.
- Solr 나 ElasticSearch 와 같은 색인 시스템의 검색 기능을 사용하는 것이 좋다.
- 크기가 증가하는 경우에 분산 파일 시스템을 사용할 수 있다.
	- HDFS, S3  등
### 4.3.4. 데이터 스토어 정리
- 관계형, NoSQL, 파일 시스템

## 4.4. 데이터 관리
### 4.4.1. 중앙 데이터 관리
- 전통적인 데이터 중심 어플리케이션에서 가장 자주 사용하는 방식
- 데이터베이스 테이블들을 정규화할 수 있으며 아주 높은 데이터 일관성을 제공하는 등의 장점이 있다.
- 데이터베이스와 어플리케이션들 간에 강한 연관성이 생기며 어플리케이션을 독립적으로 개선하고 발전시키기 어려워진다.
	- Q. 성능상의 문제로 동일한 데이터를 로딩해야하는데, 분산 데이터로 하기에는 비용적인 문제가 발생한다면 어떻게 하는게 좋은가?

### 4.4.2. 분산 데이터 관리
- 각 마이크로서비스가 별도의 데이터 스토어를 사용하도록 만든다.
- 각 마이크로서비스가 다른 마이크로서비스에 아무런 영향을 미치지 않고도 그 크기를 자유롭게 조절할 수 있도록 해준다.

### 4.4.3. 하이브리드 데이터 관리
- 분산 데이터 관리 방식의 단점 중 하나로는 각 서비스별로 별도의 데이터 스토어를 사용하는 데 따른 비용 부담이다.
- 하나의 팀에서는 여러 마이크로서비스가 같은 데이터베이스를 공유하며 같은 바운디드 컨텍스트 내에 존재하게 된다.
- 하지만, 이럴 때 특정 서비스가 다른 서비스의 테이블에 직접 접근하게 된다면 시스템 복잡도가 아주 크게 증가한다.


### 4.4.4. 데이터 관리 정리
- 데이터 관리 패턴에서는 데이터 조합과 확장성, 성능 최적화 및 신뢰성과 보안성을 고려해야한다.

## 4.5. 데이터 조합 패턴
### 4.5.1. 데이터 서비스 패턴
- 데이터베이스의 데이터를 서비스 형태로 제공하며, 이러한 서비스를 데이터 서비스라고 지칭한다.
- 데이터 소유권을 가진다.
- 데이터에 대한 책임을 가져가며, 간단한 조회 기능만을 할지, 복잡한 처리르 할지 결정할수 있다.
- 어떻게 동작할까요?
	- 응답 데이터를 효과적으로 만들기 위해 여러 테이블에 대한 조인 연산이나 저장 프로세저를 실행하는 등의 복잡한 작업을 할 수도 있다.
	- 캐스를 통해 읽기 성능을 향상시키는 것도 가능하다.
- 어떻게 사용할 수 있나요
	- 여러 마이크로서비스가 같은 데이터에 접근하는 경우
		- 특정 마이크로서비스가 해당 데이터에 대한 소유권을 가지지 않으며, 여러 마이크로서비스가 이 데이터를 사용한다.
		- 모든 어플리케이션이 API를 통해서 데이터에 접근하도록 만든다.
	- 레거시 또는 전용 데이터 스토어를 추상화하는 경우
		- 데이터베이스 전용 드라이버를 사용하고, 모든 테이블 및 데이터베이스 구조를 다 파악해야지 사용할수 있다.
		- 하지만 해당 방식으로 접근하는 것은 좋은 방식이 아니고 API 를 통해서 접근할수 있도록 API를 만드는 것이 좋다.
- 고려해야 할 사항들
	- 클라우드 네이티브 어플리케이션에서 여러 마이크로서비스가 같은 데이터에 접근하는 것은 피해야하는 패턴이다. 마이크로서비스간 강한 연관성이 생기며 스스로 크기를 조절하거나 발전하기 어렵게 만들기 때문이다. 하지만 현실적으로는 발생하며, API를 통해 데이터를 접근하게 만들어서 연관성을 느슨하게 만들수 있다.
- 관련 패턴들
	- 캐싱 패턴: 로컬 또는 분산 캐싱을 통해 데이터를 서비스 형태로 제공할 때 데이터 읽기 성능을 최적화할 수 있다.
	- 성능 최적화 패턴: 데이터 캐싱과 더불어 데이터베이스에서 테이블 조인 연산이나 저장 프로시저를 실행하는 등의 방법을 통해 복잡한 질의들을 처리함으로써 성능을 향상시킬 수 있는 방법이다.
	- Materialized View 패턴: API를 통해 데이터에 접근하는 방식은 많은 성능을 요구하기 마련이다. 서로 다른 데이터스토어에 저장된 데이터들을 조합해서 처리해야 하는 경우, 데이터를 로컬 스토어에 중복 저장하고 Materialized View를 만들어 질의 성능을 향상시킬 수 있다.
		- Q. 쓰시는 분 계신가요? 저희 MongoDB에서 쓰려고 했는데, DBA가 꼭 써야하냐고 물어봐서... 못썻습니다.
	- 볼트 키 패턴: API 보안과 더불어 어떤 서비스가 데이터에 접근하는지 알 수 있으면 API 호출자가 누군지 알아내고 그에 적합한 보안 정책 및 데이터 보호 정책을 적용하는 데 도움이 된다.

### 4.5.2. 조합 데이터 서비스 패턴
- 하나 이상의 데이터 서비스로부터 데이터를 읽어서 조합하고 필요한 경우 더 복잡한 작업을 통해 풍부하고 명료한 데이터를 제공한다.
- 사용자가 아닌 데이터 서비스 쪽에서 데이터를 조합하기 때문에 서버사이드 매시업 패턴이라고 부른다.
- 어떻게 동작할까요?
	- 여러 데이터 서비스와 자신만의 고유한 데이터 스토어로부터 데이터를 가져와서 조합한 데이터를 제공한다.
	- 조합한 데이터를 캐시에 저장해서 성능을 향상시킬 수도 있다.
- 어떻게 사용할 수 있나요
	- 데이터 서비스가 잘게 나누어져 있으면 클라이언트는 원하는 데이터를 얻기 위해 여러 서비스에 질의를 보낼수 밖에 없다. 이를 공통 서비스 형태로 묶어서 제공함으로써 클라이언트 측에서 이루어지는 중복작업을 줄일수 있다.
- 고려해야할 사항들
	- 여러 서비스들을 조합해야한다. 중복되지 않는 조합 데이터를 처리하기 위해 조합 데이터 서비스를 만들면 불필요한 서비스 계층만 추가하게 되고, 조합한 데이터를 재사용하는 경우도 줄어든다.
	- 클라이언트 측에서 데이터를 재사용하고 복잡도를 줄이는 정도와 서비스 계층을 추가함으로써 추가 지연 시간과 관리 복잡도를 비교해서 이득이 클 경우에만 사용하는 것이 좋다.
- 관련 패턴들
	- 캐싱 패턴: 데이터 읽기 성능 최적화를 제공하며, 경우에 따라 백엔드 데이터 스토어 혹은 데이터 서비스를 사용할 수 없는 상황에서도 탄력적인 데이터 읽기 서비스를 제공할 수 있다.
	- 클라이언트 사이드 매시업 패턴: 사용자의 웹 브라우저와 같은 클라이언트 측에서 데이터를 조합할 수 있다. 비동기 데이터 읽기가 가능하고 부분데이터 만으로 데이터 조합이 가능한 경우 좋은 성택이 될수 있다.

### 4.5.3. 클라이언트-사이드 매시업 패턴
- 클라이언트 측이 여러 데이터 서비스에서 데이터를 가져와서 조합하고 사용한다.
- 어떻게 동작할까요?
	- 여러번의 비동기 호출을 통해 웹 사이트 콘텐츠를 여러 조각으로 가져오고 그때그때 렌더링한다.
	- RIA (Rich Internet Application) 이라고도 부른다.
- 어떻게 사용할 수 있나요?
	- 중요한 데이터를 낮은 지연 시간으로 보여주기
	- 웹 페이지를 훨씬 더 빨리 불러오는 듯한 효과
- 고려해야 할 사항들
	- 부분 데이터를 사용자에게 바로 보여줄수 있거나, 일부데이터를 의미 있게 사용할수 있을 경우에만 이패턴을 사용하는 것이 좋다.
- 관련 패턴
	- 조합 데이터 서비스 패턴: 콘텐츠를 동기적으로 가져와서 데이터와 조합하는 것이 자주, 그리고 여러 서비스에서 사용되는 경우 적용하면 좋은 패턴이다.
	- 캐싱 패턴: 전반적인 지연 속도를 개선하고자 하는 경우 캐시 데이터를 사용하는 것이 좋다.

### 4.5.4. 데이터 조합 패턴 정리


| 패턴            | 사용해야 할 경우                                                                                   | 사용하면 안되는 경우                                                                                | 이점                                                                                          |
| ------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- |
| 데이터 서비스       | - 단일 서비스가 데이터를 소유하지 않으며, 여러 마이크로 서비스가 데이터에 의존하는 경우                                          | - 데이터가 분명히 특정 서비스에 귀속되는 경우, 불필요한 마이크로서비스를 추가하게 되면 관리 복잡도만 증가함                              | - 서비스 간 결합도를 낮춰줌<br>- 공유 데이터에 대한 작업을 더 잘, 그리고 안전하게 제어할 수 있음                                 |
| 조합 데이터 서비스    | - 많은 클라이언트가 필요한 데이터를 얻기 위해서 여러 서비스에 질의를 보내는 경우, 그리고 이런 데이터를 여러 클라이언트가 공통으로 사용하고 재사용이 가능한 경우 | - 하나 또는 소수의 클라이언트에서만 사용하는 데이터의 경우<br>- 클라이언트에서 데이터를 조합하는 방법을 일반화하여 다른 클라이언트에서 재사용이 불가능한 경우 | - 데이터를 얻기 위핸 클라이언트 측의 중복 작업을 줄여주고 이를 공통 서비스로 제공<br>- 캐시나 정적 데이터 등을 통해 데이터를 더 탄력적으로 제공할 수 있음 |
| 클라이언트 사이드 매시업 | - 일부 데이터만으로도 의미 있는 작업이 가능한 경우, 예를 들어 웹 브라우저에서 다른 데이터에 종속적이지 않은 데이터만 별도로 표시하는 경우             | - 별도로 가져온 데이터들을 합치거나 조합하는 등 별도의 처리과정을 거쳐야만 의미 있는 작업이 가능한 경우                                | - 좀 더 응답이 빠른 어플리케이션을 만들 수 있음<br>- 사용자 대기 시간을 줄일 수 있음                                        |

## 4.6. 데이터 확장 패턴
- 클라우드 네이티브 어플리케이션의 부하가 증가하게 되면 서비스나 데이터 스토어가 병목지점이 될수 있다.
- 복잡성을 줄이면서, 일관성이나 트랜잭션과 같은 요구사항을 만족해야한다.
- Q. 다들 일관성 모델을 어플리케이션에서 정하고 코딩하나요?
	- 알고 있는 일관성 모델은
		- 강한 일관성 (Strong)
		- 결과적 일관성 (Eventual)
		- Casual 일관성
- 관계형 데이터베이스는 처음부터 확장성을 고려하지 않고 설계되었습니다.
	- PostgreSQL 은 multiple-master 가 되지 않나?
	- Vitess 도 있는데 흐음...

### 4.6.1. 데이터 샤딩 패턴
- 데이터 스토어를 샤드로 나누어 데이터 저장 및 읽기 규모를 조절하는 것
- 어떻게 동작할까요?
	- 수평적 데이터 샤딩
	- 수직적 데이터 샤딩 (hot-cold)
	- 기능적 데이터 샤딩 (heavy)
	- 디렉토리 기반 샤딩: 키를 기반으로 위치 정보를 저장하고, 데이터 재배치되는 경우 클라이언트는 변경된 위치를 알아내기 위해 다시 샤드키를 통해 정확한 위치를 검색해야한다.
	- 범위 기반 데이터 샤딩: 연속적인 특성이 있으면 사용하기 좋은 방법이다. 주로 날짜나 시간에 따라서 데이터를 나누고 저장할때 유용하다
	- 해시 기반 데이터 샤딩: 데이터 필드를 샤드 키로 사용하거나, 날짜 범위 등으로 ㅔㄷ이터를 나눌 경우 데이터가 균등하게 배분되지 않는다. 샤드간 좀 더 균일한 양으로 나누고자 하는 경우 사용할 수 있다.
	- Q. redis 는 cluster모드로 동작할때 어떻게 동작하게 되나요?
		- https://ssoco.tistory.com/18#:~:text=Redis%20Cluster%EB%8A%94%20Multi%2Dmaster%2C%20Multi%2Dslave%20%EA%B5%AC%EC%A1%B0%EB%A5%BC%20%EA%B0%80%EC%A7%80%EB%A9%B0%20%EA%B0%81,%EC%9D%B4%EB%9D%BC%EB%8A%94%20Data%20%EC%A0%80%EC%9E%A5%EA%B5%AC%EC%97%AD%EC%9D%84%20%EB%8B%A4%EB%A5%B8%20Master%EC%99%80%20%EB%82%98%EB%88%84%EC%96%B4%20%EC%86%8C%EC%9C%A0%ED%95%A9%EB%8B%88%EB%8B%A4.
		- https://configsys.medium.com/redis-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%98%88%EC%A0%95-d8b05ec77386
	- mongodb 의 shard cluster 동작
		-  mongodb router를 통해서 거기서 쿼리를 보내서 조회한다.
		- https://ozofweird.tistory.com/entry/MongoDB-Sharding
- 어떻게 사용할 수 있나요
	- 데이터를 싱글 노드에 저장하지 않는 경우, 또는 데이터를 분산해서 지연 시간을 낮출 때 사용할 수 있다.
	- 싱글 노드에서 멀티 노드로 확장
		- 스토리지나 연산, 네트워크 대역폭과 같은 자원들이 병목이 될때 데이터 샤딩을 사용할 수 있다.
	- 데이터 조회 시간 단축을 위한 데이터 분리
		- 데이터의 여러 필드를 조합해서 샤드 키를 만들고 데이터를 분리할 수 있다.
		- 날짜와 시간 범위로 데이터를 나눌수 있다.
			- 주기적으로 핫 샤드의 데이터를 아카이브 샤드로 옮겨주는 작업이 필요하다.
			- elasticsearch
				- https://techblog.woowahan.com/7425/
				- https://mangkyu.tistory.com/209
		- 지리적 데이터 분산
- 고려해야 할 사항들
	- 데이터 추가, 삭제, 또는 질의 방식의 변경으로 샤드의 불균형은 언제든 일어날 수 있다.
	- 재배치 작업을 효과적으로 하려면 샤드 크기를 가급적 작게 유지하는 것이 좋다.
	- 여러 샤드 간 데이터 어그리게이션 처리는 어그리게이션 종류별로 다르다.
	- 샤드 키를 만들 때는 자동으로 그 값이 증가하는 필드는 사용하지 않는 것이 좋다. 샤드끼리는 서로 통신하지 않기 때문에 자동으로 증가하는 필드 값을 샤드 키로 사용할 경우 여러 샤드가 동일한 샤드 키를 생성할 수 있으며 서로 다른 데이터를 로컬에서 같은 키로 참조하는 일이 일어날 수 있다.
		- 키 생성
			- snowflake: https://en.wikipedia.org/wiki/Snowflake_ID
			- elastic search 의 키 생성 방식: https://medium.com/@musabdogan/understanding-elasticsearchs-auto-generated-id-is-duplication-a-concern-3ced51e14f93
			- UUIDv4 vs UUIDv7: https://devswim.tistory.com/60
- 관련 패턴
	- 구체화된 뷰 패턴: 각 샤드의 종속 데이터를 서비스의 로컬 스토어에 복제하여 데이터 질의 성능을 향상시키고 서비스 또는 데이터 스토어에 대한 여러 번의 검색 호출을 막을 수 있다. 로컬 스토어에 복제된 데이터는 약한 일관성을 가지기 때문에 이 패턴은 종속 데이터의 일관성이 그다지 중요하지 않는 경우에만 사용해야 한다.
		- notion 관련: https://www.notion.com/blog/data-model-behind-notion
	- 데이터 지역성 패턴: 서로 연관이 있는 데이터들을 샤드에 모아서 색인을 만들고 더 효과적인 데이터 조회를 위해 저장 프로시져를 실행할 수 있다.

### 4.6.2. 명령과 조회 책임 분리 패턴
- CQRS(Command and Query Responsibility Segregation)
- 어떻게 동작할까요?
	- 데이터 변경 또는 쓰기와 같은 명령과 데이터 읽기에 해당하는 조회를 별도의 서비스로 나눈다. 각 서비스를 쉽게 모델링하고 서비스들이 독립적으로 크기를 확장할 수 있다.
	- 명령 및 질의에는 데이터 스토어에 특하된 정보를 제공해서는 안되고, 어플리케이션과 관련된 데이터를 다루어야 한다.
	- 카프카와 같은 로그 기반 큐 시스템을 활용한 이벤트 소싱 패턴으로 서비스 간 이벤트들을 전달할 수 있다.
- 어떻게 사용할 수 있나요
	- 명령과 질의에 서로 다른 도메인 모델 사용하기
	- 작업 분산과 데이터 경합 감소
- 고려해야 할 사항들
	- CQRS 패턴은 명령과 질의 작업을 분리함으로써 높은 가용성을 제공한다. 명령 혹은 질의 서비스 중 하나가 동작핮지 않는 경우에도 전체 시스템이 멈추지 않는다.
	- 질의 서비스의 경우 거의 무한한 확장이 가능하고, 적절한 수의 데이터 복제본이 있다면 질의 서비스가 멈추지 않고 동작한다고 보장할 수 있다. 하지만 명령 작업은 데이터 샤딩 등의 패턴을 사용해서 합치는 과정에서 데이터 충돌이 발생할수 있기 때문에 이를 방지해야한다.
	- CQRS는 명령과 질의 작업 간에 높은 일관성이 필요한 경우 사용해서는 안된다.
	- CQRS를 할때는 ORM과 같은 자동화 도구를 사용하기 어렵다.
	- CQRS 패턴은 시스템 구조가 매우 복잡해진다. 비지니스 로직이 복잡하지 않는다면 CQRS 패턴을 사용하지 않는 것이 좋다.
- 관련 패턴들
	- 이벤트 소싱 패턴: 명령 서비스에서 데이터 갱신 이벤트를 질의 서비스로 전달할때 이벤트 소싱 패턴을 사용할 수 있다. 해당 패턴을 사용하면 명령과 질의 모델 사이에 약한 일관성을 제공하게 되며, 시스템 구조를 더 복잡하게 만들 수 있다.
	- 구체화된 뷰 패턴: 명령과 질의 모델이 간단하다면 CQRS 패턴 대시 구체화된 뷰 패턴을 사용해서 확장성을 높이는 것이 좋다.
	- 데이터 샤딩 패턴: 데이터 샤딩 패턴을 사용해서 데이터를 분리하고 명령 서비스를 확장할 수 있다. 질의 서비스에는 성능상 이점이 그다지 없다.
	- API 보안: 명령 및 질의 서비스의 보안성을 향상시키기 위해 이 패턴을 사용할 수 있다.

### 4.6.3. 데이터 확장 패턴 정리

| 패턴                   | 사용하면 좋은 경우                                                                                                                | 사용해서는 안되는 경우                                                                                   | 이점                                                                                                                                                                                  |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 데이터 샤딩               | - 데이터에 각 데이터를 고유하게 식별할 수 있는 하나 또는 그 이상의 필드가 있어서 데이터를 하위 집합으로 묶을수 있는 경우                                                    | - 샤드 키를 통해 각 샤드에 균등한 크기의 데이터를 저장할 수 없는 경우<br>- 전체 데이터 셋의 중앙 값 산출과 같이 데이터 처리 작업에 전체 데이터가 필요한 경우 | - 각 데이터의 필드를 조합해서 샤드 키를 만들고 데이터를 샤드 단위로 묶을 수 있음<br>- 클라이언트와 지역적으로 가까운 곳에 관련 데이터를 저장하고 최적화할 수 있음<br>계층적 샤드 또는 시계열 기반 샤드를 만들어서 검색 시간을 최적화할 수 있음<br>- 샤드 키가 없는 질의를 부 색인을 사용해서 처리할 수 있음 |
| 명령 및 조회 책임 분리 (CQRS) | - 어플리케이션에서 다음과 같이 고성능을 요구하는 데이터 변경 작업을 처리하는 경우: 데이터 검증, 보안성 검증, 데이터 변환<br>- 복잡한 조인 연산 또는 데이터 매핑과 같은 고성능 질의 연산을 처리해야 하는 경우 | - 명령(데이터 변경)과 조회(데이터 질의) 서비스 간 높은 일관성이 요구되는 경우<br>- 명령과 질의 모델 간 연관성이 큰 경우                      | - 명령 및 질의 작업 간 영향도를 최소화 함<br>- 명령 및 질의 데이터를 각각의 경우에 잘 맞는 별도의 데이터 스토어에 저장하고 사용할 수 있음<br>- 명령 질의 간에 별도의 보안 정책을 적용할 수 있음<br>- 명령 및 질의 서비스를 서로 다른 팀에서 개발하고 관리할 수 있음<br>- 고가용성을 제공함      |

## 4.7 성능 최적화 패턴
- 데이터 사용에서 성능을 향상시킬 수 있는 가장 기본적인 방법은 색인이다.
- 과도한 색인 사용은 오히려 읽기와 쓰기 성능을 감소시킨다.
- 읽기 모델을 간단하게 만드는 데는 데이터 비정규화가 좋다. 데이터 비정규화는 조인 연산을 제거해서 읽기 성능을 향상시킨다.

### 4.7.1. 구체화된 뷰 패턴
- Materialized View Pattern은 데이터를 처리하는 곳 가까운 곳에 미리 구체화된 뷰로 저장해 둠으로써 질의에 대한 데이터 조회를 효과적으로 처리하는 방법이다.
- 어떻게 동작할까요
	- 의존 서비스로부터 데이터를 비동기로 복제해서 사용한다.
- 어떻게 사용할 수 있나요
	- 데이터 읽기 효율성 증대
	- 안전한 시스템에서 민감하지 않은 데이터 제공
- 고려해야 할 사항들
	- 구체화된 뷰 패턴은 데이터 읽기 성능을 향상시켜 서비스 성능을 향상시킬 뿐만 아니라 불필요한 데이터를 처리할 필요가 없고 의존하는 서비스를 파악하지 않아도 되기때문에 서비스 로직이 간단해진다는 장점이 있다.
	- 서비스 탄력성을 제공한다. 데이터가 로컬 스토어에 복제되어 있기 때문에
	- 데이터일관성이 중요할 경우 사용하면 안된다. 데이터 불일치가 발생할수 있다.
- 관련 패턴들
	- 데이터 지역성 패턴: 코드 실행을 데이터와 가까운 곳에서 함으로써 데이터 조회를 더 효율적으로 한다.
	- 조합 데이터 서비스 패턴: 데이터 조합을 서비스 수준에서 할 수 있거나 의존 서비스가 정적 데이터를 가지고 있어서 조합 데이터 서비스가 이 데이터를 캐시로 저장할 수 있는 경우, 구체화된 뷰 패턴 대신 사용할 수 있다.
	- 명령 및 질의 책임 분리 패턴: 질의 처리를 위해서 CQRS 패턴을 사용할 수 있다.
	- 이벤트 소싱 패턴: 데이터를 한 원천에서 다른 곳으로 복제할 때 이 패턴을 사용한다. 데이터 변경은 이벤트로 만들어져 전달된다.

### 4.7.2. 데이터 지역성 패턴
- 데이터 처리 로직을 최대한 데이터와 가까운 곳에서 실행한다.
- 사용하는 대역폭을 줄일수 있다.
- 어떻게 동작할까요
	- 데이터를 옮기는 것보다 실행 코드를 옮긴다.
- 어떻게 사용할 수 있나요
	- 데이터 읽기 지연 시간 감소
	- 데이터 조회 시 네트워크 대역폭 소비 감소
- 고려해야할 사항들
	- - 데이터 노드의 CPU 자원 사용도 최대화하게 될수 있다. 대부분의 데이터 노드들의 IO 작업에 치중하는 경향이 있기 때문에 질의가 간단하다면 해당 패턴을 사용할 수 있다.
	- 질의의 결과가 입력 데이터 크기와 거의 차이가 없는 경우 이 패턴은 사용하지 않는 것이 좋다.
	- 데이터 스토어가 마이크로 서비스에서 전용으로 사용하는 경우에만 사용해야한다. 공유 데이터베이스라면 사용하면 안된다. 
- 관련 패턴들
	- 구체화된 뷰 패턴
	- 캐싱 패턴

### 4.7.3. 캐싱 패턴
- 어떻게 동작할까요?
	- 캐시히트, 캐시 미스
	- read-through cache operation
		- write 가 발생할시 cache invalidation이 반드시 필요하다.
	- write-through cache operation
	- 메모리가 모자라서 데이터를 캐시에 추가하지 못할수 있기 때문에 LRU, FIFO, MRU 등 캐시를 expire 시키는 알고리즘이 필요하다.
- 어떻게 사용할 수 있나요?
	- 데이터 조회 시간 단축
	- 정적 콘텐츠를 가져오는 시간 단축
	- 데이터 스토어 경합 감소
	- 데이터 조회 시간 단축을 위한 데이터 미리 가져오기
	- 데이터 스토어 의존성 해소를 통한 고가용성 구현
	- 단일 노드에 저장할 수 없는 데이터를 캐시에 저장하기
- 고려해야할 사항
	- 캐시 데이터는 단일 데이터 소스로 사용해서 안되며, 고가용성을 반드시 만족팔 필요도 없다.
	- 캐시를 사용할 수 없는 경우에도 어플리케이션은 제대로 동작해야한다.
	- 서비스 요청에 대한 응답이 대부분 정적 데이터로 구성되고 데이터 일부만 자주 변경되는 경우가 있다. 
	- 캐시를 삭제하는 정책 대신, 데이터가 흘러 넘칠때 로컬 캐시가 이에 대응하도록 만들수도 있다. 이럴 경우 storage를 추가로 사용한다.
	- 캐시 유효 시간은 너무 길거나 짧지 않게, 적당한 시간을 지정한다. 캐시 유효 시간이 너무 길면 데이터 스토어와 캐시 데이터 간 불일치가 많아지며, 너무 짧으면 데이터를 데이터 스토어에서 자주 가져와야 하기 때문에 캐시를 쓰는 의미가 없어진다.
	- 캐시 데이터를 로컬에 저장할 때 가장 큰 문제점은 서비스를 확장할 때 각 서비스가 자신만의 로컬 캐시를 가지게 되며 서로 다른 시점에 데이터 스토어와 캐시 데이터를 동기화 한다는 것이다.
	- 가능하다면 데이터 스토어와 마찬가지로 캐시에 대한 배치 데이터 업데이트를 수행하는게 좋다. 여러 캐시가 변경될 경우 낙관적 방식과 비관적 방식이 있다. 비관적 방식의 경우 확장성이 떨어지기 때문에 아주 짧은 시간이 소요될때만 사용해야한다.
	- 캐시를 강제 만료하거나 데이터를 다시 만들수 있도록 하는 것이 좋다.
	- 몇몇 상용 캐시 서비스는 볼트 키 패턴 등을 통해 데이터 보안성을 제공한다. 하지만 대부분의 캐시는 보안성을 염두에 두고 설계되지 않았기 때문에, 캐시 데이터를 외부에 직접 제공하는 것은 피해야한다.
- 관련 패턴들
	- 데이터 샤딩 패턴: 데이터 스토어를 확장하는 것과 비슷한 방법으로 캐시를 확장할수 있다. 또한 데이터를 지리적으로 분산해서 캐시에 있는 관련 데이터가 실제 사용하는 서비스와 가까운 곳에 배포할 수 있다.
	- 탄력적 연결성 패턴: 캐시 데이터를 사용할 수 없는 경우 데이터 원천을 통해 서비스를 계속 할 수 있다.
	- 데이터 서비스 패턴: API 보안성과 데이터 서비스 패턴을 함께 사용해서 분산 캐시에 대한 서비스 계층을 제공하고 데이터 사용자에게 좀 더 비지니스 친화적인 API를 제공할 수 있다.
	- 볼트 키 패턴: 액세스 토큰을 통해 서드파티가 캐시에 안전하게 직접 접근할 수 있도록 한다.
	- 이벤트 소싱 패턴: 모든 로컬 캐시에 캐시 무효화 요청을 전파할 때 사용한다. 캐시 데이터에 대한 약한 일관성을 제공해주며 데이터 소스가 여러 서비스로 인해 변경되어 데이터가 쓸모 없어지는 경우를 최소화해준다.

### 4.7.4. 정적 콘텐츠 호스팅 패턴
- 데이터 스토어의 정적 콘텐츠를 클라이언트와 가까운 곳에 배포하여 추가 자원 소모 없이 낮은 지연 시간으로 클라이언트에게 콘텐츠를 제공하는 방법
- 어떻게 동작할까요
	- CDN(Content Delivery Network)
- 어떻게 사용할 수 있나요
	- 빠른 정적 콘텐츠 제공
	- 렌더링 서비스의 자원 사용량 감소
- 고려해야할 사항들
	- 정적 콘텐츠의 크기가 작은 경우에는 직접 주는게 더 빠르다
	- 클라이언트 구현이 복잡해질수도 있다.
		- 브라우저는 이미 되어 있지만, 다른 클라이언트를 사용할 경우 이걸 직접 다 구현해야한다.
	- 정적 콘텐츠를 안전하게 보관해야할 필요가 생긴다. 만약 인증된 사용자만 정적 콘텐츠에 접근하는 것을 허용하고 싶다면, API 보안과 데이터 서비스 패턴을 함께 사용하거나 볼트 키 패턴을 같이 사용해야한다.
- 관련 패턴
	- 데이터 샤딩 패턴: 정적 데이터가 많을때 샤드를 나눠서 관리할수 있다.
	- 캐싱 패턴: 정적 데이터는 거의 바뀌지 않기 때문에 캐시 데이터의 유효기간을 지정할 필요가 없다.
	- 볼트 키 패턴: 보안성 제공
	- 데이터 서비스 패턴: 정적 콘텐츠를 제공하는 서비스에 API보안 기능을 추가할 수 있다.

### 4.7.5. 성능 최적화 패턴 정리

| 패턴         | 사용하면 좋은 경우                                                                                                                                                                                      | 사용해서는 안 되는 경우                                                                                                               | 이점                                                                                                                                                            |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 구체화된 뷰     | - 데이터 일부를 로컬에서 제공할 수 있으며 나머지 데이터는 지연 시간이 높은 외부 데이터 스토어에서 가져와서 처리할 수 있을 때<br>- 로컬 스토어로 옮기는 데이터 크기가 작으며 거의 변경되지 않을 때<br>- 보안 시스템을 통해서만 접근할 수 있지만 민감하지 않은 데이터를 제공해야 할때                             | - 데이터를 의존 서비스에서 낮은 지연 속도로 가져올 수 있을때<br>- 의존 서비스의 데이터가 빠르게 변경될 때<br>- 데이터의 일관성이 더 중요할 때                                      | - 어플리케이션에 적합한 아무 데이터베이스에나 데이터를 저장할 수 있음                                                                                                                       |
| 데이터 지역성    | - 데이터를 여러 데이터 스토어에서 읽어서 조인이나 데이터 어그리게이션 연산을 수행할 때<br>- 데이터 스토어가 매우 크고 클라이언트가 지리적으로 분산되어 있을때                                                                                                     | - 질의의 결과가 입력 데이터 대부분을 포함할 때<br>- 데이터 노드에서 데이터를 처리하는 비용이 데이터를 네트워크로 전송하는 비용보다 클 때                                            | - 데이터 조회 지연 시간을 낮추고 네트워크 대역폭 소모를 줄임<br>- CPU 사용 효율을 증대하고 전반적인 성능을 최적화함<br>- 결과 데이터를 캐시에 저장하고 요청을 더 효과적으로 처리함                                                  |
| 캐싱         | - 정적 데이터 또는 거의 변경되지 않는 데이터 처리에 적합함<br>- 어플리케이션이 하나 이상의 클라이언트로부터 동일한 질의를 여러 번 받는 경우, 특히 다음 질의가 어떤 데이터를 요구할지 예측할 수 없는 경우<br>- 데이터 스토어 간 경합이 심하거나 여러 클라이언트로부터 동시에 데이터 조회 요청이 발생하는 것을 제대로 처리할 수 없을때 | - 데이터가 자주 변경되는 경우<br>- 신뢰할 수 있는 데이터 원천으로 사용해서는 안됨<br>- 데이터가 아주 중요하며 시스템이 데이터 불일치를 처리할 수 없는 경우                               | - 데이터 일부를 캐시에 저장해서 성능을 향상시킬 수 있음<br>- 캐시 배제 기법을 통해 중복 연산을 제거하고 성능을 향상시킴<br>- 캐시에 정적 데이터를 미리 읽어와서 제공할 수 있음<br>- 캐시 삭제 정책과 함께 사용하면 최근 또는 요구되는 데이터를 캐시에 젖아할 수 있음 |
| 정적 콘텐츠 호스팅 | - 클라이언트에서 요구하는 데이터 일부 또는 전체가 정적 콘텐츠인 경우<br>- 정적 데이터를 여러 환경 또는 지리적으로 떨어진 여러 위치에 제공해야 하는 경우                                                                                                       | - 접근 시간이나 위치를 기록하는 것과 같이 클라이언트에 제공하기 전 정적 콘텐츠를 수정해야 하는 경우<br>- 제공하는 정적 콘텐츠의 크기가 작은 경우<br>- 클라이언트 측에서 정적데이터를 받아서 조합할 수 없는 경우 | - 지리적으로 데이터를 나누고 클라이언트와 가까운 곳에 저장함으로써 클라이언트에게 더 빠르게, 낮은 지연시간으로 콘텐츠를 제공할 수 있음<br>- 렌더링 서비스의 자원 소모량을 줄일 수 있음                                                    |
## 4.8. 신뢰성 패턴
### 4.8.1. 트랜잭션 패턴
- 어떻게 동작할까요
	- 트랜잭션은 ACID 속성을 따른다.
	- 트랜잭션의 수준은, read uncommitted, read committed, repeatable read, serializable 로 나뉜다.
- 어떻게 사용할 수 있나요
	- 여러 작업을 단일 작업으로 묶어서 실행하기
	- 여러 시스템 간 협력 작업
		- 2PC 를 사용하는 XA 트랜잭션 등을 적용할 수 있다.
- 고려해야 할 사항들
	- 가능하다면 멱등성 있게 작업을 만들고, 이를 이용해 트랜잭션 없이도 실행되도록 하는게 좋다.
	- 실행은 동기화해야하고 세개 이상의 시스템이 연계된다면 사가 패턴을 사용하는 것이 좋다.
	- 모든 업데이터가 단일 데이터 스토어에서 이루어지거나, 모든 단계가 마치 하나의 원자적 작업처럼 동시에 이루어져야 한다면 사가 패턴 대신 XA 트랜잭션을 사용하는게 좋다.

### 4.8.2. 신뢰성 패턴 정리

## 4.9 보안: 볼트 키 패턴
- vault key pattern 은 신뢰할 수 있는 토큰을 가지고 데이터 스토어에 직접 접근할 수 있도록 해준다.
- 어떻게 동작할까요
	- 볼트 키 패턴은 클라이언트가 제출하는 신뢰할 수 있는 토큰에 기반하여 동작한다.
	- 토큰은 데이터 스토어가 검증한다.
- 어떻게 사용할 수 있나요
	- 데이터 스토어가 데이터에 접근하고자 하는 클라이언트를 인증하고 확인하기 위해 ID 제공자에 접근할 수 없을 때 볼트 키 패턴을 사용할 수 있다.
- 고려해야 할 사항들
	- 악의적인 사용자가 볼트 키를 가로채거나 위조할수 있다. 키의 유효시간을 적절한 값으로 지정해야한다.

## 4.10 데이터 관리 패턴 구현기술
### 4.10.1. 관계형 데이터베이스 시스템

### 4.10.2. 아파치 카산드라
- 페이스북에서 내부적으로 사용하기 시작했다.
- 컬럼 스토어, 제로 다운 타임으로 동작할 수 있는 것으로 유명하다
- 카산드라의 쓰기 성능은 읽기 성능에 비해 훨씬 좋다.
- 설계상 약한 일관성을 제공한다. 하지만 일관성 수준을 변경해서 어플리케이션에 따라 약한 일관성이나 강한 일관성을 모두 구현할 수 있다.

### 4.10.3. 아파치 HBase
- HDFS에서 동작하는 분산 NoSQL 컬럼 스토어
- 맵리듀스 작업을 처리할수 있다.
- HBase는 다른 시스템에 상호 의존적이며 설정이나 보안, 유지 관리가 더 어렵다. 
- HBase는 마스터워커 배포를 사용하기 때문에 단일 장애점을 가진다.
- 고가용성이 필요하다면 HBase보다는 카산드라가 더 좋다.
- HBase는 일관성이 카산드라보다 더 좋다.

### 4.10.4. MongoDB
- 색인에 더 민감하다.
- 가용성보다는 데이터 일관성을 더 중요시한다.
- 주 스토어가 사용이 불가능한 경우 읽기 및 쓰기 작업은 10-40초 가량 중단되며 그동안 복제 스토어 중 하나가 주 스토어로 선출된다.


### 4.10.5. 레디스
- 인메모리 키-값 데이터 스토어
- RDB(Redis Database Backup)과 AOF(Append Only File) 두가지 형태로 데이터를 영구 저장할 수 있다.
- 단일 마스터 노드와 여러 개의 복제 노드를 통해 고가용성이 유지되며, 데이터 샤딩 패턴을 통해 마스터와 복제 노드간 데이터 샤딩을 통한 확장성도 제공한다.
- 하지만 레디스는 질의 처리나 복잡한 데이터 처리, 데이터 어그리게이션과 같은 표준 관계형 데이터 스토어가 제공하는 기능이 없기 때문에 관계형 데이터베이스 대신 사용할 수 있는 NoSQL 대체품으로는 부적절하다.

### 4.10.6. Amazon DynamoDB
- 키-값 및 도큐먼트 데이터베이스로 낮은 지연시간과 높은 확장성을 제공한다.

### 4.10.7. Apache HDFS
- 분산파일 시스템으로 비교적 저렴한 하드웨어에서 실행하더라도 최소 세 개의 복제본을 분산 저장함으로써 높은 데이터 탄력성을 가지도록 설계되었다.
- HDFS는 데이터를 여러 데이터 노드에 저장하며 데이터에 대한 모든 메타 데이터를 단일 노드의 메모리에 저장한다.

### 4.10.8 Amazone S3
- Simple Storage Service
- Object Storage

### 4.10.9 Azure Cosmos DB
- 완전 관리형 NoSQL 데이터 스토어
- 키-값, 도큐먼트, 컬럼, 그래프 데이터베이스로 사용할수 있다.
- 낮은 지연 시간으로 데이터를 저장하고 조회할수 있다.
- 단말간 암호화나 접근 제어 제공

### 4.10.10. Google Cloud Spanner
- 완전 관리형 관계형 데이터 스토어
- 무한한 크기 확장과 강력한 일관성 제공
- SQL질의를 처리할수 있다.

### 4.10.11 구현 기술 정리

| 데이터 스토어                  | 사용하면 좋은 경우                                                                                                                                     | 사용해서는 안 되는 경우                                                                                                      |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| 관계형 데이터베이스 관리 시스템(RDBMS) | - 트랜잭션과 ACID 속성이 필요한 경우<br>- 데이터 간 상호 관계를 유지해야 하는 경우<br>- 작거나 중간 정도 양의 데이터를 다루는 경우                                                             | - IoT 데이터와 같이 데이터가 계속 증가하느 ㄴ경우<br>- XML이나 JSON 이진 데이터 포맷과 같은 데이터를 처리하는 경우<br>- 어플리케이션에서 일정 수준 이상의 가용성을 요구하는 경우     |
| 아파치 카산드라                 | - 고가용성이 필요한 경우<br>- 높은 확장성이 필요한 경우<br>- 중앙화되지 않은 솔루션이 필요한 경우<br>- 읽기보다 쓰기가 빨라야하는 경우<br>- 데이터 조회가 대부분 파티션 키를 통해 이루어지는 경우                        | - 기존의 데이터가 자주 변경되는 경우<br>- 파티션 키에 해당하지 않는 컬럼으로 데이터에 접근해야하는 경우<br>- 트랜잭션이나 복잡한 조인 연산, ACID 속성과 같은 관계형 기능을 필요로 하는 경우 |
| 아파치 HBase                | - 일관성이 필요한 경우<br>- 확장성이 필요한 경우<br>- 중앙화되지 않은 솔루션이 필요한 경우<br>- 높은 읽기 성능이 필요한 경우<br>- 랜덤 접근 또는 실시간 데이터 접근이 필요한 경우<br>- 페타바이트 단위의 데이터를 저장해야 하는 경우 | - 어플리케이션이 일정 수준 이상의 가용성을 요구하는 경우<br>- 기존의 데이터가 자주 변경되는 경우<br>- 트랜잭션이나 복잡한 조인 연산, ACID 속성과 같은 관계형 기능을 필요로 하는 경우     |
| 몽고DB                     | - 일관성이 필요한 경우<br>- 중앙화되지 않은 솔루션이 필요한 경우<br>- 도큐먼트 스토어가 필요한 경우<br>- 여러 키를 통한 데이터 검색이 필요한 경우<br>- 높은 쓰기 성능이 필요한 경우                               | - 어플리케이션이 일정 수준 이상의 가용성을 요구하는 경우<br>- 트랜잭션이나 복잡한 조인 연산, ACID 속성과 같은 관계형 기능을 필요로 하는 경우                              |
| 레디스                      | - 확장성이 필요한 경우<br>- 인메모리 데이터베이스가 필요한 경우<br>- 데이터 복구를 위해 영구히 저장할수 있어야하는 경우<br>- 캐시나 큐, 실시간 스토리지가 필요한 경우                                          | - 복잡한 연산을 통한 저장 및 질의가 가능한 전통적인 데이터베이스가 필요한 경우                                                                      |
| 아마존 다이나모 DB              | - 높은 확장성이 필요한 경우<br>- 도큐먼트 스토어가 필요한 경우<br>- 키-값 스토어가 필요한 경우<br>- 높은 쓰기 성능이 필요한 경우<br>- 세밀한 접근 제어가 필요한 경우                                       | - AWS가 아닌 다른 클라우드를 사용하는 경우<br>- 트랜잭션이나 복잡한 조인 연산, ACID속성과 같은 관계형 기능을 필요로 하는 경우                                     |
| 아파치 HDFS                 | - 파일 시스템이 필요한 경우<br>- 큰 파일을 저장하는 경우<br>- 데이터를 한번 저장하고 여러번 읽는 경우<br>- 파일에 대한 맵리듀스 작업을 처리하는 경우<br>- 확장성이 필요한 경우<br>- 데이터 탄력성이 필요한 경우             | - 크기가 작은 파일을 저장하는 경우<br>- 파일 내용을 변경해야 하는 경우<br>- 랜덤 데이터 읽기가 필요한 경우                                                 |
| 아마존 S3                   | - 오브젝트 스토리지가 필요한 경우<br>- 오브젝트에 대한 맵리듀스 작업을 처리하는 경우<br>- 높은 확장 기능이 필요한 경우<br>- 오브젝트 데이터의 일부만 읽어야 하는 경우<br>- 세밀한 접근 제어가 필요한 경우                   | - AWS가 아닌 다른 클라우드 플랫폼을 사용하는 경우<br>- 복잡한 질의를 처리해야 하는 경우                                                             |
| 에저 코스모스 DB               | - 높은 확장 기능이 필요한 경우<br>- 도큐먼트 스토어가 필요한 경우<br>- 키-값 스토어가 필요한 경우<br>- 컬럼 스토어가 필요한 경우<br>- 세밀한 접근 제어가 필요한 경우<br>- 몽고DB와 카산드라 클라이언트 연결이 필요한 경우      | - 애저가 아닌 다른 클라우드 플랫폼을 사용하는 경우<br>- 여러 데이터 파티션에 걸친 트랜잭션이 필요한 경우                                                     |
| 구글 클라우드 스패너              | - 높은 확장 기능이 필요한 경우<br>- 관계형 스토어가 필요한 경우<br>- SQL 질의 처리가 필요한 경우<br>- 클러스터의 모든 노드에 대한 트랜잭션 지원이 필요한 경우                                            | - 구글 클라우드가 아닌 다른 클라우드 플랫폼을 사용하는 경우<br>- ANSI SQL 스펙 지원이 필요한 경우                                                     |

## 4.11. 테스팅
- 테스트를 위해 지켜야하는 사항
	- 테스트는 깨끗하며 미리 생성한 데이터 스토어에서 이루어져야 한다. 테스트는 데이터 스토어의 데이터를 초기화하는 코드와 작업 간 데이터 일관성이 유지되는지 확인하는 코드로 이루어진다.
	- 모든 데이터 스토어 타입과 버전을 테스트해서 발생할 수 있는 예외 상황을 확인해야 한다. 테스트를 위한 데이터 스토어를 도커 인스턴스로 만들어서 여러 환경에서의 테스트를 빠르고 쉽게 시작하며 테스트가 끝나면 테스트 환경을 간단하게 정리할수 있어야한다.
	- 데이터 매핑을 테스트해서 데이터 스토어를 사용할때 모든 필드가 제대로 매핑되는지 확인한다.
	- 서비스가 데이터 삽입이나 쓰기, 삭제, 변경과 같은 작업을 할때, 데이터베이스에 직접 접근할 수 있는 테스트 클라이언트를 통해 데이터 스토어의 상태를 점검해서 서비스가 기대한 대로 동작하는지 검증한다.
	- 관계 제약 및 트리거, 저장 프로시저가 제대로 된 결과를 만들어내는지 확인한다.
- 실제 운영 환경과 비슷한 환경에서 부하테스트를 하는 것이 좋다.
	- 데이터 잠금, 일관성, 성능 관련 병목을 체크할수 있다.
- 데이터 서비스에 의존하는 다른 마이크로서비스를 테스트해야하는 경우 실제 데이터 스토어를 배포할 필요 없이 목업 서비스 API를 사용해서 테스트할수 있다.

## 4.12. 보안
- 데이터 스토어는 볼트 키나 API 보안 등을 통해서 데이터 접근을 제어한다.
- 민감한 데이터를 저장하는 경우 저장하기 전에 암호화 한다.
- 민감 데이터는 다른 데이터와 격리해서 추가적인 보안 정책을 적용하는게 좋다.
- 필요할 경우 마스킹 처리를 해야한다.
- 개인정보 보호법을 준수해야한다.

## 4.13. 관측 가능성 및 모니터링
- 어플리케이션 지표, 로그, 분산 추적 등을 관측해야한다.
- 관측 해야하는 핵심 지표
	- 어플리케이션 메트릭
		- 데이터 스토어 가동시간/상태: 데이터 스토어의 각 노드가 동작 중이며 잘 실행되고 있는지를 나타낸다.
		- 질의 처리 시간: 다섯 종류의 문제가 질의 처리 시간을 길게 만들 수 있다.
			- 비효율적 질의: 여러 개의 복잡한 조인 연산 또는 제대로 색인을 만들지 않는 테이블 사용과 같은 최적화된 질의를 사용하는 경우
			- 데이터 스토어의 데이터 증가: 데이터 스토어가 처리할 수 있는 이상의 데이터를 저장한 경우
			- 동시성: 같은 테이블이나 레코드에 동시에 이루어지는 작업은 데이터 스토어를 잠그고 성능에 영향을 줄 수 있다.
			- CPU/Memory, 디스크 공간 등 시스템 자원의 부족: 데이터 스토어가 실행되고 있는 노드의 시스템 자원이 부족해서 데이터 스토어가 요청을 제대로 처리할 수 없는 경우가 발생한다.
			- 의존 시스템 또는 복제본이 사용 불가능한 상태: 분산 데이터 스토어의 경우 검색 서비스와 같은 의존 시스템이나 복제본이 사용 불가능한 상태라면 해당 시스템을 다시 배포하거나 다른 인스턴스를 찾기 위핸 추가 시간이 소요된다.
		- 질의 실행 응답: 질의 처리가 제대로 동작하는지 확인합니다. 질의가 실패하면 로그 등을 통해 더 자세한 내용을 확인한다.
		- 질의 작업 감사: 이상한 질의나 사용자 작업은 예상하지 못한 결과를 초해해서 데이터 스토어 성능에 영향을 미칠 수 있다. 로그 감사를 통해 이런 이상한 동작을 식별하고 방지할 수 있다.
	- 시스템 지표: CPU 점유율이나 메모리 사용량, 사용 가능한 디스크 공간, 네트워크 사용량, 디스크 IO 속도 등을 모니터링 해서 효과적으로 데이터를 처리하기에 충분한 시스템 자원이 있는지 확인 할 수 있다.
	- 데이터 스토어 로그
	- 주 데이터스토어와 복제 데이터 스토어 간 통신에 소요되는 시간과 처리량: 네트워크에서 발생하는 문제를 파악할 수 있으며 상태가 좋지 않은 데이터 스토어 노드를 찾아서 대체할 수 있다.
- 보통 백분위 값을 사용해서 분석할수 있고
- ES + Kibana

## 4.14. 데브옵스
- 고려 사항
	- 사용할 데이터 스토어 유형을 정한다.
		- 관계형 데이터베이스, NoSQL, FileSystem
	- 배포 패턴을 설정한다.
		- 클라이언트의 유형
		- 얼마나 많은 노드를 사용할 것인가
		- 데이터 스토어를 쿨라우드 벤더에서 관리할 것인가, 혹은 자체 관리할 것인가
		- 복제는 어떻게 할 것인가
		- 데이터는 어떻게 백업할 것인가
		- 재해 복구는 어떻게 할 것인가
		- 데이터는 어떻게 보호할 것인가
		- 데이터 스토어를 어떻게 모니터링할 것인가
		- 데이터 스토어와 그 관리 비용이 어느 정도인가
	- 데이터 보호 정책을 적용한다.: 데이터스토어는 민감하고 중요한 비지니스 데이터를 가지고 있을 수 있으므로 반드시 보호해야한다. 데이터 스토어는 물리적, 그리고 소프트웨어 적으로 보호하면, 엄격한 접근 제어와 데이터 암호화, 로그 감사로 이루어진다.
	- 관측 가능성을 확보하고 모니터링을 설정한다.: 마이크로서비스와 마찬가지로 데이터 스토어에도 관측 가능성을 설정하고 모니터링을 통해 계속 정상적으로 동작하도록 관찰할 수 있다. 이를 통해서 데이터 샤드 재배치와 같은 데이터 확장 문제를 해결할 방법을 찾거나 어플리케이션의 성능 및 확장성을 향상시킬 수 있는 다른 디자인 패턴을 적용해볼 수 있다.
	- 자동화된 지속적 전달을 사용한다.: 데이터 스토어의 경우 자동화나 지속적인 전달이 그다지 직관적이지 않을 수 있다. 데이터 스토어 스키마를 처음 초기화하고 난 뒤, 어플리케이션이 점점 커지는 과정에서 하위 호환성을 유지하는 것은 결코 쉬운 일이 아니다. 하위 호환성은 중요한 요소이다.

## 4.15 마치며
- 
