```toc
```

## 7.1 API 관리 패턴
- API 관리는 API 생성, 관리, 보안, 분석, 확장을 다룬다
- API 관리를 통해 클라우드 네이티브 애플리케이션은 다음 기능 제공
	- 외부에 노출하고자 하는 API에 직접 참여
	- 애플리케이션을 다른 서비스와 통합해서 새로운 기능 만들기
	- API 사용 촉진
	- 비즈니스 분석 결과와 통찰 제공
	- 비즈니스 기능을 관리하고, 안전하고 탄력적으로 제공

- API, API Proxy는 애플리케이션이 관리하고 사용자에게 노출하는 비즈니스 기능
- API는 하나 또는 여러 개의 백엔드 마이크로서비스로 구성됨
- 별도로 분리된 API 게이트웨이를 통해 제공되는 경우가 많다
	- 비즈니스 기능은 마이크로서비스 내에 구현
	- API 게이트웨이는 보안, 스로틀링, 버전 관리 등을 담당
	- API 계층에 비즈니스 로직 구현하는 건 피해야 함
- API 계층에서 서비스 오케스트레이션 등 서비스 조합을 구현하는 건 좋지 않음
- 대개 REST, Open API, GraphQL로 제공

- API Product는 API를 개발자에게 제공할 때 주로 사용하는 개념
- API Product는 하나 또는 두 개 이상의 API를 더 높은 수준의 비즈니스 기능으로 연결
	- 클라우드 스토어 서비스에서 스토리지 서비스를 API 프로덕트라고 한다면 파일 API, 블롭 API, 디스크 API 등등

### 7.1.1 API 게이트웨이 패턴
- API Gateway Pattern은 비즈니스 기능을 사용자에게 제공할 때 가장 많이 사용하는 방법
- 비즈니스 전면에 별도 계층을 두어서 사용자에게 서비스를 노출하고 제공

#### 어떻게 동작할까요
- 주로 마이크로서비스 위에 만들어짐
- 마이크로서비스 또는 조합 서비스를 통해 구현한 서비스를 API 게이트웨이를 통해 관리형 API를 제공
- API 게이트웨이는 API 컨트롤 플레인과 API 개발자 포털과 함께 운용

- 각각의 역할
	- API 생성자/API 개발자
		- 인터페이스, 문서화, 버전 관리 등 API를 기술적 관점에서 이해하고 API 퍼블리셔를 통해 API를 API 스토어에 배포
		- 평점이나 의견을 받아보기도 함
		- API를 추가할 수는 있지만 라이프사이클 관리는 못함
	- API 퍼블리셔
		- 엔터프라이즈 혹은 비즈니스 단위로 API 관리
		- API 라이프사이클 및 구독, 홍보 등을 관리
		- API 사용 패턴에 관심을 가지며, 관련 통계 자료 접근 가능
		- 어떤 경우 API 생성자와 퍼블리셔가 단일 역할로 사용되기도 함
	- 애플리케이션 개발자
		- API 스토어에서 API 검색해서 쓰고, 평점이나 의견을 매김
	- API 컨트롤 플레인 관리자
		- API 관리 솔루션을 운영 및 관리
		- 사용자 권한, 접근 계정 등을 만들고 보안적인 것들을 책임짐

![](files/Pasted%20image%2020251123171000.png)

1. 관리형 API로 제공할 비즈니스 기능들을 파악합니다.
2. API 생성자 또는 서비스 개발자가 비즈니스 기능을 구현한 관련 마이크로서비스 위에 관리형 API 또는 API 프록시를 만듭니다. API 와 연결되는 다운스트림 서비스는 독립적인 단일 마이크로서비스 일 수도 있고 서비스 조합일 수도 있습니다. API 는 API 게이트웨이에 만들어집니다.
3. API 퍼블리셔는 만들어진 API 를 발행해서 애플리케이션 개발자가 개발자 포털에서 API 를 검색하고 사용 할 수 있도록 합니다.
4. 애플리케이션 개발자는 API 를 구독해서 API 개발자 포털에서 API 를 사용하고 애플리케이션 기능을 구현 하기 위해 필요한 API 관련 정보들을 습득합니다.
5. 모바일이나 웹, 데스크톱 애플리케이션과 같이 API를 사용하는 애플리케이션들은 API 게이트웨이를 통해 요청을 보내서 비즈니스 기능을 사용합니다.
6. API 퍼블리셔와 생성자는 사용자에게 제공하는 API를 제어하고 관찰하고 관리합니다.

- API Gateway
	- API에 접근할 수 있는 정문
	- 연결되는 다운스트림 마이크로서비스 전면에 만들어지며, API 게이트웨이 런타임을 통해 제공됨
	- API 사용자는 API Gateway와 연결된다
	- API 호출을 받아 접근 토큰, 인증서, 인증 정보와 보안성을 검토하는 책임 가진다
	- API 호출 별로 쿼터, 속도 제한, 캐싱, 버전 관리 등 다양한 QoS 정책 적용
	- 경우에 따라서는 JSON <-> XML 같은 로직을 가지기도 함
	- 단, 가급적으로 이런 비즈니스 관련 기능 구현하지 않는 게 좋음
	- API 분석, 관측 가능성 제공을 위한 다양한 정보 수집

##### API 매니지먼트 플레인
- API management plane
- API 생성자 및 퍼블리셔가 API 게이트웨이 및 개발자 포털에서 API 제공하고 관리하기 위해 사용하는 인터페이스
- 컨트롤 플레인을 사용해서 API 및 API 프로덕트 정의하고 생성하고 API 라이프사이클 상태 변경, 정책 관리
- API 사용자나 스키마, API 가시성 역시 컨트롤 플레인에서 관리

##### API 개발자 포털
- API Developer Portal
- API 소개하고 알려줌으로써 필요한 API 찾고 관련 정보 습득할 수 있게 만든다
- 개발자 포털에서 API 호출할 때 사용할 보안키, 토큰 등을 발급받을 수 있음
- API에 대한 통계 정보도 얻을 수 있음

- API Gateway는 이 패턴에서 필수가 아님
- 마이크로서비스 개발자가 스스로 API 게이트웨이 패턴을 통해 서비스를 관리형 API로 제공하기도 함

#### 어떻게 사용할 수 있나요
![](files/Pasted%20image%2020251123171541.png)

- API Gateway는 마이크로서비스 전면에 파사드 형태로 많이 쓴다
- 모든 마이크로서비스를 API 형태로 제공할 필요는 없다 
- 특정 기능을 제공하기로 결정했다면 구현 후 API를 만든다

- 주문 API를 요청하면 API Gateway는 보안, 스로틀링, 캐싱, 버전 관리 등 다양한 정책을 적용
- 마이크로서비스를 먼저 만들고 그 다음 API를 만들어서 제공하므로 이런 방식을 bottom-up API management 기법이라고 부른다
	- top down도 가능
	- 여기서는 API 설계를 먼저 한다
	- 개발 시점에 API 요구사항이 어느 정도 주어진 경우 쓰기 좋다

#### 고려해야 할 사항들
- API 게이트웨이에 비즈니스 구현하지 않기
- 내부 혹은 외부에 API 제공하기 위해 여러 API 관리 계층을 쓸 수 있다
- 초기 단계에는 API Gateway만 필요하고 컨트롤 플레인이나 개발자 포털은 필요 없을 수 있다.
	- 이 경우 API 발행이나 관련 정보는 API Gateway에서 제공하는 별도의 인터페이스 사용
- API 관리에 대한 요구사항이 점점 많아지면 별도의 API 컨트롤 플레인이나 개발자 포털을 도입할 수도 있다
- API Gateway 계층은 보통 모놀리식 런타임으로 사용한다
	- 보안, 기타 정책 등 많은 일을 해야 한다면 여러 런타임으로 나눠서 사용할 수도 있다
	- 이 경우 API 마이크로게이트웨이 패턴을 쓰는 게 좋다

#### 관련 패턴들
- 모든 서비스 조합 패턴과 함께 사용 가능
- 특정 요구사항을 만족시키기 위해 다른 형태의 API 게이트웨이 구조를 사용할 수도 있음

### 7.1.2 API 마이크로게이트웨이 패턴
- API microgateway pattern
- API 게이트웨이 패턴을 살짝 바꾼 것
- API 게이트웨이를 분산해 API 게이트웨이의 각 API를 독립적인 실행 환경으로 배포
	- 더 이상 모놀리식이 아님

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251123172021.png)
- 중앙집중형 API 게이트웨이 대신 각 API가 자신만의 고유한 실행환경을 가지도록 함
- 이를 마이크로게이트웨이라고 부름
- 중앙 API 매니지먼트 플레인을 통해 모든 마이크로게이트웨이를 관리할 수 있어야 함
- API 개발자 포털로도 매니지먼트 플레인에 접근할 수 있어야 함

#### 어떻게 사용할 수 있나요
![](files/Pasted%20image%2020251123172201.png)

- 일반적으로 가벼운 게이트웨이 런타임을 사용해서 컨테이너 형태로 배포
- API 매니지먼트 다른 부분은 API 게이트웨이 패턴과 동일
- 각 API는 독립적으로 실행되며 다른 구성 요소와 마이크로게이트웨이 런타임을 공유하지 않습니다

#### 고려해야 할 사항들
- 기저의 API 매니지먼트 플랫폼이 분산 배포 게이트웨이를 지원해야 함
- 게이트웨이 런타임은 최대한 가벼워야 함
- 이런 분산 시스템을 관리하고 확장하려면 쿠버네티스 같은 컨테이너 오케스트레이션 시스템을 사용하는 게 좋음
- 클라우드 서비스 제공 업체는 API 매니지먼트를 서비스로 제공

#### 관련 패턴들
- API 게이트웨이랑 똑같음

### 7.1.3 서비스 메시 사이드카 게이트웨이 패턴
- 독립적인 API 게이트웨이 런타임이 아니라 서비스 메시를 사용하는 환경에서 API 게이트웨이 기능을 사이드카 프록시로 옮겨서 마이크로서비스와 함께 실행

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251123172428.png)
- 이미 서비스 메시를 쓰고, 여기에 API 관리 기능을 추가하고 싶다면 이 패턴을 쓰는 게 좋음
- 사이드카 프록시에 API 게이트웨이 기능을 추가
- 서비스 개발자 혹은 데브옵스 조직이 서비스메시 동작을 제어, API 생성자와 퍼블리셔는 API 라이프사이클을 관리

- API 게이트웨이로 사이드카 프록시를 사용하는 주된 이유는 API 게이트웨이 요구사항과 사이드카 프록시 요구사항이 비슷해서
- 둘 다 프록시처럼 동작, 별도 컨트롤 플레인을 통해서 제어

#### 어떻게 사용할 수 있나요
- 이 패턴 구현은 대부분 API 매니지먼트 솔루션에 의해 이루어지며, 기저 세부사항이 가려짐
- API 컨트롤 플레인은 사이드카 프록시를 직접 관리할 수도, 서비스 메시 컨트롤 플레인 API를 통해 관리할 수도

#### 고려해야 할 사항들
- 가장 복잡한 분산 구조
- 운영상의 복잡도도 서비스 메시보다 더 큼

#### 관련 패턴들
- 서비스 메시 패턴의 기본적인 개념 모두 사용
- API 게이트웨이, API 마이크로게이트웨이 모두 적용됨

### 7.1.4 API 관리 패턴 구현 기술
- 혼잡하다~
- 온프레미스
	- Kong, MuleSoft, 레드햇 3scale API management, WSO2 API Manager
- 클라우드
	- 구글의 Apigee, 애저 API Management, 아마존 API Gateway, Mulesoft Anypoint Platform

### 7.1.5 API 관리 패턴 정리

| 패턴                | 사용하면 좋은 경우                                                                                                        | 사용해서는 안 되는 경우                                                                                                |
| ----------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| API 게이트웨이         | 모든 API 관리 기술에서 핵심적인 패턴. API 매니지먼트 플레인이나 개발자 포털은 부가적인 기능으로 요구사항이 없다면 사용할 필요가 없으나, API 라이프사이클 관리가 필요한 경우 사용하는 것이 좋음 | 없음                                                                                                           |
| API 마이크로 게이트웨이    | API 게이트웨이 계층의 고가용성이 필요하고 각 API별로 독립적인 실행 환경이 요구되는 경우                                                              | 클라우드 네이티브 애플리케이션의 관리형 API가 관리할 만하며 무겁지 않은 경우, 이 패턴을 사용하면 오히려 불필요하게 복잡도를 증가시킬 수 있음                            |
| 서비스 메시 사이드카 게이트웨이 | 운영 환경에서 서비스 메시를 사용하며 별도의 계층 없이 API 관리 기능을 추가하고 싶은 경우                                                              | 서비스 메시를 사용하지 않거나 사용할 계획이 없는 경우, 이 패턴을 사용하는 것은 복잡도를 과도하게 증가시킴. 서비스 메시를 사용하는 경우에도 API 관리를 별도의 구성 요소로 도입할 수도 있음 |

## 7.2 API 사용 패턴
- 백엔드에는 지금까지 설명한 대부분의 연결성 패턴 사용 가능
- 프런트엔드에는 다른 패턴들이 또 있음

### 7.2.1 프런트엔드와 마이크로서비스 간 직접 통신 패턴

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251123173349.png)
- 프런트엔드가 마이크로서비스 기능을 사용하려면 모든 마이크로서비스를 외부에 노출해야 함
- LB를 통해서 서비스에 접근
- 마이크로서비스가 외부에 노출되는 만큼 보안에 각별히 신경써야 한다

- 각 애플리케이션은 마이크로서비스 인터페이스와 직접 연결된다
- 마이크로서비스가 바뀌면 프런트엔드도 바뀌어야 한다
- 인증, 인가, 관측 가능성 등 서비스를 막론하고 모두 각 마이크로서비스에서 구현해야 함
#### 어떻게 사용할 수 있나요
- 서비스나 시스템이 많지 않은 간단한 애플리케이션 만들 때 쓸 수 있음
- 주로 소규모 마이크로서비스를 사용하며, 별도의 API 관리 계층을 통해 마이크로서비스를 관리형 API로 제공할 수 없는 경우 사용
- 나중에 시스템이 커지면서 API 게이트웨이 패턴을 추가

#### 고려해야 할 사항들
- 프런트엔드와 백엔드가 매우 강결합
- 마이크로서비스를 직접 외부에 노출함으로써 생기는 보안 위협, 공통 기능을 제공하는 중앙 집중형 요소가 없다는 태생적인 한계

#### 관련 패턴들
- API 게이트웨이 패턴을 통해 직접 연결되지 않게

### 7.2.2 API 게이트웨이를 통한 프런트엔드 사용 패턴
- 직접 노출하지 않고 API 관리 계층을 두기

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251123173841.png)
- API 관리 계층을 통해 외부 사용자에게 제공, 프런트엔드는 이 계층과 대신 통신
- 마이크로서비스를 API 형태로 제공하려면 API Contract에 따라 인터페이스 정의하고, 인터페이스를 API 접근 사용자에게 제공
	- API Gateway가 여기서 API Contract에 해당
	- 이는 내부 백엔드 API와 같을 수도 있고 다를 수도 있음
- API 관리 계층은 파사드처럼 동작해 세부 구현을 바꿔도 클라이언트에게 영향을 주지 않을 수 있음
- 보안, 스로틀링, 접근 정책, 인증 등을 API 관리 계층에게 위임 가능

#### 어떻게 사용할 수 있나요
- 많은 회사가 API 관리 패턴으로 넘어가는 추세
- API 관리 계층을 사용하지 않는다면 애플리케이션 구조에 점진적인 API 관리 기능을 도입하고 이에 따라 프런트엔드도 조금씩 수정하다가 향후에는 마이크로서비스를 직접 사용하지 않고 노출된 API만 사용하도록 바꾸는 게 좋다

#### 고려해야 할 사항들
- 프런트엔드가 API를 쓸 때 부딪히는 한계 중 하나는 프런트엔드를 위한 특별한 인터페이스나 API가 없고 범용 API만 사용해야 한다는 것
- 데스크톱, 모바일 요구사항이 다른데 제공되는 API는 같다
- 프런트엔드가 특정 상황에 사용할 수 있도록 API 구성하는 게 필요한데 이는 아래에서 설명

#### 관련 패턴들
- 이전에 설명한 API 관리 패턴을 사용
- 이 패턴과 프론트엔드를 위한 백엔드 패턴을 함께 사용해서 프런트엔드를 위한 전용 API를 제공할 수도 있다.

### 7.2.3 프런트엔드를 위한 백엔드 패턴
#### 어떻게 동작할까요
- 프런트엔드 요구사항은 종류에 따라 아주 다르다
- 모든 환경을 위한 범용 API를 만들면 결국 제약이 생긴다
- 각 프런트엔드 유형에 따라 맞춤형 API를 제공할 필요도 있다
- 이를 BFF(Backend For Frontend Application)이라고 부른다
- 하나의 범용 API 대신 프런트엔드 유형별로 다른 API를 사용
- 각 API는 백엔드 마이크로서비스와 직접 상호작용하거나 핵심 비즈니스 기능을 제공하는 범용 API를 쓰기도 한다.
- 특정 유형의 프런트엔드를 위한 API는 보통 그 프런트엔드를 만드는 팀에서 관리한다
- 이 패턴을 사용하면 각 BFF가 고유한 라이프사이클을 가지므로 각 BFF API를 바꿔도 다른 API에 영향을 미치지 않는다.
![](files/Pasted%20image%2020251123174240.png)
#### 어떻게 사용할 수 있나요
- 각기 다른 프런트엔드를 통해 사용자에게 다른 경험을 주고 싶을 때 쓴다
- 모바일은 데스크톱과 달리 특정 데이터 포맷을 쓰거나, 더 가벼운 메시징 기술, 다른 보안 프로토콜 등
- BFF를 쓰면 사용자에게 최적의 사용자 경험을 제공할 수 있음

#### 고려해야 할 사항들
- BFF는 범용 API로 애플리케이션 개발할 때보다 복잡도는 떨어져도 추가적인 운영 부하가 생김
- 같은 기능을 여러 API로 제공
- BFF를 만들 때는 범용 다운스트림 서비스나 범용 API 쓰는 게 좋다
	- 어떤 API를 어떻게 쓰고 각 API 사용에 대한 통계를 산출할 수 있다
- 또한 이 패턴을 사용하면 외부에 노출되는 API가 많아지고, 지원하는 프런트엔드 유형이 많아지면 더 많은 API를 만들어야 한다
- 따라서 사용자 경험을 확연히 더 좋게 만들 수 있을 때 써야한다

#### 관련 패턴들
- 주로 API 게이트웨이나 API 마이크로게이트웨이 패턴과 함께 사용

### 7.2.4 API 사용 패턴 정리

|패턴|사용하면 좋은 경우|사용해서는 안 되는 경우|
|---|---|---|
|프런트엔드와 마이크로서비스 간 직접 통신|• API 관리 계층이 필수 요건이 아닌 경우|• 대개 특정 시점에 관리될 API를 도입해야 하는 상황이 발생하며, 따라서 이 패턴은 애플리케이션 개발 초기 단계에만 사용하는 것이 좋음|
|API 게이트웨이를 통한 프런트엔드 사용|• 사용자 유형과 패턴이 모두 동일하며 프런트엔드 수준에서 별도의 요구사항이 없는 경우<br>• 사용자에게 제공하는 API가 서로 다른 유형의 사용자 모두에서 잘 동작할 때|• 프런트엔드 요구사항에 따라 API가 자주 바뀌는 경우<br>• API의 성공적인 사용 여부가 프런트엔드 애플리케이션에 의해 전적으로 결정되는 경우|
|프런트엔드를 위한 백엔드(BFF)|• 각 프런트엔드 애플리케이션 유형별로 고유한 사용자 경험을 제공하고자 할 경우|• 단일 유형의 프런트엔드 애플리케이션만 사용하거나, 서로 유사한 프런트엔드 애플리케이션을 요구사항이 모두 동일한 경우|

## 7.3 마치며

