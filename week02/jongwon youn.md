```toc
```

## 2.1 동기 메시징 패턴

- 하나 이상의 다른 마이크로서비스가 제공하는 기능들을 호출하고, 지정된 시간 내에 응답을 받는 식으로 비즈니스 기능을 구현하기도 한다
- 이런 경우 동기 메시징 패턴(synchronous messaging pattern)을 적용할 수 있다
- 동기 메시징 패턴에서는 MS가 자신이 사용하는 다른 MS에 의존 관계를 지니게 된다

### 2.1.1 요청-응답 패턴

- 요청-응답 패턴(request-response pattern)은 가장 많이 사용하는 패턴
- 분산 컴퓨팅 분야 전반에서 애용
- 적절한 시간 내에 데이터를 서로 주고받아야 함

#### 어떻게 동작할까요

![](files/Pasted%20image%2020250909202000.png)

- MS는 하나 이상의 다른 MS에 요청을 보내고 응답을 기다림
- 클라이언트 애플리케이션은 응답이 올 때까지 동작을 멈추고 대기하며, 통신 채널은 클라이언트 애플리케이션이 응답을 받을 때까지 연결을 유지


- 주고받는 데이터를 흔히 메시지라고 부르며
- 응답이 올 때까지, 혹은 타임아웃 시간까지 기다린다
- 질의를 주고받는 거랑 비슷해서 질의 기반(query-based) 상호작용이라고도 부른다

#### 어떻게 사용할 수 있나요

- 즉각 데이터를 요청하고 받아야 하는 곳에서 주로 사용
- 외부에 서비스 기능을 제공하는 경우 대부분 이 패턴으로 구현
- 기저 네트워크나 프로토콜 영향을 받지 않아 주고받는 메시지 형식에 따라 다양한 기술을 적용해 구현할 수 있다는 장점이 있다
- HTTP와 Restful 서비스를 사용하는 대부분의 MS는 이 패턴으로 구현
- 그래서 초창기 클라우드 네이티브 애플리케이션에서 가장 널리 사용된 방식


- 최근은 사용 방법이나 요구사항이 많이 다르다
- 이는 통신 패턴의 구현 기술을 살펴볼 때 살펴보자

#### 고려해야 할 사항들

- 이 패턴을 많이 사용하면 의존성이 생긴다
- 연결하는 서비스가 많아질수록 의존성 연결 고리는 기하급수적으로 늘어나고 복잡해짐
- 이렇게 연결이 복잡해지면 성능에 병목 현상이 있거나 오류가 발생하는 등 여러 다른 서비스에 영향을 미칠 수 있다


- 따라서 외부 사용자나 시스템, 혹은 마이크로서비스 간에 서로 메시지를 계속 주고받는 방식으로 통신할 때만 사용하는 게 좋다
- 그 외에는 비동기를 쓰는 게 좋다

#### 관련 패턴들

- 서비스 오케스트레이션 및 API 게이트웨이 패턴
    - 서비스를 조합하고 관리형 API로 외부에 기능을 제공할 때 요청-응답 방식을 많이 쓴다
- 요청-회신 패턴
    - 요청-회신(request-reply) 패턴은 중간 매체를 통해 메시지 큐를 사용하는 것과 비슷

### 2.1.2 원격 프로시저 호출 패턴

- 분산된 원격 애플리케이션 프로시저를 자기 자신 프로시저처럼 호출하고 사용하는 동기화 통신 패턴
- 특정 마이크로서비스가 자신의 비즈니스 로직을 함수처럼 만들고, 다른 서비스가 이 함수를 호출해서 비즈니스 기능 이용 가능

#### 어떻게 동작할까요

![](files/Pasted%20image%2020250915211501.png)

- 기반이 되는 RPC 프레임워크가 네트워크를 통해 원격 메서드를 호출하는 복잡한 부분 알아서 처리해줌
- 즉, 개발자는 네트워크에서 어떻게 통신하는지 알 필요가 없음
- 서로 다른 프로그래밍 언어와 기술을 사용하는 것도 가능


- 원격 메서드에 대한 세부 정보, 서비스 이름, 이름 분석(name resolution), 서비스 간 정보 교환을 위한 데이터 타입 등을 명세하는 서비스 정의부터 해야함
- 보통 IDL 사용해서 명세함


- RPC 패턴 사용하면 서버, 클라이언트 코드 자동 생성 가능
- 이를 stub이라고 함


- 서버 측 네트워크 전송 계층이 메시지를 받아 RPC 런타임으로 전달할 때 TCP 씀

#### 어떻게 사용할 수 있나요

- 거의 모든 MS 통신에 RPC 쓸 수 있음
- 수십 년간 CORBA(Common Object Request Broker Architecture)와 같은 수많은 RPC 기술을 분산 애플리케이션 개발에 사용함
- 대부분 RPC 기술은 TCP 계층 바로 위에 만들어져서 아주 복잡함
- 따라서 RESTful 서비스와 같은 기술이 각광 받음에 따라 기존 RPC 기술이 도태됨
- 다만, gRPC 등 클라우드 네이티브 아키텍처에 적합한 새로운 RPC 패턴이 나타남
- HTTP2를 사용해 기존 LB와 같은 컴포넌트를 그대로 쓸 수 있고, 프로토콜 버퍼 통해 더 효율적이면서 타입 안정적인 데이터 직렬화도 지원

![](files/Pasted%20image%2020250915212250.png)

- RPC는 내부 간 통신에 적합
- 외부 서비스에도 gRPC 써도 되지만 대부분 웹 클라이언트 지원이 부족

#### 고려해야 할 사항들

- RPC는 MS 간 통신 구현에 가장 단단하면서 효율적인 기술
- 서비스 간 동기 통신 구현에는 추천
- 단, 웹 또는 모바일 서비스와 같은 외부 사용자에게 노출되는 경우 Restful 및 JSON 방법을 권장

#### 관련 패턴들

- 서비스 조합 및 API 관리 패턴
    - 이거 구현할 때 기반으로 RPC 많이 씀
- 요청-응답 패턴
    - RPC 대신 사용

### 2.1.3 동기 메시징 패턴 비교

|  패턴   |                                                                사용하면 좋은 경우                                                                |                                사용해서는 안 되는 경우                                 |                       이점                        |
|:-----:|:----------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------:|:-----------------------------------------------:|
| 요청-응답 |                    • 실시간 응답이 필요한 서비스<br>• 서비스 사용이 자유로운 경우<br>• 다양한 이용 방식이나 사용자가 존재할 경우<br>• 외부 사용자에게 서비스를 노출해야 하는 경우                     |        • 응답 속도가 빠르고 처리량이 많은 통신의 경우<br>• 서비스 간 통신에 엄격한 규격이나 약속이 필요한 경우        | • 내외부 서비스 간 통신에 사용하기 좋은 가장 일반적이고 호환성이 뛰어난 통신 패턴 |
|  RPC  | • 서비스 간 통신 속도 및 처리량이 매우 중요한 경우<br>• 서비스 구성을 위해 각 서비스 간 통신에 엄격한 규격 또는 약속이 필요한 경우<br>• 서비스가 사용하는 기저 통신 프로토콜과 비즈니스 로직을 완전히 독립적으로 유지하고 싶은 경우 | • 웹이나 모바일과 같이 서비스가 다양한 종류의 애플리케이션과 상호 통신해야 하는 경우<br>• 서비스 이용이 자유롭고 유연해야 할 경우 |      • 효율적이고 타입 안정성을 보장할 수 있는 서비스 간 통신 패턴       |

## 2.2 비동기 메시징 패턴

- 즉각적인 응답을 기대하지 않음
- 응답을 전혀 하지 않을 수도 있고, 별도의 큐나 다른 통신 채널로 비동기 응답을 보내기도 함


- 비동기 메시징 패턴에서 MS 간 통신은 메시지 브로커나 이벤트 브로커를 통해서 이루어짐


- 클라우드 네이티브 애플리케이션에서 브로커는 최소한의 비즈니스 로직만으로도 뛰어난 메시징 인프라 제공 가능
- 비즈니스 로직은 생산자, 소비자가 가지므로
- 덕분에 브로커를 중앙화된 메시지 플랫폼으로 사용 가능

### 2.2.1 단일 수신자 패턴

- single-receiver pattern에서는 하나의 MS가 단 하나의 MS 혹은 시스템에 메시지 전달함
- 이를 보통 command라고 부름
- 단일 생산자, 단일 소비자 정보 교환이므로 point-to-point 비동기 메시징이라고도 부름

#### 어떻게 동작할까요

- 큐에 메시지를 넣고 큐에서 메시지를 가져와서 처리
- 생산자의 관심은 오직 메시지가 큐에 제대로 들어갔는지
- 언제 누구에게 전달되었는지는 신경쓰지 않음


- 큐를 쓰므로 메시지를 순서대로 전달할 것을 보장
- 보통 브로커는 최소 1회 전달 등의 메시지 전달 보장 메커니즘이 있음
- ack를 통해 메시지 전달되었음을 보장받을 수 있음

![](files/Pasted%20image%2020250915213555.png)

- 단일 수신자 패턴은 메시지 전달이 보장되어야할 때 자주 사용함

#### 어떻게 사용할 수 있나요

- 다양한 메시지 브로커 구현 가능
- AMQP(Advanced Message Queuing Protocol)은 큐 기반 단일 소비자 메시징 구현할 때 가장 널리 사용되는 프로토콜


- 브로커로 AMQP 쓰면 생산자, 소비자를 서로 다른 언어로 구현 가능
- RabbitMQ, ActiveMQ, ActiveMQ Artemis 등

#### 고려해야 할 사항들

- 종단간 메시지 전달 보장할 때 많이 사용
- 메시지 브로커는 신뢰성, 확장성, 성능에 중요한 역할을 맡음
- 따라서 요구사항에 잘 맞는 브로커 기술 선택 필요


- 어떤 모놀리식 엔터프라이즈 미들웨어에 근간을 두고 있음
- 비즈니스 로직 상당 부분을 브로커에 구현하도록 만드는 경향이 있음
- 라우팅, 필터링, 콘텐츠 내용에 따른 전달 등
- 클라우드 네이티브에서는 브로커에 비즈니스 로직을 두지 않고, MS 안에 구현하는 것을 권장

#### 관련 패턴들

- 최대 한 번 전달, 최소 한 번 전달 등
- fire and forget 등은 메시지 브로커 없이 구현하기도 함

### 2.2.2 다중 수신자 패턴

- 여러 소비자에게 메시지를 보내고 싶다면?
- 이런 경우 multiple-receiver, pub-sub 패턴


- 클라우드 네이티브에서는 MS가 특정 이벤트가 발생한 경우 비즈니스 로직이 실행된다거나, 다른 한 개 이상의 MS에 이벤트가 발생했다는 사실을 알리도록 만들 때가 많음

#### 어떻게 동작할까요

- 메시지는 하나 이상의 소비자에게 전달됨
- 이를 지원하는 브로커나 이벤트 버스를 사용
- 보통 토픽에 메시지를 발행하면, 하나 이상의 MS가 해당 토픽을 구독하는 방식
- 메시지는 해당 토픽을 구독하는 모든 서비스에 비동기로 전달됨

![](files/Pasted%20image%2020250915214040.png)

- 이벤트 버스는 메시지 생산, 구독 등의 요청을 처리하고 메시지를 전달함
- 메시지 전달이 단일 수신자 패턴만큼 엄격하지는 않음
- 가능한 구독자들에게 전달하기만 하면 됨


- 구독자가 오랜 시간동안 동작하지 않아도 메시지를 전부 받고 싶다면 이런 기능을 지원하는 솔루션을 사용
- 대신, 보관해야하는 메시지가 많아지므로 부하도 커짐

#### 어떻게 사용할 수 있나요

- 발행자-구독자 메시징 지원하는 브로커 사용
- ActiveMQ, RabbitMQ, 애저 서비스 버스 등
- Kafka, NATS, AWS SNS, 애저 Event Grid 등


- 다중 소비자 패턴은 생산자의 모든 이벤트를 영구 스토어(persistent store)에 저장하고 관리하는 영구 전송(persistent delivery)를 지원
- 그렇다고 이벤트가 구독자 서비스에 전달을 보장하지는 않음
- 대비하더라도 이벤트를 전달할 수 없는 상황이 발생하기도 함


- 즉, 최소 한 번 전달과 같은 요구사항이 필요한 경우 사용할 수 없음
- 몇몇 브로커는 내구성 토픽(durable topic) 같은 개념을 통해 메시지 전송을 보장하기도 함
- 모든 내구성 소비자에 대한 각 메시지를 논리적으로 영구 보관하기 때문


- 보통 여러 소비자에게 동일한 메시지 전달할 대 최소 한 번 전달과 같은 요구사항 만족하려면 다중 소비자 패턴 보다는 단일 수신자 패턴처럼 각 소비자별로 큐를 따로 두는 방식을 많이 씀

#### 고려해야 할 사항들

- 여러 소비자가 하나의 브로커를 공유
- 따라서 메시지 속성 등으로 라우팅하는 것보다 브로커와 비즈니스 로직을 최대한 분리
- 브로커는 메시징 인프라로만 사용
- 그렇게 하면 소비자가 메시지를 소비하는 방식을 더 자유롭게, 더 쉽게 구현할 수 있음


- 내구성 토픽, 구독 등은 꼭 필요할 때만 사용

#### 관련 패턴들

- 이벤트 주도 아키텍처

### 2.2.3 비동기 요청-응답 패턴

- 어떤 경우 생산자가 브로커를 통해 소비자에게 메시지를 전송하고, 다른 브로커 채널로 응답을 받을 수도 있다
- 이를 비동기 요청-응답 패턴이라고 함

#### 어떻게 동작할까요

- 기본적으로 단일 수신자 패턴과 같은 메시징 모델 사용
- 전송하는 메시지 메타데이터에 메시지 전송 후 응답을 보내달라는 요청사항과 어떻게 응답을 보낼 수 있는지 지정할 수 있다
- 소비자는 메시지를 생성한 측에 다른 메시지 브로커 채널로 응답 메시지를 생성해서 전달

![](files/Pasted%20image%2020250915220644.png)

- 요청 큐에 요청 메시지를 보내면서, 생산자와 관련된 ID와 응답 채널 정보를 함께 보냄
- 생산자는 미리 정의해둔 다른 응답 큐(콜백 큐)에 별도의 구독 요청을 보내 응답 메시지를 받을 준비를 함
- 소비자는 요청 메시지에서 응답 큐 정보를 확인하고, 응답 메시지를 만들어서 응답 큐에 전송

#### 어떻게 사용할 수 있나요

- 이는 응답-요청 패턴을 대체하는 게 아님
- 비동기 메시지에 응답해달라는 비즈니스 데이터가 있으면 이 패턴을 씀
- 단일 수신자 패턴을 지원하는 브로커로 구현 가능

#### 고려해야 할 사항들

- 요청-응답 패턴과 비슷해 비동기 요청 응답 패턴이 더 신뢰할 수 있고 더 나은 대체제라고 생각할 수도 있다
- 그러나 용도가 다르다
- 비동기 요청-응답 패턴은 두 개의 단방향 메시지를 조합하는 것
- 두 개의 메시지 큐를 쓰므로 성능이 떨어지고, 부하가 생김
- 실제로 자주 쓰이지는 않음

#### 관련 패턴들

- 전송 방향이 서로 반대인 두 개의 비동기 단일 수신자 패턴을 조합한 것
- 따라서 단일 수신자 패턴에 적용되는 내용이 다 적용됨

### 2.2.4 비동기 메시징 패턴 비교

| 패턴            | 사용하면 좋은 경우                                                                                  | 사용해서는 안 되는 경우                                             |
|---------------|---------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| **단일 수신자**    | • 한 마이크로서비스가 다른 마이크로서비스에 비동기로 명령을 전송하는 경우<br>• 메시지를 순서대로 전송해야 하는 경우<br>• 메시지 전송을 보장받고 싶은 경우 | • 최소 한 번 이상 전달과 같은 특별한 전송 규칙이 필요 없고, 효율적인 데이터 전송이 요구되는 경우 |
| **다중 수신자**    | • 하나 이상의 수신자가 같은 메시지나 이벤트에 관심이 있는 경우                                                        | • 메시지 전송을 보장해야 하는 대부분의 경우                                 |
| **비동기 요청-응답** | • 요청과 응답 사이에 특별한 관계가 필요한 비동기 메시징 처리의 경우                                                     | • 동기 요청-응답 패턴 대신 신뢰할 수 있는 메시징 방식이 필요한 경우                  |

## 2.3 서비스 정의 패턴

- 서비스 정의(service definition) 고민해야 함
- 사용자에게 MS를 어떻게 사용할 것인지 정의하는 부분
- 서비스 정의하는 기술과 사용하는 방법은 서로 다름

### 2.3.1 동기 통신에서의 서비스 정의

- 서비스 정의는 Service Registry라는 중앙화된 곳에서 이루어짐
- 다른 MS 및 개발자와 상호작용할 수 있는 일종의 메타데이터 스토어
- HTTP 프로토콜 이용한 RESTful, gRPC와 같이 동기 통신에 사용하는 프로토콜 등 다양한 기술을 골라 정의 가능

#### 어떻게 동작할까요

![](files/Pasted%20image%2020250915222846.png)

- 서비스 정의는 클라이언트가 원하는 서비스를 어떻게 사용할 것인지 정의
- MS는 서비스에 대한 정의를 서비스 레지스트리에 자동으로 발행하거나, 서비스 소유자 또는 개발자가 수동으로 서비스 정의를 작성해서 발행
- 사용자는 서비스 레지스트리에 접근해서 서비스 정의를 찾음
    - 이를 서비스 검색이라고 부름


- 찾아낸 서비스 정의는 클라이언트 애플리케이션을 만들거나 클라이언트 라이브러리 생성할 때 사용
- 여기에는 인터페이스, 메시지 형식, 데이터 스키마 등이 담겨있음


- 서비스 레지스트리는 서비스 정의 저장 외에도 평점, 리뷰, 다양한 API 관련 요구사항을 만족하기 위한 부수적인 기능을 제공

#### 어떻게 사용할 수 있나요

- 서비스 정의와 기타 메타데이터를 관리할 수 있는 API를 제공하는 메타데이터 스토어 형태로 구현할 때가 많다
- consul, etcd, zookeeper 등
- 보통 중앙화된 컴포넌트로 배포해서 사용


- 서비스 정의 기술은 프로토콜별로 다양함
- OpenAPI, Protobuf, GraphQL 스키마


- gRPC 등은 서비스 정의가 필수지만 REST 등은 또 아님
- 단, 클라우드 네이티브에서는 서로 상호작용을 많이 하므로 서비스 각각 모두 정의 만들어두는 게 좋음


- Open API와 Consul로 RESTful 서비스에 대한 서비스 정의 만들기
    - Open API로 서비스 정의 만들고
    - Consul 등의 서비스 레지스트리에 저장해 서비스 사용자가 서비스에 대한 메타데이터를 검색하고 사용할 수 있게 함
    - Open API 정의로 코드를 생성하고, 문서를 참조하고, SLA나 보안 스키마 등의 정보를 얻을 수 있음
    - Consul 등의 서비스 레지스트리는 서비스 카탈로그처럼 서비스 메타데이터에 접근할 수 있는 일원화된 방법을 제공

#### 고려해야 할 사항들

- 서비스 정의 만들고 공유하는 건 거버넌스와 아주 밀접한 연관
- 보통 서비스 정의는 중앙화된 서비스 레지스트리에 저장해서 사용자가 서비스를 검색하고 사용할 수 있게 함
- 따라서 서비스 레지스트리는 Open API, gRPC, GraphQL 스키마 등 다양한 정의 모두 다룰 수 있어야 함
- 서비스 정의를 도입하면 MS의 개발 라이프사이클이 변할 수도 있음
- 코드 검증이나, 클라이언트 구현을 서비스 정의에 기반해서 함
- 이렇게 구현하면 외부에 알려진 정의와 MS 구현이 일치하는지 확인할 수 있음

#### 관련 패턴들

- 서비스 레지스트리 및 검색 패턴과 밀접한 연관
- 동기 요청-응답, 원격 프로시저 호출, API 관리 패턴

### 2.3.2 비동기 통신에서의 서비스 정의

- 메시지는 스키마를 사용
- 중앙화된 메타데이터 레지스트리에 스키마를 저장하고 씀

#### 어떻게 동작할까요

- MS 간 신뢰할 수 있는 튼튼한 비동기 통신을 구현하려면 서비스 정의로 비동기 메시징을 만들고 사용할 때 필요한 명세를 만들어야 함
- 서비스 정의에 스키마 정의를 포함하는 경우도 많음

![](files/Pasted%20image%2020250916203740.png)

- 생산자는 스키마로 생산한 메시지가 올바른지 확인하고 큐에 넣음
- 소비자는 스키마로 메시지를 역직렬화


- 이를 이용하면 데이터 타입에 대한 메타데이터 양을 줄이고, 메시지를 만들 때마다 필드 이름을 기입할 필요가 없음

#### 어떻게 사용할 수 있나요

- 초기 비동기 통신 구현에는 스키마나 스키마 레지스트리 많이 사용하지 않음
- 비동기 통신이 증가하면서 메시지 규약을 명확히 할 필요가 생김
- 따라서 여러 브로커 솔루션이 스키마 레지스트리를 함께 지원함
- 중앙화된 메타데이터 스토어를 써도 됨


- Avro, Protobuf, JSON Schema 등


- 카프카 스키마 레지스트리는 스키마 버전 변경 내역을 관리하고, 카프카 클라이언트에 사용할 수 있는 직렬화 기능도 제공함
- Kinesis, Azure Event Hub 등도 스키마 레지스트리를 통한 통합 메시징 서비스 제공함


- 스키마 레지스트리는 메시지 스키마 정보만 제공
- 다른 상세한 규약 정보를 다루지는 않음
- AsyncAPI는 생산자, 소비자 간 비동기 메시징에 필요한 서비스 규약 등에 대한 정의를 표준화함
- 현재는 널리 쓰이지 않지만 비동기 메시징 아키텍처에서 서비스 정의 표준 기술이 될 수 있는 훌륭한 특성을 많이 지님

[Coming from OpenAPI \| AsyncAPI Initiative for event-driven APIs](https://www.asyncapi.com/docs/tutorials/getting-started/coming-from-openapi)

[AsyncAPI — Event-Driven Architecture의 (사실상)표준 API - Sungyong - Medium](https://sungyong.medium.com/asyncapi-event-driven-architecture%EC%9D%98-%EC%82%AC%EC%8B%A4%EC%83%81-%ED%91%9C%EC%A4%80-api-f3adcbd24d08)

#### 고려해야 할 사항들

- 대부분 비동기 메시징은 스키마 기반 직렬화, 역직렬화를 사용하지 않고 구현함
- 이는 메시지나 데이터 타입 불일치를 가져오는 경우가 많음
- 또한 함께 보내는 메타데이터 때문에 메시지 사이즈가 커짐
- 그래서 스키마를 쓰는 게 좋음
- 단, 매번 스키마 검증을 한다는 점에서 성능상 부하가 생기기도 함
- 레지스트리에서 스키마 정보를 가져오는 부분에 대한 캐싱도 필요함

#### 관련 패턴들

- 서비스 레지스트리, 검색 패턴
- 비동기 요청-응답, 원격 프로시저 호출, API 관리 패턴

## 2.4 동기 메시징 패턴 구현에 사용할 수 있는 기술

### 2.4.1 RESTful 서비스

- 요청-응답 패턴 구현하는 잘 알려진 방법
- RESTful 서비스는 REST 구조상에서 구현
- 네트워크상에서 서비스와 객체를 고유한 주소 형태, 즉 URI로 표현
- 이를 자원(resource)라고 부름
- 이런 자원은 객체의 타입, 연관 데이터, 다른 자원과의 관계, 자원을 사용할 수 있는 방법 등을 나타냄


- REST 스스로는 프로토콜을 강제하지 않지만 보통 HTTP로 구현
- HTTP로 RESTful 자원에 접근하는 경우 URI로 자원을 구분할 수 있는 식별자로 쓰고, GET/PUT/DELETE/POST/HEAD와 같은 표준 HTTP 메서드를 사용해서 자원에 필요한 액션을 수행

![](files/Pasted%20image%2020250916204705.png)

- 주로 JSON, XML 등 텍스트로 데이터를 나타낼 수 있는 형태를 사용

### 2.4.2 GraphQL

- 최근 유행하는 요청-응답 패턴 구현 기술 중 하나
- GraphQL은 MS에 대한 요청을 질의 형태로 보낸다
- 질의는 클라이언트가 알고자 하는 데이터를 나타내며, MS는 가지고 있는 데이터와 비즈니스 로직으로 이를 응답함


- GraphQL은 어떤 데이터를 원하고, 어떤 방식으로 하고, 어떤 데이터 형태가 필요한지 클라이언트가 지정함
- 주로 query, mutation, subscription 사용함
    - 데이터를 요청하고, 데이터를 수정하고, 비동기 이벤트 주도 통신 등의 메시징

![](files/Pasted%20image%2020250916204907.png)

- 어떤 데이터를 원하는지 보내면 안에서 여러 MS 데이터 조합해서 내려줌
- GraphQL 요청은 HTTP로 함
- HTTP GET 쓰면 query parameter 쓸 수 있음


- GraphQL은 모바일 애플리케이션 같은 소비자나 클라이언트에 바로 노출되는 MS, API에 쓰거나 서버에 요청하는 데이터를 제어할 필요가 있는 경우 씀
- 발행자-구독자 같은 패턴도 지원함


- GraphQL은 REST 대비 필요없는 데이터까지 받거나 필요한 데이터를 충분히 받지 못해 다른 API를 추가로 쏘지 않아도 됨
- 원하는 데이터만 정확히 한 번의 요청으로 받을 수 있음
- 그 외에 데이터 검증, 타입 검사, 자세한 에러 처리, 하위 호환을 위한 버전 관리 등을 지원

### 2.4.3 웹소켓

- 웹 소켓으로도 동기 요청-응답 패턴 구현 가능
- 웹소켓은 간단히 웹에서 TCP 구현한 것
- 양방향 통신 지원하고, 한 번 연결하면 비동기 메시징이 가능해서 강력함


- 단일 TCP 연결로 양방향 통신하고, HTTP 상에서 연결을 만든다
- 즉, HTTP 지원하는 기존 인프라로 핸드셰이킹하고 연결 만들 수 있음
- 그 뒤에는 저수준 TCP 소켓처럼 동작
  ![](files/Pasted%20image%2020250916205207.png)


- 특정 메시지 직렬화 포맷을 강요하지 않음
- 서버와 클라가 양방향 동기 요청-응답 통신을 해야하는 경우 쓰면 좋다

### 2.4.4 gRPC

![](files/Pasted%20image%2020250916205324.png)

- RPC 기반 통신 기술
- 서로 다른 MS 간 연결을 지역 함수 호출처럼 쉽게 만들 수 있다.
- gRPC는 기존 RPC 기술들의 한계를 극복하고 인터넷 규모의 서비스 간 통신 기술이 가능하도록 설계됨
- Protobuf로 직렬화함
- HTTP 2 기반 -> 상호 운용이 가능하고 효율적임
- 여러 프로그래밍 언어 지원


- 첫 번째로 서비스 인터페이스를 정의
    - 서비스를 어떻게 써야하는지, 원격에서 어떤 메서드를 호출해야 하고, 어떤 인자가 필요한지, 어떤 메시지 포맷을 사용하는지 정의
- 이를 이용해서 서버와 클라이언트 stub 생성
- 데이터 직렬화, 네트워크 연결, 인증, 접근 제어, 관측 가능성 모두 제공


- Thrift는 자체 인터페이스 정의 언어로 폭 넓은 프로그래밍 언어 제공
- gRPC는 Protobuf만 사용해 Thrift보다 폐쇄적이지만 HTTP2 잘 지원함
- 스트리밍 같은 메시지 패턴도 구현 가능

### 2.4.5 동기 메시징 기술 비교

- RESTful
    - 비즈니스 엔터티나 기능을 HTTP 지원과 동작과 같은 자원 지향 모델로 표현하는 것이 적합한 경우
    - 웹 클라이언트 및 모바일 애플리케이션 등 다양한 클라이언트와 상호작용하는 서비스의 경우
    - 클라이언트 요청에 따라 JSON, CSV, XML과 같은 다양한 콘텐츠 타입을 지원해야 하는 서비스의 경우
    - 사람이 쉽게 읽고 이해할 수 있는 텍스트 기반 메시지 포맷을 사용해야 할 경우


- GraphQL
    - 클라이언트 측에서 어떤 데이터를 어떻게 원하는지, 어떤 데이터 포맷을 사용하는지 결정하도록 하고 싶은 경우
    - 서비스 간 통신에서 유연하지만 잘 정의된 스키마를 사용하고 싶은 경우
    - 서비스로부터 필요한 비즈니스 데이터를 더 적은 수의 요청으로 얻고 싶은 경우


- gRPC
    - 서비스 간 저지연, 고성능 통신이 필요한 경우
    - 마이크로서비스 간 타입 안정성을 보장하는 만들 수 있는 데이터 교환이 필요한 경우
    - 클라이언트 혹은 서버 애플리케이션에서 스트리밍 처리가 필요한 경우


- 웹소켓
    - 고유 데이터 포맷으로 양방향 메시징을 구현해야 하는 경우

## 2.5 비동기 메시징 패턴 구현 기술

### 2.5.1 AMQP

- 단일 수신자 메시징 패턴에 가장 자주 쓰임
- AMQP는 생산자, 브로커, 소비자 사이엥 믿을 수 있는 통신 제공
- 메시지 ack도 가능


- 언어와 무관한 프로토콜 -> 다양한 언어, 프레임워크 지원

### 2.5.2 아파치 카프카

- 오픈소스 이벤트 버스/브로커
- 메시지나 이벤트를 분산 커밋 로그로 관리
- 순서대로 내구성을 보장하며, 여러 소비자가 각기 원하는 속도를 메시지를 읽을 수 있음


- 카프카는 설계부터 고가용성, 분산 이벤트를 지원하는 브로커를 지향함. 생산자와 소비자가 메시지를 더 쉽게 제어할 수 있고, 튼튼하고 믿을 수 있음
- 또한 효과적이며 크기조절이 쉬운 메시징 인프라 제공
- 따라서 서비스에 아주 무거운 비즈니스 로직이 구현된 클라우드 네이티브 애플리케이션의 비동기 통신 패턴 구현에 아주 적합


- 카프카는 이벤트 재생이 가능
- 이벤트는 순번이 있어서 일부만 재생하는 것도 가능


- 카프카는 AMQP, STOMP(Streaming Text Oriented Messaging Protocol), MQTT(Message Queueing Telemetry Transport) 등의 프로토콜도 지원하지
  않고 이벤트 큐 시맨틱을 제공하지도 않음
- 그러나 훌륭한 성능, 이벤트 전달 보장 특성 때문에 이벤트 주도 아키텍처에 많이 씀
- 스트림 처리에도 쓰기도 함

### 2.5.3 NATS

- 간단한 오픈소스 메시징 인프라
- 개발자, 사용자가 쓰기 쉽고 성능이 좋음
- 고가용성을 보장하고, 가벼운 메시징이 가능, 여러 프로그래밍 언어 지원
- 단일 수신자, 다중 수신자 패턴에서 사용하는 최소 한 번 이상 전달이나 최대 한 번 전달과 같은 규칙 지원
- 카프카처럼 로그로 이벤트 저장, 순번으로 추적 및 관리, 재생도 가능


- NATS 역시 AMQP, STOMP, MQTT 지원하지 않음
- 그러나 태생부터 도커, 쿠버, 서비스 메시, 클라우드 네이티브 기술을 염두에 두고 만들어졌으며 가볍고, 확장성이 좋아 많이 쓴다
- 이벤트 스트리밍, IoT의 명령 및 제어 관리(command and control management), edge system 지원

## 2.6 테스팅

- 테스트 전략은 서비스 통신 패턴에 따라 달라짐


- 동기 통신은 테스트하고자 하는 서비스를 독립 실행하고, 서비스 인터페이스에 대해 테스트할 수 있음
- 테스트의 일환으로 요청을 보내고 기대하는 응답이 오는지 검사하고, 성능 지수나 에러 메시지 등을 확인 가능
- 서비스가 여러 서비스나 시스템을 쓰는 경우 이를 조합해 테스트를 진행


- 비동기 통신은 다름
- 그냥 요청 보내고 응답 검사하는 게 불가능
- 간단한 시나리오에서도 브로커의 큐에 전달하고, 특정 토픽 구독하는 과정이 필요
- 서로 의존성이 없어 이를 유닛테스트로 검사하는 건 정말 어려움
- 그래서 비동기 통신 시나리오에서는 세부 단계를 나누고
    - 생산자가 메시지를 잘 만들어서 브로커에 잘 전달하는지
    - 소비자는 브로커로부터 메시지를 잘 읽어서 잘 돌아가는지
    - 테스트해야함
- 이렇게 세분화해서 테스트하면 제대로 동작하는지 확인할 수 있지만, 종단간 통신이라는 관점에서는 단일 환경에서 생산자, 소비자, 브로커 한꺼번에 테스트해야 할 필요도 있다
- 이런 통합 테스트는 docker compose나 k8s로 자동화할 수 있다.

## 2.7 보안

- 통신 패턴에 따라 보안이 조금씩 다름
- 동기 메시징 패턴은 TLS 사용
- RESTful, gRPC, GraphQL 모두 TLS 적용 가능
- OAuth 2.0, JWT 등의 사용자 인증 및 접근 관리 패턴도 쓸 수 있음


- 비동기는 동기와 다름
- 생산자와 브로커, 브로커와 소비자 연결을 안전하게 만들어야 함
- TLS 쓰고, ACL로 인증된 생산자 및 소비자만 브로커에 접근 가능하게

## 2.8 관측 가능성 및 모니터링

- 통신 기술과는 별개
- 에이전트나 플러그인으로 메트릭 수집, 추적, 로그 기록
- 모든 동기 통신은 관측 가능성 도구를 최우선으로 제공
- 비동기 통신은 메시지 ID 입력해서 메시지 흐름을 추적하는 등 부수적인 작업 필요

## 2.9 데브옵스

- 동기 패턴은 대부분 클라우드 서비스에서 제공하는 쿠버 등의 플랫폼과 아주 잘 맞는다
- 비동기 통신 패턴은 배포 방법, 워크로드 상태, 크기 조절, 고가용성에 대한 요구사항이 동기랑 완전 다름
- 대부분 비동기 메시징 솔루션은 데브옵스 작업을 더 쉽게 하거나, 데브옵스 관련 작업이 클라우드 서비스 자체의 일부로 제공되도록 몇 가지 추상화를 제공
- Kafka나 RabbitMQ를 k8s Operator로 제공하는 등


- 데브옵스는 클라우드 네이티브 애플리케이션에만 제대로 적용할 수 있다.

[Software Delivery Guide](https://martinfowler.com/delivery.html)

## 2.10 마치며

## 질문

- 여러 책이나 아티클에서 비동기 통신을 엄청 강조하는데 실제로 다들 많이 쓰시나요? 얼마나 쓰시는지, 동기 vs 비동기 판단은 어떻게 하는지
- 비동기 요청-응답 패턴도 거의 써본 적이 없는데 (정말 필요한 경우가 아니라면) 다들 많이 써보셨나요
- 서비스 정의를 중앙화해서 쓰는 패턴을 많이 이야기하는데 이건 다들 어떻게 생각하시는지, 다른 팀에 API 공유는 어떻게 하는지
- NATS 많이 쓰나요? 순수한 궁금증
- GraphQL이 항상 주변을 보면 호불호가 갈렸는데 (전 써본 적이 없어서) 백엔드 개발자 입장에서 선호하시나요?
