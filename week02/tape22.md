# 2장 통신 패턴

- micro service가 급증하고 비즈니스 요구사항이 많아지면 서비스 간 통신 패턴이 중요해짐
- 비동기 통신은 메시지를 브로커같은 중간 매체를 통해 전달하거나, 큐 기반이나 pub/sub 패턴을 활용

### 동기 메시징 패턴

동기 통신은 요청 -응답, 원격 프로시저 호출과 같은 패턴으로 기능을 호출하고 지정한 시간 내 응답하기를 기대하는 방식으로 동작

- request-response : 요청 → 응답까지 대기(block)하며 통신 채널은 응답을 받을 때까지 커넥션을 유지해야함
    - http , RESTful 서비스
    - 묵시적인 의존성이 생기므로 성능 병목현상이 발생할 수 있음
    - orchestration, API gateway 패턴, request-reply 패턴

- 원격 프로시저 호출 패턴
    - RPC는 분산된 원격 애플리케이션 프로시저를 마치 자신의 프로시저처럼 호출하고 사용하는 동기 통신 패턴
    - 서로 다른 프로그래밍 언어 기술을 사용해 클라이언트와 애플리케이션을 만들 수 있음
        - 서비스 정의를 IDL(Interface Definition Language)통해 명세하고, stub이 제공하는 추상화 계층으로 비즈니스 로직을 구현하는데만 집중할 수 있음
    
    
    - 클라이언트 stub이 데이터를 직렬화 → 원격 서비스 호출 → RPC 런타임 컴포넌트가 네트워크 전송계층으로 전달 → 원격 서버 측에서도 RPC 런타임으로 전달 → 서버 stub을 호출하면서 TCP 기반으로 동작 → 역직렬화하여 데이터 리턴
    - gRPC (http2 기반 통신 프로토콜), 프로토콜 버퍼로 효율적이면서 타입 안정적인 데이터 직렬화를 지원
    - 서비스 조합 및 API 관리 패턴


---

### 비동기 메시징 패턴

메시지나 이벤트 브로커같은 제 3의 컴포넌트에 의해 생성 및 소비됨.

- single-receiver 패턴
    - 하나의 마이크로서비스가 단일 소비자에게 메시지를 전달하고, 소비자는 메시지 요청 작업을 처리하는 구조
        - 예: 브로커 큐에 넣으면 주문 처리 서비스가 작업을 처리
        - 브로커 큐에 메시지를 넣기 때문에 순서가 보장되고, 메시지 브로커는 최소 1회 전달을 보장함
        - AMQP 프로토콜, RabbitMQ, 아파치 ActiveMQ 등
        <img width="435" height="112" alt="Screenshot 2025-09-18 at 7 07 01 PM" src="https://github.com/user-attachments/assets/d975e52e-9811-4a55-a2c5-0f99c3aef1fe" />
       
        - 큐 기반의 단일 수신자 패턴은 end to end 메시지 전달을 보장해야할 때 주로 사용함

- multipl-receiver 패턴
    - 메시지가 하나 이상의 마이크로서비스 소비자에게 전달됨
    - 특정 topic에 메시지를 발행해서 이벤트 버스로 전달하면, 여러 마이크로서비스가 해당 토픽을 구독하고 비동기로 전달받는 구조
    <img width="464" height="145" alt="Screenshot 2025-09-18 at 7 07 21 PM" src="https://github.com/user-attachments/assets/d1c2624e-bd5d-4775-8f44-d6022c1748a4" />
    
    - 이벤트 드리븐 메시징 서비스는 아파치 Kafka, NATS, aws SNS, Azure eventGrid 등
    - 생산자가 만든 모든 이벤트를 persistence store에 저장하고 관리하지만, 이벤트가 모든 컨슈머에 전달되는 건 보장하지 않음.
    - 브로커에는 비즈니스 로직과 독립적으로 메시지를 라우팅하는 방향을 유지해야 메시지 소비 방식을 더 자유롭게 구현하고 제어할 수 있음

- 비동기 request-response 패턴
    - 생산자가 브로커를 통해 소비자에게 메시지를 전달하고,
    - 다른 브로커 채널을 통해 응답을 받는 구조
    - 요청 큐에 메시지를 보내고 잘 처리되면 생산자는 다른 응답 큐를 통해 응답 메시지를 받음.
    <img width="478" height="117" alt="Screenshot 2025-09-18 at 7 07 35 PM" src="https://github.com/user-attachments/assets/d4e691f8-e9f1-43ed-a751-f6b9a880a059" />    
    
    - 두 개의 단방향 메시지를 조합하는 것이기 때문에 성능과 부하를 고려하여 도입해야함
    - 요청과 응답 사이에 비즈니스 관계가 있는 경우에 주로 처리

---

### 서비스 정의 패턴

- 동기 통신의 경우 서비스 레지스트리라는 중앙화 된 곳에서 이루어짐
    - 마이크로 서비스는 서비스 정의를 레지스트리에 자동으로 발행
    - 사용자는 서비스 디스커버리를 통해 정의 데이터를 찾음
    - consul, etcd, zookeeper 등 주로 중앙화된 컴포넌트로 배포해서 사용
    - RESTful은 openAPI를, gRCP는 프로토콜 버퍼를, GraphQL은 GraphQL 스키마를 사용하는 등 서비스 인터페이스를 정의함
    
- 비동기 통신에서는 스키마를 통해 메시지를 직렬화, 역직렬화
    - 생산자, 소비자 모두 스키마 레지스트리에서 서비스 정의에 기록된 스키마 정보를 찾아서 사용함
    <img width="458" height="205" alt="Screenshot 2025-09-18 at 7 07 48 PM" src="https://github.com/user-attachments/assets/34c4dbb0-3063-4d3d-93e6-96a0b7fd49b0" />   
    
    - 사용하는 브로커 종류에 따라 아파치 Arvo, 프로토콜 버퍼, json 등 스키마 정의가 달라짐
    - 카프카 스키마 레지스트리를 사용하면 스키마를 저장하고 조회할 수 있어 생산자, 소비자를 통합할 수 있음
        - 버전 변경 내역도 관리해주고 직렬화 기능도 제공
        - 아마존 키네시스나 애저 이벤트 허브같은 클라우드 메시징 서비스도 스키마 레지스트리를 제공
        - AsyncAPI는 비동기 메시징에 필요한 서비스 규약에 대한 정의를 표준화
        - 비동기 메시징은 생산자와 소비자 간의 데이터 타입을 일치시키고 메시지 사이즈로 인한 성능 저하를 고려하여 스키마를 사용하는 것이 좋음.

---

### 동기 메시징 패턴 구현에 사용할 수 있는 기술

- RESTful 서비스
    - REST 모델을 준수
    - 주로 HTTP 프로토콜로 구현하며 URI로 표현하는 방식
- GraphQL
    - 유행이 죽지 않았나..?
    - 요청을 query로 보내면 응답 메시지를 받을 수 있어 클라이언트가 어떤 데이터를 어떤 방식으로, 어떤 데이터 형태로 필요한지 정할 수 있음
    - query, mutation, subscription
    <img width="462" height="264" alt="Screenshot 2025-09-18 at 7 08 05 PM" src="https://github.com/user-attachments/assets/bf6a80b0-a7e3-4fef-bf4b-871026a114d6" />
    
    - 소비자나 클라이언트에 바로 노출되는 마이크로서비스 API나 서버에 요청하는 데이터를 제어할 필요가 있는 경우 사용
- 웹 소켓
    - 웹에서 TCP를 구현한 것이며, 양방향 통신을 지원
    - 한 번 연결하면 비동기 통신이 가능하고 http 상 handshaking을 통해 연결
        - 연결하고 나면 저수준 TCP 소켓처럼 동작
    - 특정 메시지 직렬화 포맷을 강요하지 않기 때문에 아무 포맷이나 사용 가능
- gRPC
    - 제각기 다른 언어의 마이크로서비스를 로컬함수 호출처럼 불러서 사용할 수 있음
    - 이진 데이터 직렬화 포맷인 프로토콜 버퍼를 통해 클라이언트-서버 간의 데이터를 마샬링/언마샬링해줌
    <img width="480" height="145" alt="Screenshot 2025-09-18 at 7 08 16 PM" src="https://github.com/user-attachments/assets/c5ba6515-5d17-4c4b-a83b-bbb6dd27496d" />

    - 프로토콜 버퍼를 통해 서비스 인터페이스를 정의하고
    - 서비스 인터페이스를 사용해서 서버, 클라이언트 stub을 생성
    - 서비스 인터페이스 정의에 명세한 메서드를 사용해서 클라이언트가 원격 메서드를 마치 로컬 함수처럼 호출
    - gRPC 프레임워크가 데이터 직렬화, 인증, 네트워크 연결, 접근 제어 등의 모든 작업들을 처리해줌

### 비동기 메시징 패턴 구현 기술

- AMQP
    - single-receiver 메시징 패턴에 자주 쓰이는 프로토콜
    - 생산자가 메시지를 큐에 전달하면 브로커는 이에 대한 확인을 보내고, 브로커가 메시지를 소비자에게 전달하면 소비자도 메시지 확인을 보낼 수 있음
- 아파치 카프카
    - 이벤트 버스/브로커로서 메시지나 이벤트를 분산 커밋 로그로 관리
    - 이벤트를 전달한 뒤에도 삭제하지 않기 때문에 이벤트 재생이 가능하고, 순번이 있어 이 번호를 통해 일부만 선택해서 재생할 수 있음
    - 설계 자체가 고가용성, 분산 이벤트를 지향
- NATS
    - 고가용성, 가벼운 메시징, 다양한 프로그래밍 언어를 지원
    - at least once, at most once 전송 규칙 지원
    - 로그를 통해 이벤트를 저장하고 순번으로 이벤트를 재생할 수 있음
    - 이벤트 스트리밍, IoT 컨트롤, 엣지 시스템도 지원

---

### 테스팅

- 동기 통신
    - 서비스를 독립 실행하고 정상 응답, 성능, 에러 메시지 등을 확인
- 비동기 통신
    - 통신 시나리오를 세부 단계로 나누고, 메시지를 만들어서 브로커에 제대로 전달되는지 / 메시지가 소비가 잘 되는지 등으로 검사하여 테스트해야함
    - 본질적으로 통합 테스트

### 보안

- 동기 통신
    - TLS(Transport Layer Security)로 마이크로서비스 간 통신채널을 안전하게 함
    - Oauth 2.0, JWT
- 비동기 통신
    - 보안 개념은 없으나 생산자-브로커-소비자 간의 연결을 안전하게 만드는 것이 중요
    - ACL(접근 제어 목록)

### 관측 가능성 및 모니터링

- 에이전트나 플러그인 등을 통해 애플리케이션 메트릭을 수집 및 추적
- 로그를 기록하며 서비스 시각화
- 비동기 통신의 경우 메시지 관련 ID를 추가로 입력하여 흐름을 추적하거나 해야함

### 데브옵스

- 쿠버네티스 클라우드 상에서 메시지 브로커의 수를 조절하고자 하는 경우 상태를 저장하는 스토어를 별도로 작업해야할수 있음
- 카프카, RabbitMQ 등을 쿠버네티스 오퍼레이터 형태로 제공하여 추상화할 수도 있음
