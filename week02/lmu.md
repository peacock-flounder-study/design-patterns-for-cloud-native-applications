# Chapter 2. 통신 패턴
## 2.1. 동기 메시징 패턴
### 2.1.1. 요청-응답 패턴
- request-response
	- 어떻게 동작할까요: 동기, 타임아웃
	- 어떻게 사용할수 있나요: HTTP, RESTful
	- 고려해야 할 사항들
		- 외부에 제공할 경우 사용
		- 마이크로서비스 간의 의존성이 생긴다. 서비스가 많아질수록 의존 성 연결 고리는 기하급수적으로 늘어난다.

### 2.1.2. 원격 프로시저 호출 패턴
어떻게 동작할까요?
- RPC를 이용하려면 IDL(Interface Definition Language)를 사용해서 명세한다.
- 스터브: RPC 통신에 필요한 저수준 프로토콜을 처리해주는 클라이언트 측 코드와 서버 측 코드를 자동으로 만들어 준다. 이때 생ㅇ성된 코드 컴포넌트 서버 또는 클라이언트
어떻게 사용할 수 있나요?
- 수십년 전에는 CORBA(Common Object Request Broker Architecture) 등과 같은 수많은 RPC 기술을 분산 어플리케이션 개발에 사용해왔다.
- 대부분의 RPC 계층은 TCP 계층 바로 위에 만들어졌기 때문에 복잡했고, RESTful이 나오면서 도태되기 시작했다.
- 최근 gRPC가 나와 HTTP2 통신 프로토콜을 사용하여 통신하고 protobuf 를 통해 더 효율적이고 타입 안정성을 만족할 수 있는 데이터 직렬화를 지원한다.
고려해야할 사항
- 웹 또는 모바일 서비스와 같이 외부 사용자에게 노출되는 서비스의 경우 RPC가 잘 맛지 않는다.
관련 패턴들
- 서비스 조합 및 API 관리 패턴
- 요청-응답 패턴

### 2.1.3. 동기 메시징 패턴 비교
- 요청-응답
	- 사용하면 좋은 경우
		- 실시간 응답이 필요한 서비스
		- 서비스 사용이 자유로운 경우
		- 다양한 이용 방식이나 사용자가 존재할 경우
		- 외부 사용자에게 서비스를 노출해야 하는 경우
	- 사용해서는 안되는 경우
		- 응답 속도가 빠르고 처리량이 많은 통신의 경우
		- 서비스 간 통신에 엄격한 규격이나 약속이 필요한 경우
	- 이점
		- 내외부 서비스 간 통신에 사용하기 좋은 가장 일반적이고 호환성이 뛰어난 통신 패턴
- RPC
	- 사용하면 좋은 경우
		- 서비스 간 통신 속도 및 처리량이 매우 중요한 경우
		- 서비스 구성을 위해 각 서비스 간 통신에 엄격한 규격 또는 약속이 필요한 경우
		- 서비스가 사용하는 기저 통신 프로토콜과 비지니스 로직을 완전히 독립적으로 유지하고 싶은 경우
	- 사용해서는 안되는 경우
		- 웹이나 모바일과 같이 서비스가 다양한 종류의 어플리케이션과 상호 통신해야 하는 경우
		- 서비스 이용이 자유롭고 유연해야 할 경우
	- 이점
		- 효율적이고 타입 안정성을 보장할 수 있는 서비스 간 통신 패턴
		- 


## 2.2. 비동기 메시징 패턴
### 2.2.1. 단일 수신자 패턴
- single-receiver pattern
- 해당 패턴에서 전송하는 메시지를 일반적으로 명령이라고 한다.
- 점대점 비동기 메시징이라고도 부른다.
어떻게 동작할까요?
- 단일 수신자 패턴은 메시지가 전달되는 것을 보장해야 하는 경우 자주 사용한다.
어떻게 사용할수 있을까요?
- AMQP(Advanced Message Queuing Protocol)
- RabbitMQ, Active MQ, ActiveMQ Artemis 등
고려해야할 사항들
- 큐 기반 단일 수신자 패턴은 종단간 메시지 전달을 보장해야할때 많이 사용한다.
- 이 패턴을 구현할 때 사용할 수 있는 브로커 어플리케이션 중 대부분은 모놀리식 엔터프라이즈 미들웨어에 그 근간을 두고 있다. 이런 브로커들은 개발자들이 비지니스 로직 중 상당 부분을 메시지 브로커에 구현하도록 만드는 경향이 있다.
- 클라우드 네이티브 어플리케이션에서 적합하지는 않다. 가급적이면 비지니스 로직은 브로커 바깥인 마이크로서비스 안에서만 구현하는 것이 좋다.
관련 패턴들
- fire and forget 과 같은 변형 패턴들은 메시지 브로커 없이 구현하는 경우도 있다.

### 2.2.2. 다중 수신자 패턴
- 어떻게 동작할까요?
	- 특정 토픽으로 메시지를 전달하면, 하나 이상의 마이크로서비스가 토픽을 구독하는 방식
	- 이벤트 버스는 메시지 생산, 구독과 같은 요청을 처리하고 구독자 서비스들에 메시지를 전달하는 책임을 맡고 있다.
	- 모든 구독자가 메시지를 전부 다 받을 때까지 메시지를 보관해야해서 많은 부하가 가해진다.
- 어떻게 사용할 수 있나요?
	- Active MQ, RabbitMQ 등도 토픽기반을 제공한다.
	- Apache Kafka, NATS(Neural Autonomic Transport System), Amazon SNS, Azure Event Grid 등
	- 전송 기법의 경우 모든 이벤트를 영구 스토어에 저장하고 관리하는 영구 전송을 지원한다.
	- 내구성 토픽과 같은 개념을 통해 메시지 전송을 보장하기도 한다.
	- 최소 한번 전달, 최대 한번 전달, 정확히 한번 전달
- 고려해야 할 사항들
	- 중앙화된 런타임 컴포넌트로 이벤트 버스 컴포넌트가 동작
	- 내구성 토픽이나 내구성 구독 같은 메시지 기법은 반드시 그런 기능이 필요할 때만 사용해야 한다.
- 관련 패턴
	- 이벤트 주도 아키텍처
### 2.2.3. 비동기 요청-응답 패턴
- 생산자가 브로커를 통해 소비자에게 메시지를 전송하고 다른 브로커 채널을 통해서 응답을 받는다.
- 어떻게 동작할까요?
	- 메시징 모델을 사용해야한다.
	- 요청큐와 응답큐(또는 콜백 큐)를 사용한다.
- 어떻게 사용할 수 있나요?
	- 단일 수신자 패턴을 지원하는 대부분의 방법으로 비동기 요청-응답 패턴을 구현할 수 있다.
- 고려해야할 사항들
	- 동기 요청-응답 메시징의 대체제라고 생각할수 있지만, 용도가 다르다.
	- 실제 구현을 해야하는가 고민이 필요하다.

### 2.2.4. 비동기 메시징 패턴 비교
- 단일 수신자
	- 사용하면 좋은 경우
		- 한 마이크로서비스가 다른 마이크로서비스에 비동기로 전송하는 경우
		- 메시지를 순서대로 전송해야 하는 경우
		- 메시지 전송을 보장받고 싶은 경우
	- 사용해서는 안 되는 경우
		- 최소 한번 이상 전달과 같은 특별한 전송 규칙이 필요 없고, 효율적인 데이터 전송이 요구되는 경우
- 다중 수신자
	- 사용하면 좋은 경우
		- 하나 이상의 소비자가 같은 메시지나 이벤트에 관심이 있는 경우
	- 사용해서는 안되는 경우
		- 메시지 전송을 보장해야 하는 대부분의 경우
- 비동기 요청-응답
	- 사용하면 좋은 경우
		- 요청과 응답 사이에 특별한 관계가 필요한 비동기 메시징 처리의 경우
	- 사용해서는 안되는 경우
		- 동기 요청-응답 패턴 대신 신뢰할 수 이쓴 메시징 방식이 필요한 경우
## 2.3. 서비스 정의 패턴
### 2.3.1. 동기 통신에서의 서비스 정의
어떻게 동작할까요?
- 서비스 레지스트리
	- Consul, etcd, zookeepr
- RESTful 서비스는 OpenAPI, gRPC는 protocol buffer, GraphQL은 GraphQL Schema

고려해야할 사항들
- 서비스는 거버넌스와 같이 가게 된다.

### 2.3.2. 비동기 통신에서의 서비스 정의
- 스키마를 정의해서 직렬화 또는 역질렬화 한다.
- 비동기 통신은 메시지 브로커나 이벤트 버스를 통해서 통신이 일어난다.
어떻게 동작할까요?
- 아무 메시지나 발행하고 소비자가 알아서 쓰는건 현실과 동떨어진 생각이다.
- 마이크로서비스 간 신뢰할 수 있는 튼튼한 비동기 통신을 구현하려면 서비스 정의로 명세를 만들어야한다.
- 서비스 정의: Avro, Protobuf, JSON schema 를 서비스 레지스트리에서 가져온다.
- 생산자와 소비자는 이를 사용해서 메시지 브로커에 태우고 통신한다.

어떻게 사용할 수 있나요
- 초기 비동기 통신 구현에서는 스키마나 스키마 레지스트리를 많이 사용하지는 않았다.
- 중앙화된 메타데이터 스토어를 사용할수 있다.
	- 스키마 정의를 위해서 Avro, Protocol Buffer, JSON Schema
- 이벤트 주도 아키텍쳐 어플리케이션의 경우에는 CloudEvents와 같은 솔루션을 사용한다.

Kafka Schema Registry 를 사용한 스키마 정의
- Kafka Client에 Kafka Schema Registry에 대한 스키마 변경 내역 등을 관리해준다.

고려해야할 사항들
- 대부분의 비동기 메시징은 스키마 기반 직렬화 및 역직렬화를 사용하지 않고 구현된다. 이런 구현 방식은 생산자와 소비자간 메시지나 데이터 타입의 불일치를 가져오는 경우가 많다.

관련된 패턴
- 서비스 레지스트리 및 검색 패턴

## 2.4. 동기 메시징 패턴 구현에 사용할 수 있는 기술
### 2.4.1. RESTful 서비스
- URI 로 표현하는 resource
- REST 는 대부분 HTTP로 구현한다.

### 2.4.2. GraphQL
- Query, Mutation, Subscription 구조

### 2.4.3. 웹소켓
- HTTP 를 통해서 handshaking 을 하고, 해당 소켓을 통해서 계속 통신한다.

### 2.4.4. gRPC
- HTTP2 를 기반하여 구현되었다.
- 서비스 인터페이스를 정의해야한다. 이를 protobuf 를 통해서 노출한다.
- gRPC와 비슷하게 Apache Thrift 도 자체 인터페이스 정의 언어를 제공한다.

### 2.4.5. 동기 메시징 기술 비교
- RESTful:
	- 비지니스 엔티티나 기능을 HTTP 자원과 동작과 같은 자원 지향 모델로 표현하는 것이 적합한 경우
	- 웹 클라이언트 및 모바일 어플리케이션 등 다양한 클라이언트와 상호작용하는 서비스의 경우
	- 클라이언트 요청에 따라 JSON, CSV, XML 과 같은 다양한 콘텐츠 타입을 지원해야 하는 서비스의 경우
	- 사람이 쉽게 읽고 이해할 수 있는 텍스트 기반 메시지 포멧을 사용해야 할 경우
- GraphQL:
	- 클라이언트 측에서 어떤 데이터를 어떻게 원하는지, 어떤 데이터 포멧을 사용하는지 결정하도록 하고 싶은 경우
	- 서비스 간 통신에서 유연하지만 잘 정의된 스키마를 사용하고 싶은 경우
	- 서비스로부터 필요한 비지니스 데이터를 더 적은 수의 요청으로 얻고 싶은 경우
- gRPC:
	- 서비스 간 저지연, 고성능 통신이 필요한 경우
	- 마이크로서비스 간 타입 안정성을 보장하는 믿을 수 있는 데이터 교환이 필요한 경우
	- 클라이언트 혹은 서버 어플리케이션에서 스트리밍 처리가 필요한 경우
- 웹소켓: 고유 데이터 포멧으로 양방향 메시징을 구현해야 하는 경우

## 2.5. 비동기 메시징 패턴 구현 기술
### 2.5.1. AMQP
- 단일 수신자 메시징 패턴 구현에서 가장 자주 쓰이는 프로토콜
- 언어와는 무관하다.

### 2.5.2. 아파치 카프카
- 이벤트 버스/브로커로서 메시지나 이벤트를 분산 커밋 로그로 관리한다.
- 이벤트를 전달한 뒤에 이벤트를 삭제하지 않기 때문에 이벤트 재색이 가능하다.
- AMQP, STOMP, MQTT 같은 프로토콜을 지원하지 않고, Event Queue Semantic도 제공하지 않는다. 하지만 성능과 이벤트 전달을 보장하는 특성 때문에 이벤트 주도 아키텍처에서 널리 사용되고 있다.

### 2.5.3. NATS
- NATS는 클라우드 네이티브 어플리케이션을 위해 만든 간단한 오픈소스 메시징 인프라다.
- 로그를 사용해서 이벤트를 저장하고 이벤트 순번을 통해 이벤트를 추적하고 관리하면 재생 기능도 제공한다.
- NATS도 AMQP, STOMP, MQTT와 같은 프로토콜을 지원하지 않는다.

## 2.6. 테스팅
- 동기 통신은 테스트하고자 하는 서비스를 독립 실행하고 서비스 인터페이스에 테스트를 수행할수 있다.
- 비동기 통신에서는 테스트가 어렵다. 모든 요소가 의존성이 없기 때문에 유닛 테스트로 검사할수 없다. 비동기 통신 시나리오는 세부 단계로 나누고 생산자 서비스가 필요한 메시지를 만들어서 브로커에게  제대로 전달하는지, 브로커에서 메시지를 전달받고 소비해서 메시지를 검사하는 식으로 검사하는 식으로 테스트해야한다.
- 통합 테스트가 필요하다.

## 2.7 보안
- 동기 메시징 패턴의 경우 TLS를 사용해서 통신채널을 안전하게 해야한다.
- RESTful, gRPC, GraphQL 모두 TLS 사용 가능하다.
- OAuth 2.0, JWT 와 같은 사용자 인증 및 접근 관리도 함계 쓸 수 있다.
- 비동기 메시징의 경우 브로커에 접근할수 있는 TLS, ACL을 잘 관리해서 인증된 생산자 소비자만 접근 가능하게 해야한다.

## 2.8. 관측 가능성
- 동기 통신 관련 기술은 관측 가능성을 제공한다.
- 비동기 통신은 message ID와 같은 정보를 추가로 입력해서 메시지의 흐름을 추적하거나 하는 부수적인 작업이 필요하다.

## 2.9. 데브옵스
- 동기 통신 패턴은 대부분의 클라우드 서비스 회사에서 제공하는 쿠버네티스와 같은 플랫폼과 잘 맞는다.

