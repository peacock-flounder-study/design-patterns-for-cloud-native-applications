# 이벤트 주도 아키텍처 패턴

동기 통신을 주로 사용하는 서비스 컴포지션 패턴과 달리 비동기로 동작

**이벤트**는 정보를 공유하기 위한 목적.

이벤트를 생성하는 애플리케이션 측이 응답을 요구하는 경우에도, 이 응답은 직접적인 경로로 돌아오지 않음

동작 또는 시간적 특성을 이해하기 위해 연속적인 이벤트를 처리해야 할 수도 있음 -> 스트림

## 이벤트 주도 아키텍처

- 최대 한 번 전달 : 이벤트가 소비자에게 한 번만 전달되거나 전달되지 않습니다.
- 최소 한 번 전달 : 이벤트가 소비자에게 전달된다는 것을 보장하고, 같은 이벤트를 한 번 이상 소비할 수도 있습니다.

### 딱 한 번만 처리하기

이벤트에 고유한 번호 부여 or 멱등성을 가지기.

***더 높은 수준의 전달 보장은 더 높은 성능이나 복잡도를 요구하기 때문에 반드시 보장해야 하는 최저 수준을 선택***

### 메시지 브로커 유형

- 표준 메시지 브로커 : ActiveMQ, RabbitMQ
- 로그 기반 메시지 브로커 : Kafka, NATS

### CloudEvents

이벤트에 대해서도 스키마를 정의할 수 있음.

CloudEvents는 CNCF 프로젝트 -> 표준 명세

### 이벤트 스키마

JSON, XML or Avro, Protobuf(이진 포맷).

## 이벤트 전달 패턴

### producer-consumer pattern

이벤트 큐를 통해 비동기로 통신

- 비동기 이벤트 전달
- 각 이벤트를 단일 애플리케이션에서 처리하기 (?)
- 이벤트 전달 보장
- 갑자기 발생하는 대량의 이벤트 처리
- 워크로드를 공평하게 분배

**고려 사항들**

각각에 상황에 맞는 별도의 큐를 사용하는 것이 좋다 -> 컨슈머가 이벤트를 골라 처리해야 하기 때문

이벤트가 몰리는 경우를 잘 처리할 수 있어야 함.

### publisher-subscriber pattern

Best effort로 동작하며 durable subscription을 통해 최소 한 번을 보장할 수도 있음

- 이벤트 브로드캐스트
- 베스트 에포트로 이벤트 전달
- 모든 이벤트가 모든 구독자에게 전달되는 것을 보장
- 구독자에게 선택적 이벤트 전달
- 워크로드 공유

### Fire and forget pattern

최대 한 번 이벤트를 전달. 메시지 브로커가 아니라 API 활용

### Store and forward pattern

클라이언트가 서비스에 이벤트를 보낼 때 최소 한 번 전달을 보장. 메시지 브로커가 아니라 API 활용

### 폴링 패턴

긴 시간이 소요되는 작업을 시작하고 주기적으로 작업이 끝났는지 확인

백엔드 서비스를 계속 호출하는 것은 클라이언트와 백엔드 서비스의 자원을 모두 낭비하는 것.

Webhook 활용한 콜백, 웹소켓.

### request callback pattern

서비스 요청 시 콜백 정도를 함께 제공해서 콜백을 통해 응답을 전달.

- 웹소켓 : HTTP2, gRPC, GraphQL
- 웹훅 : 콜백 URL을 보내거나 미리 설정해서 응답을 전달. WebSub. 꼭 HTTP 엔드포인트가 콜백이 될 필요는 없다.

## 상태 관리 패턴
