# 이벤트 주도 아키텍처 패턴

동기 통신을 주로 사용하는 서비스 컴포지션 패턴과 달리 비동기로 동작

**이벤트**는 정보를 공유하기 위한 목적.

이벤트를 생성하는 애플리케이션 측이 응답을 요구하는 경우에도, 이 응답은 직접적인 경로로 돌아오지 않음

동작 또는 시간적 특성을 이해하기 위해 연속적인 이벤트를 처리해야 할 수도 있음 -> 스트림

## 이벤트 주도 아키텍처

- 최대 한 번 전달 : 이벤트가 소비자에게 한 번만 전달되거나 전달되지 않습니다.
- 최소 한 번 전달 : 이벤트가 소비자에게 전달된다는 것을 보장하고, 같은 이벤트를 한 번 이상 소비할 수도 있습니다.

### 딱 한 번만 처리하기

이벤트에 고유한 번호 부여 or 멱등성을 가지기.

***더 높은 수준의 전달 보장은 더 높은 성능이나 복잡도를 요구하기 때문에 반드시 보장해야 하는 최저 수준을 선택***

### 메시지 브로커 유형

- 표준 메시지 브로커 : ActiveMQ, RabbitMQ
- 로그 기반 메시지 브로커 : Kafka, NATS

### CloudEvents

이벤트에 대해서도 스키마를 정의할 수 있음.

CloudEvents는 CNCF 프로젝트 -> 표준 명세

### 이벤트 스키마

JSON, XML or Avro, Protobuf(이진 포맷).

## 이벤트 전달 패턴

### producer-consumer pattern

이벤트 큐를 통해 비동기로 통신

- 비동기 이벤트 전달
- 각 이벤트를 단일 애플리케이션에서 처리하기 (?)
- 이벤트 전달 보장
- 갑자기 발생하는 대량의 이벤트 처리
- 워크로드를 공평하게 분배

**고려 사항들**

각각에 상황에 맞는 별도의 큐를 사용하는 것이 좋다 -> 컨슈머가 이벤트를 골라 처리해야 하기 때문

이벤트가 몰리는 경우를 잘 처리할 수 있어야 함.

### publisher-subscriber pattern

Best effort로 동작하며 durable subscription을 통해 최소 한 번을 보장할 수도 있음

- 이벤트 브로드캐스트
- 베스트 에포트로 이벤트 전달
- 모든 이벤트가 모든 구독자에게 전달되는 것을 보장
- 구독자에게 선택적 이벤트 전달
- 워크로드 공유

### Fire and forget pattern

최대 한 번 이벤트를 전달. 메시지 브로커가 아니라 API 활용

### Store and forward pattern

클라이언트가 서비스에 이벤트를 보낼 때 최소 한 번 전달을 보장. 메시지 브로커가 아니라 API 활용

### 폴링 패턴

긴 시간이 소요되는 작업을 시작하고 주기적으로 작업이 끝났는지 확인

백엔드 서비스를 계속 호출하는 것은 클라이언트와 백엔드 서비스의 자원을 모두 낭비하는 것.

Webhook 활용한 콜백, 웹소켓.

### request callback pattern

서비스 요청 시 콜백 정도를 함께 제공해서 콜백을 통해 응답을 전달.

- 웹소켓 : HTTP2, gRPC, GraphQL
- 웹훅 : 콜백 URL을 보내거나 미리 설정해서 응답을 전달. WebSub. 꼭 HTTP 엔드포인트가 콜백이 될 필요는 없다.

## 상태 관리 패턴

데이터베이스에 종속되지 않고 어떻게 클라우드 네이티브 애플리케이션의 상태를 만들고 관리할 수 있는지

### 이벤트 소싱 패턴

모든 상태 변화를 일련의 이벤트처럼 저장. 애플리케이션의 특정 시점 상태를 만들어낼 수도 있음

이벤트는 발생한 순서에 따라 persistence store에 기록. 카프카와 같은 커밋 로그로 저장.

- 상태 재현 : 시, 외부에 영향을 미치거나 알림을 보낼 수 있는 시스템들은 꺼야함
- 다른 도메인 모델 생성 : 적은 부하, 독립적인 발전
- 임시 질의 실행 : ? 뭔 소리지
- 이벤트 재생

로그를 어떻게 저장할 것인가? Snapshot을 활용하자.

이벤트 소싱은 스키마 변경이 어려움. 반드시 애플리케이션의 상태를 재현하거나 다른 도메인 모델을 만드는 것이 필수인 경우에만 사용하자.

## 오케스트레이션 패턴

### mediator pattern

중재자 마이크로서비스 런타임. 이벤트 큐와 토픽, API를 통해 마이크로서비스와 상호작용하며 애플리케이션에 따라 이벤트를 변환. 대개 상태를 저장하지 않음.

이벤트를 받아서 조합해야 하는 경우 상태를 관리해야 하기도 함.

- 이벤트 분류 분산
- 이벤트를 여러 하위 이벤트로 분할
- 순차적인 작업 수행 보장

시스템이 빠르게 변하면 이 패턴 사용 권장 -> 중재자만 수정해서 통합 로직과 작업 순서 변경이 가능

중앙 오케스트레이션이 필요하지 않으면 쓰지 않기

### pipe and filter pattern

분산 방식으로 이벤트를 조율 -> 여러 이벤트 큐와 토픽을 활용해서 마이크로서비스를 연결. 거대한 그래프를 만든다.

- 독립적인 대규모 시스템 구현
- 매끄러운 기능 추가 및 삭제
- 업무 분리

책임이 각 팀으로 분산된다. 하지만 이벤트 스키마를 잘 정의하는 것이 중요하다. 이벤트 흐름이 자주 바뀌면 사용하기 어려움

### priority queue pattern

이벤트를 우선순위별로 다루어서 가장 중요한 이벤트를 먼저 다루고 낮은 순위의 이벤트는 자원이 충분히 남는 경우에만 처리

- 다른 것보다 먼저 처리해야 하는 이벤트
- 자원 사용 최적화

큐별로 오래된 이벤트를 버리는 등의 정리 작업이 필요할 수도 (높은 순위 큐로 올린다던지)

구독 필터를 활용해서 구현할 수도 있음

## 이벤트 주도 아키텍처에서 사용하는 기술

- ActiveMQ : AMQP를 구현한 가장 오래되고 가장 많이 사용하는 오픈소스 메시지 브로커. 내구성 있는 구독 확장이 불가능
- RabbitMQ : 푸시, 풀 방식 모두를 지원.
- Amazon SQS
- Amazon SNS
- Azure Event Grid
- Azure Service Bus
- Google Cloud Pub/Sub

## 테스팅

어떻게 테스트할 것인가? 기존 방식과 마찬가지로 단위 및 통합 테스트를 만들고 사용.

1. 메시지 브로커와 같이 이벤트 전달 인프라가 가용한 상태 (토픽, 큐도)
2. 이벤트 소비 검증이 가능

테스트를 위해 별도의 토픽과 큐를 사용해야 한다. 카오스 엔지니어링을 통해 실패 케이스를 테스트 해야한다.

## 보안

안전한 프로토콜로 연결하고 주고받는 데이터를 암호화.

오직 인증된 애플리케이션만 이벤트를 받아서 소비할 수 있게 해야함.

## 관측 가능성 및 모니터링

이벤트 처리 연계 어느 지점에서나 실패가 발생할 수 있다. 관측 가능성을 통해 어디서 문제가 왜 생겼는지 알 수 있어야 한다.

분산 추적 애플리케이션 + 로그를 남기자. 지속적인 모니터링

## 데브옵스

메시지 브로커가 핵심 컴포넌트.

적절한 오케스트레이션 및 이벤트 전달 패턴이 무엇인지 파악하는 것. 어느 수준의 이벤트 전달 보장이 필요한지도. 적절한 메시지 브로커 혹은 메시지 브로커를 사용하지 말자.

이벤트 스키마의 하위 호환성을 유지하자.
