# Chapter 5. 이벤트 주도 아키텍쳐 패턴
- 이벤트 주도 아키텍처 
- 이벤트는 정보를 공유하기 위한 목적으로 사용된다.
- 이벤트는 중요한 시스템 상태 변경 또는 상태 발생으로 볼수 있다.
- 이벤트 발생 빈도가 낮고 인프라 비용을 절감하고자 할때는 서버리스 (람다 등등)을 사용하면 좋다.
- 시간 축에 따라 정렬한 연속적인 이벤트들을 스트림이라 부른다.

## 5.1. 이벤트 주도 아키텍처
- 메시지 브로커가 전달하는 정도
	- At most once
	- At least once
	- Exactly once
### 5.1.1. 딱 한 번만 처리하기
- At least once는 보장할수 있지만, 이를 잘 처리하려면 idempotence 하게 만들어야한다.
- 사용자에게 영향을 미치는 비지니스 정보는 event를 idempotence하게 만들어서 실질적으로는 exactly once 해야한다.
- 간단한 알림이나 주기적인 업데이트는 손실되어도 크게 지장이 없으니 At least once로도 충분하다.
### 5.1.2. 메시지 브로커 유형
- 표준 메시지 브로커: ActiveMQ, RabbitMQ
- 로그 기반 메시지 브로커: Kafka, NATS

### 5.1.3. CloudEvents
- 스키마에 대한 정의
- CloudEvents 명세를 사용해서 설계하는게 좋다.

### 5.1.4. 이벤트 스키마
- JSON이나 XML을 많이 사용하지만, 고성능이 필요할 경우 Avro나 Protobuf 도 많이 사용한다.

## 5.2. 이벤트 전달 패턴
### 5.2.1. 생산자-소비자 패턴
- 어떻게 동작하는가?
	- 하나 이상의 생산자가 큐에 이벤트를 보낸다.
	- 메시지 브로커는 내구성이 있는 스토어에 영구적으로 저장한다.
	- 소비자는 메시지 브로커에 요청하여 순서대로 메시지를 처리한다.
- 어떻게 사용할 수 있나요?
	- 비동기 이벤트 전달
		- 생산자-소비자 패턴을 사용하는 주요한 이유
	- 각 이벤트를 단일 어플리케이션에서 처리하기
		- 이벤트 큐를 사용하면 이벤트가 여러 소비자에게 전달되지 않을 것이라고 보장할수 있다.
		- 개인 의견: http 서버로 하게 될 경우와 비교한 것으로 생각된다.
	- 이벤트 전달 보장
		- 여러가지 이유로 이벤트 소실은 발생할 수 있다.
	- 갑자기 발생하는 대량의 이벤트 처리
		- pull 방식을 사용할 경우 소비자가 자신이 처리할수 있을만큼만 가져갈수있어서 과부하가 발생하지 않는다.
			- 개인 의견: 현실에서는 pull방식으로 가져가도 JVM 이 OOM으로 터진다.
	- 워크로드를 공평하게 분배
		- 개인의견: 현실에서는 워크로드 잘 안분배된다. 카프카의 경우에는 특히 파티션을 잘 나눠야한다.
- 고려해야 할 사항들:
	- 단일 메시지 브로커에서 여러 이벤트 큐를 제공할 수도 있다.
	- 이벤트가 갑자기 몰릴때를 고려해야한다
- 관련 패턴
	- 발행자 구독자 패턴
	- Fire-and-Forget Pattern
	- Sotre-and-Forward 패턴

### 5.2.2. 발행자-구독자 패턴
- 어떻게 동작하는가
	- 내구성 있는 구독
- 어떻게 사용할 수 있나요?
	- 이벤트 브로드캐스트
	- 베스트 에포트로 이벤트 전달
	- 모든 이벤트가 모든 구독자에게 전달되는 것을 보장
	- 구독자에게 선택적 이벤트 전달
	- 워크로드 공유
- 고려해야할 사항
	- 내구성 있는 구독을 사용해야한다.

### 5.2.3. 파이어 앤 포겟 패턴
- 어떻게 동작하는가?
	- HTTP 이든 뭐든 그냥 서버에 요청하고, 그 결과는 중요하지 않다.
- 어떻게 사용할 수 있는가?
	- 베스트 에포트 방식으로 이벤트 전달하기
	- 구독 기능을 지원하지 않는 시스템에서의 이벤트 전달
- 고려해야 할 사항들
	- 이 패턴은 시간이 지나면서 가치가 떨어질 경우 처리하기 좋다.
	- 전송이 버려지면 안되면 생산자-소비자 패턴을 사용해야한다.

### 5.2.4. 스토어 앤 포워드 패턴
- 어떻게 동작하는가?
	- 최소 1번을 전달을 보장한다.
	- 데이터베이스, 브로커의 큐와 같은 내구성 있는 스토어에 이벤트 우선 저장
	- 이벤트가 성공적으로 전달하면 스토어에서 이벤트를 지운다.
- 어떻게 사용할 수 있나요?
	- 구독을 지원하지 않는 서비스로의 이벤트 전달
	- 서비스가 동작하지 않을 때 발생한 모든 이벤트 전달 보장
- 고려해야할 사항
	- 메시지 브로커를 사용할 수 없을때, 최소 한번 전달 보장이 필요할때 사용하는 것이 좋다.
	- 현실적인 해결책
	- 같은 이벤트 큐를 쓸지, 서로 다른걸 쓸지 고민을 해야한다.
	- 클라이언트가 독립적인 큐를 가지게 갈것인지, 아니면 하나를 가질것인지 고민해야한다.

### 5.2.5. 폴링 패턴
- 긴 시간이 소요되는 작업을 시작하고 주기적으로 작업이 끝나쓴ㄴ지 확인하도록 구현할 수 있다.
- 어떻게 동작할 것인가?
	- 주기적으로 백엔드서비스에 작업 완료 여부 확인 요청
- 어떻게 사용할 수 있나요?
	- 알림을 보낼 수 없는 환경에서 긴 시간이 소요되는 작업 결과 조회하기
	- 구독 또는 콜백을 사용할 수 없는 클라이언트에게 이벤트 전달
- 고려해야할 사항들
	- 클라이언트는 동작을 멈추거나 언제든지 재시작할 수 있어야한다.
	- 백엔드의 자원을 낭비하게 된다.
	- long polling 으로 전체 횟수는 줄일수 있으나, 네트워크가 안정적이며 백엔드의 서비스 처리 능력이 충분할 경우 사용할 수 있다.

### 5.2.6. 요청 콜백 패턴
- request callback pattern
	- 웹소켓
	- 웹훅
- 어떻게 사용할 수 있나요?
	- 비동기로 응답 전달
	- 지속적인 변경 내용 전달
- 고려해야할 사항들
	- 반드시 HTTP Endpoint 가 아니여도 된다.
	- event queue, email, s3 등등 다양한 방법들이여도 된다.

### 5.2.7. 이벤트 전달 패턴 정리
![[Pasted image 20251106204234.png]]
![[Pasted image 20251106204244.png]]

## 5.3. 상태 관리 패턴
### 5.3.1. 이벤트 소싱 패턴
- 어떻게 동작할까요?
	- 이벤트는 Kafka와 같이 커밋 로그로 저장해서 이벤트 순번 ID 를 통해서 특정 시점부터 이벤트를 재생할수 있게 해야한다.
- 어떻게 사용할 수 있나요?
	- 어플리케이션 상태 재현
	- 다른 도메인 모델 생성
	- 임의 질의 실행
	- 이벤트 재생
- 고려해야할 사항
	- 어플리케이션 상태 또는 이벤트 로그를 어디에 저장할지 결정해야한다.
	- 이벤트 로그를 신뢰할 수 있는 소스 원천으로 사용하면 시스템 장애가 발생하였을때 복구에 오랜 시간이 소요될수 있다.
	- 복구 시간을 줄이기 위해서 스냅샷을 중간 중간 만들어야한다.
	- 외부 서비스와 상호작용하게 되면 어렵다.
	- 커밋 로그를 통해 이벤트를 정의하여야 한다면, 변경 이벤트를 통해서 모델링 하는 것이 좋다.
	- 이벤트는 스키마를 삭제하기 어렵다. 호환이 가능하게 계속 만들어야한다.
- 관련된 패턴들
	- 주기적 상태 스냅숏 패턴
	- CQRS
	- Materialized View

### 5.3.2. 상태 관리 패턴 정리
![[Pasted image 20251106204622.png]]

## 5.4. 오케스트레이션 패턴
### 5.4.1. 중재자 패턴
- 어떻게 동작할까요?
	- ![[Pasted image 20251106204737.png]]
- 어떻게 사용할 수 있나요?
	- 이벤트 분류 및 분산
	- 이벤트를 하위 여러 이벤트로 분할
	- 순차적인 작업 수행 보장
- 고려해야할 사항들
	- 중재자가 시간이 갈수록 복잡해지고 관리가 어려워진다.
	- 중앙 오케스트레이션이 필요하지 않다면 굳이 이패턴을 쓸 필요가 없다.
- 관련 패턴들
	- 파이프 앤 필터 패턴
	- 이벤트 전달 패턴
### 5.4.2. 파이프 앤 필터 패턴
- 어떻게 동작할까요?
- 어떻게 사용할 수 있나요?
	- 독립적인 대규모 시스템 구현
	- 매끄러운 기능 추가 및 삭제
	- 업무 분리
- 고려해야할 사항들?
	- 책임이 분산된다.
	- 이벤트 스키마를 잘 정의하는게 중요하다.
	- 이벤트 흐름이 자주 바뀌면 어렵다.
- 관련 패턴들
	- 사가 패턴
### 5.4.3. 우선순위 큐 패턴
- 중요한 이벤트를 먼저 다루고 낮은 우선순위 이벤트는 자원이 충분히 남을때만 처리한다.
- 어떻게 동작할까요?
- 어떻게 사용할 수 있나요?
	- 다른 것보다 먼저 처리해야 하는 이벤트
	- 자원 사용 최적화
- 고려해야 할 사항들
	- 오래된 이벤트를 버리는 정리 작업을 구현해야한다.

### 5.4.4. 오케스트레이션 패턴 정리
![[Pasted image 20251106205139.png]]

## 5.5. 이벤트 주도 아키텍처에서 사용하는 기술

### 5.5.1. Apache ActiveMQ
- 내구성 구독을 통해 신뢰할수 잇는 이벤트 전달을 제공한다.
- 내구성 있는 구독을 확장하는 것이 불가능하기 때문에, 다수의 구독자가 있으며 고확장성을 요구하는 이벤트 주도 시스템 개발에는 사용하지 않는 것이 좋다.

### 5.5.2. RabbitMQ
- exchange: 이벤트를 받음
- binding: 규칙에 따라 이벤트를 복사하고 큐에 분산한다.
- push, pull 모두를 지원한다.

### 5.5.3. Amazon SQS
- Simple Queue Service: 완전 관리형 이벤트 큐서비스이다.
- Deadletter queue 의 메시지들을 통해 어떤 문제가 있는지 파악할 수 있다.

### 5.5.4. Amazon SNS
- 최대 한번만 도달을 보장하기 때문에 SNS를 SQS 와 함께 사용해서 소비자에게 더 신뢰성 높은 이벤트 처리를 위한 별도의 큐를 제공하는 경우가 많다.

### 5.5.5. Azure Event grid

### 5.5.6. Azure Service Bus

### 5.5.7. Google Cloud Pub/Sub


### 5.5.8 메시지 브로커 기술 정리
![[Pasted image 20251106205738.png]]![[Pasted image 20251106205749.png]]
![[Pasted image 20251106205801.png]]

## 5.6. 테스팅
