# Chapter 3. 연결성 및 조합 패턴
## 3.1. 연결성 패턴
### 3.1.1. 서비스 연결성 패턴
- 고수준 조합 패턴
- 어떻게 동작할까요?
	- 사용자에게 제공할 비지니스는 API 게이트웨이를 통해서 관리형 API로 노출한다.
	- 연결성 확보를 위해서 request-response 도는 RPC 패턴을 사용한다.
	- 내부 서비스들은 비동기처리를 할수도 있다.
	- 내부 이벤트 스트리밍을 처리해야할수도 있다.
	- 기본적으로는 서비스간 통신 혹은 서비스와 외부 시스템 간 연결성을 확보하고 클라우드 네이티브 어플리케이션의 비지니스 기능들을 조합하는 것이 핵심이다.
- 어떻게 사용할 수 있나요?
	- 거의 모든 클라우드 네이티브 어플리케이션에 적용할 수 있다.
- 고려해야할 사항들
	- 마이크로서비스와 시스템이 늘어날수록 어플리케이션의 복잡도가 증가한다.
	- 너무 연결이나 상호작용이 많다면 서비스를 너무 잘게 나눈 것이다. 개별 기능이나 도구 단위가 아닌 비지니스 기능 단위로 다시 정의하는 것이 좋다.
	- 서비스 상호작용을 서드파티 시스템으로 처리하면 상호작용 인터페이스나 프로토콜에만 의존해야한다.
	- 서비스 상호작용을 구현할때 비지니스 로직과 관련되지 않은 인프라나 네트워크 같은 기저 정보를 노출하면 안된다.
	- 어플리케이션이 꼭 필요하지 않는 기능은 사이드카와 같은 다른 계층에서 구현해야하 한다.

### 3.1.2. 서비스 추상화 패턴
- 상호작용 대상이 많으면 추상화하여서 사용한다.
- 어떻게 동작할까요?
	- 서로 다른 DNS 이름과 IP주소를 가지고 동시에 여러 인스턴스가 실행될수 있다.
	- 적당히 추상화해서 사용하는 것이다.
	- 서비스 추상화 패턴은 다음과 같은 장점이 있다.
		- 클라우드 네이티브 어플리케이션 내의 마이크로서비스나 시스템의 위치를 IP와 같이 고정하거나 안정된 위치로 나타낼 수 있다.
		- 내장 서비스 검색 기능을 통해 세부 구현 내용을 몰라도 사용할 수 있는 일반적인 이름 표기방법을 사용할수 있다. 서비스 레지스트리 및 검색 패턴의 핵심 아이디어인데, 이를 통해 모든 마이크로 서비스와 시스템의 위치를 중앙에서 관리해서 사용자가 서비스를 검색하거나 새로운 서비스를 등록할 수 있습니다.
		- 부하 분산과 장애 복구 기능을 아주 매끄럽게 제공할 수 있습니다.
		- 서비스 인스턴스가 언제든지 새로 생기거나 사라질 수 있기 때문에 마이크로서비스나 시스템의 동적 크기 조절이 가능하다. 
		- 부하 분산과 장애 복구 기능을 아주 매끄럽게 제공할 수 있다.
		- 서비스 인스턴스가 언제든지 새로 생기거나 사라질 수 있끼 때문에 마이크로 서비스나 시스템의 동적 크기 조절이 가능하다.
- 어떻게 사용할 수 있나요?
	- 쿠버네티스 서비스의 형태
	- 쿠버네티스 인그래스를 통해서 묶는 형태
	- 서비스 유형을 ExternalName으로 이용해서 외부 DNS를 별칭으로 만들어서 사용할수도 있다.

### 3.1.3. 서비스 레지스트리 및 검색 패턴
- 어떻게 동작할까요
	- 서비스 URL, OpenAPI, gRPC Protobuf 와 같은 서비스 인터페이스 정의, SLA (Service-Level Aggrement) 등 사용자가 필요로하는 대부분의 정보가 포함된다.
	- 서비스 레지스트리는 정규화 되어있다.
		- 좀 찾아보니까 spring 계열에서는 Eureka 가 그나마 현실적인 Service discovery인거 같다.
			- https://mr-spock.tistory.com/44
			- ![[Pasted image 20250907214130.png]]
			- 결국, k8s 에서는 service discovery 를 주장하지만, 개발하는 과정 + 운영하는 과정에서는 그 서비스가 실행된지 얼마나 되었는지, 그 서비스에 어떠한 이벤트가 발생했는지를 빠르게 찾아볼수 있는게 중요하다. kubernetes 는 그러한 점에서는 잘하고 있지 않다.
		- 특히 service 들은 하나의 클러스터에서만 실행되는게 아니기 때문에 + zone과 region 이슈등으로 인해서 쿠버네티스 환경에서 동작하고 있지 않은 서비스들도 검색하고, 그에 관한 정보를 획득할수 있도록 하는 규격화가 굉장히 중요한 이슈이다. 그리고 이에 따른 UI가 기본으로 제공되는가도 현실 운영에서는 굉장히 중요한 부분이다. api 서버로만 제공해두고, grafana 같은걸로 보세요 하는건 너무 비현실적이며 파편화되는 운영을 가져온다.
		- hashicorp 의 consul 도 괜찮아보이기는 한데, hashicorp 가 신뢰도를 잃어서 많은 선택을 받을수 있을지는 모르겠다.
	- 서비스 레지스트리 및 검색 패턴은 두가지 방법으로 구현할 수 있다.
		- 클라이언트 측 서비스 검색
			- 클라이언트가 서비스 정의를 서비스 레지스트리에 검색하고, 서비스를 호출하는 구조
			- Neflix Eureka 가 그 예시
		- 서버 측 검색
			- kubernetes 나 spring gateway 같은 구조
			- 일반적인 로드밸런서와 Gateway 구조들이 비슷하다.
- 고려해야 할 사항들
	- 개발하자마자 완전한 서비스 레지스트리 어플리케이션을 갖춰야하는 건 아니다.
	- 기본적인 기능 정도만 사용하고, 가능하면 쿠버네티스와 같은 곳에 의존한다.
	- 서비스 상태를 점검하거나, 의존성이 복잡해지거나 리더 선출과 같은 추가 기능이 필요할때 검토해도 괜찮다.
- 관련 패턴들
	- API 개발자 포털이라 불리는 별도의 API 레지스트리를 사용한다.

### 3.1.4. 탄력적인 연결성 패턴
- 어떻게 동작할까요?
	- 마이크로서비스 간 또는 마이크로서비스와 다른 시스템 간 탄력적인 상호작용을 설계하여 만약 연결에 문제가 발생할 경우 이를 처리하거나 복구할수 있도록 한다.
	- 핵심은 클라이언트와 통신하는 마이크로서비스에서 탄력적인 연결성 로직을 서비스 런타임의 일부로 구현해야한다는 것이다.
- 어떻게 사용할 수 있나요?
	- 타임아웃
	- 재시도
	- 데드라인
		- 타임아웃과 비슷하지만, 완료되어야하는 고정 시각을 지정한다.
		- 특히 데드라인을 전파하면서, 유저에게 일정 시간 이내에 응답해야하는 경우에 유용하다
	- 회로차단기
		- 정상 상태가 closed 이고, 비정상이 open이다. half-open 이 되면 실험적으로 허용한다.
		- 개인적으로는 용어가 헷갈려서 closed 보다는 blocked 와 allowed 를 선호한다.
	- Fail-fast
		- 대개 빠른 실패 응답이 느린 실패 응답보다 더 좋다고 여긴다.
- 고려해야할 사항들
	- 사이드카를 통해서 별도의 런타임을 구성할수 있다.
- 관련 패턴들
	- 사이드카, 서비스 메시

### 3.1.5. 사이드카 패턴
- 주 마이크로서비스 곁에 또다른 어플리케이션 또는 마이크로서비스 컨테이너를 함꼐 쓰는 방식
- 어떻게 동작할까요?
	- 통신 로직이 서비스의 비지니스 기능과 관계없는 복잡한 네트워크 통신 기능을 필요로 할 경우, 서비스 개발자는 이 통신 기능을 구현하는 데만 상단한 시간과 노력을 쏟아부어야한다.
		- Spring 기준으로는 Feign 클라이언트만 하면 된다고 생각할수 있는데 Feign 동기, Feign 비동기(flux), Armeria 등 다양한 클라이언트들을 써야하는 경우가 있는데, 이것들마다 재구현하는건 매우 피로도가 높다.
		- golang이라고 다를바가 없다. golang 도 쉽지 않다.
		- 근데 이걸 바로 도입하기도 쉽지가 않은게, istio, linkerd 가 쓰이는게 아니면 생각보다 이걸 사용하는게 쉽지 않다. envoy, linkerd-proxy 모두 그냥 날로 쓰기는 너무 어렵고 추상화된걸 써야하기 때문이다. http layer에서 retry 여부를 판단해야하는게 대부분인데 이게 어렵다.
		- cni 에서는 calico, cilium 모두 잘 되지는 않는다. cni 는 L4 정도까지만 볼수 있기 때문에 당연한 소리다.
		- k8s 의 gateway API 에서 이와 관련된 표준이 있다.
			- https://gateway-api.sigs.k8s.io/geps/gep-1731/
				- 당연하게도 대부분의 dataplane sidecar 는 envoy 이다.
	- 컨테이너는 라이프사이클을 공유한다.
- 어떻게 사용할수 있나요?
	- 사이드카 프록시
		- envoy
	- 사이드카 브릿지
		- 사이드카 프록시 방식에서는 프로토콜을 변경하지는 않는다. 하지만 프로토콜을 변경해야하는 경우가 있다. 특히 대부분은 http 로만 개발하기 때문에 이를 카프카로 바꾸거나하는 경우가 있다.
		- Dapr 가 이를 지원한다.
			- 당연하게도 이러한 데이터 스키마가 이를 서포트해야하는데 dapr 쪽에 찾아보면 cloudevent가 설명이 있다.
- 고려해야할 사항들
	- 마이크로서비스를 사이드카와 함께 사용한다는 것은 그만큼 관리하고 실행해야 할 인스턴스 수도 증가함을 의미한다.
	- 사이드카 컨테이너 관리는 별도의 컨트롤플레인 컴포넌트에 의해 이루어져야한다.
	- 사이드카 설정 자체가 아주 복잡한 로직이 될수도 있다. 연결하는 서비스와 시스템이 많아질수록 관리하는 사이드카 설정이 점점 복잡해진다.
		- istio & envoy 의 xDS 는 오버헤드가 굉장히 크다는건 널리 알려져 있다.
			- https://www.anyflow.net/sw-engineer/istio-internals-by-xds
	- 비지니스 로직과 관련된 기능을 사이드카에 구현하면 안된다.
- 관련된 패턴
	- 서비스 메시 패턴

- 현실적으로 사이드카 방식은 개발난이도가 살짝 증가하는 경향이 있다. 특히 클라우드 네이티브 생태계에 익숙하지 않은 사람들에게 가이드를 잘 제공해야한다.

### 3.1.6. 서비스 메시 패턴
- 사이드카 패턴을 확장한 것으로 클라우드 네이티브 어플리케이션의 통신 인프라스트럭쳐로서 주로 사용한다.
- 어떻게 동작할까요?
	- 서비스 메시 사이드카 프록시: 데이터플레인
	- 컨트롤 플레인
	- 서비스 메시 설정 언어
	- 내장 기능
- 어떻게 사용할 수 있나요
	- Istio, Linkerd
	- Istio가 제공하는 핵심 기능
		- 자동 부하분산: HTTP, gRPC, 웹소켓, TCP 트래픽에 대한 자동 부하 분산을 제공한다.
		- 트레픽 제어: 라우팅 규칙, 재시도, 장애 조치, 결함 주입 등의 기능을 제공한다.
		- 정책 적용: 자유롭게 추가하거나 제거할 수 있는 정책 계층과 설정 API를 통해 접근 제어, 속도 제한, 자원 제한 등의 정책 적용 기능을 제공한다.
		- 관측 가능성: 지표, 로그, 클러스터 내의 트래픽 추적 등에 대한 관측 가능성 기능을 제공한다.
		- 보안: 클러스터 내의 서비스 간 통신을 강력한 신원 기반 인증 및 권한부여로 보호한다.
- 고려해야 할 사항
	- 서비스 메시 배포 관리는 예상보다 훨씬 더 복잡할 수 있다. 서비스 메시의 복잡도는 서비스 인스턴스마다 추가로 실행되는 사이드카들의 구조와 서비스 메시 구현에서 사용되는 서비스 메시 컴포넌트들에 의해 결정된다.
	- 서비스 메시는 컨테이너와 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼에 기반하여 만들어지기 때문에 더더욱 복잡하다.
	- 모든 사이드카 프록시를 실행하고 관리하는데에 따른 성능 부하가 발생한다.
	- 서비스메시는 아직 비동기 이벤트 주도 통신과 같은 주요 통신 기법을 지원하지 않는다.

### 3.1.7. 사이드카 없는 서비스 메시 패턴
- 성능상의 이유로 사이드카 없이 만드는 경우가 있다.
- 어떻게 동작할까요?
	- 컨트롤플레인을 통한 통신 로직 설정
	- 마이크로서비스 런타임 자체가 사이드카 프록시 로직을 내장하는 경우
- 어떻게 사용할 수 있나요?
	- 구글 트래픽 디렉터의 사이드카 없는 gRPC 서비스
	- 트래픽 디렉터는 envoy 설정 API xDS를 통해 Envoy 사이드카 프록세를 제어한다.
	- istio 의 ambient mode
		- daemonset 레벨로 조절
		- eBPF 로 기반
		- https://www.anyflow.net/sw-engineer/istio-ambient-mode
- 고려해야할 사항들
	- 기존 사이드카 기반 서비스 메시 구조의 한계를 극복하기 위해 제안된 것이다.
	- 구글 트래픽 디렉터 같은 경우에는 클라이언트에 이러한 로직이 들어간다는 부담이 있고
	- istio ambient mode 의 경우에는 eBPF를 통해서 하기는 하지만 복잡하고 디버깅이 어렵다라는 특징
		- linkerd는 sidecar가 없으면 문제가 되니 그냥 쓰고, sidecar를 작게 다뤄라 라는 방향
	- cillium의 경우 cni 레벨에 걸쳐서 존재하는 방식으로 동작한다.
- 관련 패턴들
	- 
### 3.1.8. 서비스 연결성 패턴 구현에 사용하는 기술
- 대부분의 플랫폼은 서비스 추상화나 서비스 레지스트리 및 검색, 사이드카와 같은 패턴을 제공한다.
- 서비스라는 개념은 어떻게 정의하느냐에 따라 그 의미에 큰 차이를 보인다.
- Knative과 같은 서버시릇 플랫폼의 경우 어플리케이션 배포에서 서비스 추상화를 사용하는 반면, Istio 와 같은 서비스 메시 솔루션에서 가상 서비스라는 추상화 개념을 통해 어플리케이션 별로 서비스 레지스트리에 고유한 이름을 부여한다.
- 서비스 메시 솔루셔들은 탄력적 통신, 보안, 관측 가능성, 서비스 검색, 트래픽 라우팅과 같은 기능을 기본 제공한다. Istio와 Linkerd가 가장 널리 사용되고 있다.
- 서비스 메시 솔루션을 사용하지 않거나, 혹은 탄력적 통신이나 서비스 검색과 같이 필요한 기능을 지원하지 않는 플랫폼을 사용하는 경우 라이브러리를 사용해야한다.
	- Resilence4j 나 Quarkus
	- Gokit
- 특정 연결성 패턴 구현을 위해 사이드카 구조를 도입하고자 할 경우 여러 연결성 패턴을 지원하는 엔보이를 사이드카로 사용할수 있다.
- Dapr 와 같은 프로젝트의 경우에는 사이드카 브릿지와 같은 연결성 구현에 사용할 수 있다.

### 3.1.9 연결성 패턴 정리
| 패턴             | 사용해야 할 경우                                                                                                                                                                       | 사용해서는 안되는 경우                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| 서비스 연결성        | 일반적인 패턴으로 거의 모든 클라우드 네이티브 어플리케이션의 연결성 구현에 사용                                                                                                                                    | 없음                                                                                                                      |
| 서비스 추상화        | 쿠버네티스 또는 그 외 클라우드 서비스를 사용하면 명시적으로 사용해야 하는 경우가 많음<br>클라우드 네이티브 어플리케이션을 기존의 모놀리식 시스템과 연결할 때 유용함                                                                                   | 클라우드 서비스에 전적으로 의존하거나 서버리스 플랫폼을 사용할 경우 일부러 이 패턴을 적용할 필요는 없음                                                              |
| 서비스 레지스트리 및 검색 | 광범위한 클라이언트가 사용하는 수십, 수백개의 서비스를 관리하는 경우 완전한 서비스 레지스트리 및 검색 패턴이 반드시 필요하며 대부분의 경우 쿠버네티스와 같은 플랫폼이 제공하는 서비스 검색 기능만으로도 충분함<br>AWS나 Azure, GCP와 같은 클라우드 서비스를 사용하면 관련 기능들이 대부분 기본으로 제공됨 | 관리해야 하는 서비스가 적으면 완전한 서비스 레지스트리 및 검색 서비스는 필요 없음<br>하지만 DNS와 같은 서비스 검색 기법에 사용하는 일부 기술들은 서비스 위치와 배포 세부사항 등을 캡슐화하기 위해 사용해야함 |
| 서비스 탄력성        | 여러 서비스와 시스템과 연결해야 하는 신뢰할 수 있는 클라우드 네티이브 어플리케이션 구현에는 적용해야함<br>클라우드 네이티브 어플리케이션과 레거시 시스템 연결에는 필수로 사용해야 함<br>기저의 서비스 메시 솔루션 또는 클라우드 서비스가 탄력적 연결성을 지원하지 않으면 명시적으로 구현해야 하는 경우가 있음    | 기저의 서비스 메시 솔루션이나 클라우드 서비스에서 이러한 기능을 제공하는 경우, 또는 서버리스 플랫폼을 사용하는 경우 명시적으로 서비스 탄력성을 구현할 필요가 없음                             |
| 사이드카           | 비지니스 로직과 연결성 로직을 서로 분리하고 싶을 때 사용<br>연결 로직이 너무 복잡할 경우 별도의 런타임을 분리하는 것이 좋음<br>동일한 연결성 기능을 다양한 프로그램                                                                                | 데브옵스 조직에서 사이드카 구조와 복잡성을 다룰 수 없으면 적용해서는 안됨<br>컨테이너 오케스트레이션을 사용하지 않으면 사이드카 구조를 지원하는 것이 너무 복잡함                             |
| 서비스메시          | 여러 마이크로서비스 연결에 탄력성, 트래픽 라우팅, 보안 통신, 서비스 검색, 관측 가능성과 같은 기능을 구현하려고 할 때                                                                                                            | 사이드카 패턴과 동일함                                                                                                            |
| 사이드카 없는 서비스 메시 | 사이드카로 인한 성능 저하가 두드러질 경우<br>기저의 기술 스택이 사이드카 없이도 컨트롤 플레인을 통한 설정 관리 및 적용이 가능할 때                                                                                                    | 초기 단계의 기술이기 때문에 GCP트래픽 디렉터와 같이 적용할 수 있는 기술 스택이 없는 경우 사용하지 않는 것이 좋음                                                      |
## 3.2. 서비스 조합 패턴
- 서비스 조합은 여러 서비스와 시스템들을 통합하고 연결해서 어떻게 비지니스 기능을 구현하는지를 다룬다.

### 3.2.1. 서비스 오케스트레이션 패턴
- 단일 서비스에서 여러 서비스와 시스템을 호출해서 비지니스 기능을 구현한다.
- 대부분 동기 통신 방식을 사용하며 상태를 저장하지 않는 무상태 방식으로 동작한다.
- 어떻게 동작할까요?
	- 여러 마이크로서비스와 시스템을 통합하고 호출한다.
	- 다운 스트림서비스에서는 동기와 비동기 모두를 사용할수 있다. 하지만 최초 호출에 응답할때는 동기적으로 하는 것이 일반적이다.
	- 다운 스트림으로 뭘 사용하는지 모를 수 있다.
- 어떻게 사용할 수 있나요?
	- 클라우드 네이티브 분야 이전에도 ESB나 워크플로 엔진과 같이 통합 로직을 구현하기 위해서 사용하고 있었다.
		- 워크플로 엔진: https://docs.dapr.io/developing-applications/building-blocks/workflow/workflow-patterns/
	- 각 서비스들은 HTTP기반인 REST나 gRPC, SOAP등 다양한 프로토콜을 사용한다.
- 고려해야할 사항들
	- 여러 다운 스트림 기능을 조합해서 특정 비지니스 기능을 만들 수 있는 경우에만 적용해야한다. 그렇지 않으면 여러 비지니스 기능을 가지는 모놀리식 서비스를 만드는 것에 불과할 뿐이다.
	- 서비스 오케스트레이션은 상태를 저장하지 않는 방식으로 구현할 수 있을 때만 적용하는 것이 좋다. 그래야 다른 서비스들의 상태를 관리하지 않아도 되기 때문이다.
	- 조합 로직에서 호출하는 서비스를 되도록 적게 유지하는 것이 좋다. 조합 로직에서 네다섯 개의 서비스를 호출해야 한다는 것은 서비스를 잘못 나눴거나, 또는 서비스들을 너무 잘게 나누었다는 뜻일 수 있다.
	- 서비스 오케스트레이션 패턴에서는 조합 로직을 하나의 서비스에서만 처리하며, 이 서비스는 연결된 다른 모든 서비스에 강한 의존성을 가진다.
- 관련 패턴
	- 서비스 오케스트레이션은 서비스 코레오그래파와같은 다른 서비스 조합 패턴과 함께 사용할 수 있다.

### 3.2.2. 서비스 코레오그래피 패턴
- 서비스 조합 패턴을 적용할 때 조합 로직을 단일 서비스에 집중해서 구현하지 않고 여러 서비스에 나누어 만드는 것
- 어떻게 동작할까요?
	- 메시지 브로커를 사용해서 이벤트 기반으로 상호 작용한다
	- 코레오그래피에서 사용하는 마이크로서비스들을 반응형 마이크로 서비스라고 부른다.
	- 메시지 브로커를 기본 메시징 인프라스트럭쳐로 사용한다.
- 어떻게 사용할 수 있나요?
	- 특별한 기술이나 프레임워크 없이 메시지 브로커를 통한 비동기 메시징으로 서비스와 시스템들을 잘 조작하기만 하면 된다.
- 고려해야할 사항들
	- 서비스 조합 로직이 여러 마이크로 서비스에 분산되어 있다. 서비스 오케스트레이션은 조합 로직을 하나의 서비스에서 구현하기 때문에 이것만 봐도 비지니스 로직이 어떤지 이해할 수 있지만, 서비스 코레오그래피 패턴의 비지니스 로직은 하나의 서비스 로직만 보고 이해할 수 없다.
	- 서비스는 서로 느슨하게 결합된다. 서비스 오케스트레이션에 비해 서비스를 추가하거나 빼는 것이 훨씬 쉽다.
	- 서비스 코레오그래피 패턴이 비동기 이벤트 주도 통신을 사용하기 때문에 서버리스 플랫폼으로 구현할 수도 있다.

### 3.2.3. 사가 패턴
- 여러 마이크로서비스를 묶어서 새로운 서비스 조합을 만들 때, 이 서비스 간 상호작용을 트랜잭션으로 동작하게 해야할 경우가 있다.
- 트랜잭션의 경계가 여러 마이크로서비스들에 걸쳐 있기 때문에, 분산 트랜잭션이라고 부르기도 한다.
- 서비스 오케시트레이션과 서비스 코레오그래피 패턴 모두에 적용할 수 있다.
- 어떻게 동작할까요?
	- 트랜잭션을 여러 하위 트랜잭션 및 연계되는 보상 트랜잭션으로 나누어 마이크로서비스들에 배치하여 분산 트랜잭션으로 만든다.
	- 분산 트랜잭션은 트랜잭션 관리자라고 불리는 중앙 프로세스를 통해 트랜잭션의 각 단계를 조율한다. 주로 2PC 프로토콜을 사용한다. 하지만 트랜잭션을 필요로 하는 마이크로 서비스가 많을 경우에는, 2PC 프로토콜을 제대로 사용하지 못한다.
		- 트랜잭션 관리자가 단일장애점이 된다. 따라서 트랜잭션 관리자가 제대로 동작하지 않으면 대기중인 트랜잭션이 절대 끝나지 않게 된다.
		- 특정 서비스가 응답하지 않으면 전체 트랜잭션이 멈춘다.
		- 2PC 프로토콜에서는 트랜잭션에 참여하는 전체 서비스가 트랜잭션 관리자에게 트랜잭션 내용을 반영하겠다는 응답을 보내야만 해당 트랜잭션 내용을 반영한다고 가정한다. 하지만 이는 실제 상황과는 차이가 있다. 어떤 서비스의 경우 트랜잭션 내용을 실제로 반영하지 못했으면서 트랜잭션 관리자에게는 트랜잭션을 반영했다고 응답할수도 있다.
	- 사가 실행 관리자를 가진 마이크로 서비스가 트랜잭션을 조합한다.
	- 사가 패턴의 개념 자체는 어렵지 않지만 클라우드네이티브 어플리케이션의 사가 패턴은 여러 마이크로서비스에 분산해서 구현해야 하며, 마이크로서비스들이 추가되거나 제거 될수 있기 때문에 각 분산 트랜잭션의 보관 기간이 짧다. 
	- 사가 패턴은 주로 서비스 오케스트레이션 패턴과 함께 사용한다. 서베스 코레오그래피에서도 사용할수있지만, 이 경우 중앙의 SEC(Saga Execution Coordinator)가 없으며 각 마이크로서비스가 브로커를 통해 트랜잭션 작업을 수행해야 한다.
- 어떻게 사용할 수 있나요?
	- 사가 패턴을 적용하면 각 마이크로서비스에 로컬 트랜잭션과 더불어 연관 보상 트랜잭션도 함께 구현해야한다.
	- Camunda나 Apache Camel과 같은 프레임워크나 워크플로 엔진을 사요해서 지원한다.
- 고려해야할 사항들
	- 사가패턴을 구현할 때는 사가 실행 관리자를 통해 서비스 간 비지니스 트랜잭션의 상태를 저장하고 관리할 수 있는 사가 프레임워크나 워크플로 엔진을 사용해야한다. 바닥부터 모든 것을 완전히 새로 만드는 것은 너무 복잡하고 규모가 크다. 
	- 분산 서비스에서 실행되는 비지니스 트랜잭션을 디버깅하고 문제를 해결하기 위해 적절한 관측가능성 솔루션을 반드시 함께 실행해야 한다.
	- 사가 프레임워크는 반드시 확장 가능한 분산 로그를 지원해야한다. 단일 트랜잭션에서 사가 로그에 엄청난 양의 이벤트를 기록할 수도 있기 때문이다.

### 3.2.4. 서비스 조합 패턴 구현 기술
- 서비스 조합 패턴은 여러가지 구현 기술들로 만들어진다.
	- 스프링부트나 쿼커스, Micronaus, Go kit과 같은 마이크로서비스 개발 프레임워크를 사용하거나 직접 서비스 조합을 구현한다.
	- 서비스 조합을 구현할때 전용 로직을 별도로 만들거나 아파치 개열과 같은 독맂벅은 통합 프레임워크를 사용하는 것이 좋다.
	- 워크플로와 사가 구현을 위해서 Camunda나 Netflix Conductor, Uber Cadence와 같은 솔루션을 사용해서 서비스 조합을 상태 저장 및 관리가 가능한 트랜잭션 형태로 구현할수도 있다.
### 3.2.5. 서비스 조합 패턴 정리

| 패턴          | 사용해야 할 경우                                                                             | 사용해서는 안되는 경우                                                                                           |
| ----------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| 서비스 오케스트레이션 | 비지니스 기능을 구현할 때 하나의 서비스가 다른 서비스 및 시스템과의 상호작용을 제어해야할 경우<br>대부분의 인터렉티브 서비스에 잘 맞음         | 서비스 간 의존성이 문제가 될 경우<br>어플리케이션이 주로 비동기 메시징이나 이벤트를 사용하는 경우                                               |
| 서비스 코레오그래피  | 이벤트 주도 마이크로서비스들로 서비스 조합을 만들어야하는 경우<br>클라우드 네이티브 어플리케이션의 마이크로서비스들 간 의존성이 없도록 만들고자 할 경우 | 사용자에게 제공하는 API와 같은 인터렉티브 서비스의 경우                                                                       |
| 사가          | 여러 마이크로서비스 간 분산 트랜잭션 구현이 반드시 필요한 경우                                                   | 트랜잭션 실행에 필요한 보상 작업을 실행할 수 없는 서비스인 경우<br>프레임워크나 솔루션이 사가 실행을 지원하지 않는 경우(사가 패턴을 바닥부터 전부 새로 만드는 것은 너무 복잡함) |
