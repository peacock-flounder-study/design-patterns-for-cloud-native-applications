# Chapter 03. 연결성 및 조합 패턴

서비스 간 연결을 어떻게 하고 서비스 조합을 통해 어떻게 새로운 비즈니스 기능을 만드는지.

## 연결성 패턴

비즈니적인 연결성 외에도 보안, 관측 가능성, 신뢰성, 부하 분산 같은 외적인 요구도 있음.

### 서비스 연결성 패턴

각 서비스 간 연결에 적합한 다양한 통신 패턴을 사용.

- 외부 : Request-Response 메시징 패턴
- 내부 : 비동기 메시징 패턴 (using Kafka) or gRPC (마이크로 서비스 간 통신)

**인프라스트럭처나 네트워크 같은 기저 정보를 연결성 구현에 사용하거나 노출해서는 안된다.**

### 서비스 추상화 패턴

- 일반적인 이름 표기법 사용 가능
- 부하 분산과 장애 복구 기능, 동적 크기 조절이 가능

쿠버네티스를 활용하여 추성화

### 서비스 레지스트리 및 검색 패턴

서비스 정보를 한데 모아서 관리하면 사용자가 서비스를 검색하고 정보를 얻기도 쉬워짐

서비스 URL, OpenAPI, gRPC ProtoBuf, SLA와 같은 정보가 포함됨.

1. 클라이언트 측 서비스 검색

클라이언트가 서비스를 검색하고 사용.

2.서버 측 검색

LB 같은 컴포넌트에서 서비스 정보 가져와서 호출하는 방식.

LB 캐시에 저장해놓고 사용

**쿠버네티스는 etcd를 내부적으로 서비스 레지스트리처럼 사용하지만, 별도의 서비스 레지스트리와 같은 수준의 메타데이터 관리 기능을 제공하지는 않는다.**

외부 노출 API 관련 **API 레지스트리** 라는게 있는데, 서비스 레지스트리와 비슷하지만 일부 비즈니스 기능만 저장한다는 점이 다름

### 탄력적인 연결성 패턴

네트워크는 신뢰할 수 없는 영역으로 간주

- **Timeout** : 장애가 발생해도 인지하는데 걸리는 시간이 오래걸릴 수 있음. 현실적으로 지정.
- **Retry** : 최대 몇 번의 재시도, 어느정도의 시간 간격을 둘 것인지.
- **Deadline** : 특정 시간까지 서비스 호출이 완료되어야 하는 고정 시각. -> 초과되면 데드라인 초과 처리 로직을 호출
- **Circuit breaker** : 정상은 닫힌 상태, 실패 횟수가 임계치를 넘으면 열린 상태로 바꾸고 서비스 호출 차단. 서비스 호출이 가능하게 다시 circuit reset time-out 후에 돌릴 수도 있으며, Half-open 할 수도.
- **Fail Fast** : 빠른 실패 응답이 느린 실패 응답보다 좋다.

서비스 비즈니스 로직, 사이드카, 단순 CSP 기능 설정으로 구현할 수 있음

### 사이드카(Sidecar) 패턴

주 컨테이너의 기능을 확장하거나 향상 -> 타 마이크로서비스 연결성 로직 구현할 떄 자주 사용

사이드카와 주 컨테이너는 라이프 사이클을 공유.

같이 배포하면 멀티 컨테이너 파드.

- 사이드카 프록시 : 프록시처럼 사용해서 들어오거나 나가는 통신 관리. 엔보이 설정 관리 API 등을 통해 사이드카 프록시 동작 조절 가능.
- 사이드카 브릿지 : 프록시는 프로토콜을 바꾸지 않지만, 브릿지는 서로 다른 두개의 프로토콜을 연결해줄 수 있음.

장점만 있지 않음.

- 사이드카 : 실행해야 할 인스턴스(리소스)도 늘어난다
- 사이드카 컨테이너 관리는 별도의 컨트롤 플레인 컴포넌트에 의해 이뤄져야 한다.
- 사이드카 설정 자체가 아주 복잡한 로직이 될 수도 있음
- 비즈니스 기능을 사이드카에 넣지 마라

### 서비스 메시(Servie Mesh) 패턴

사이드카를 확장한 것으로, 마이크로서비스 간, 시스템 간 연결성을 구현할 때 맞닥뜨리는 문제를 해결

마이크로서비스가 비즈니스 로직과 연결성 로직 모두를 책임지고 관리해야 함.

그런데 서비스 간 통신 기능은 서로 다른 여러 마이크로서비스에서도 비슷한 요구사항을 가지는 경우가 많음. 따라서 사이드카 같은 다른 계층에 기능을 구현하고 서비스 코드를 독립적으로 유지

sidecar injection을 통해 외부와 통신하게 만들고, 컨트롤 플레인이 중앙에서 모든 사이드카를 연결. 데이터 플레인은 신뢰성, 보안, 관측 가능성, SD 등을 제공하고 이를 컨트롤 플레인에서 제어하게 함.

Istio와 Linkerd가 가장 널리 사용되고 있음.

다음과 같은 요소 제공 :
- 자동 부하 분산
- 트래픽 제어
- 정책 적용
- 관측 가능성
- 보안

생각보다 훨씬 복잡할 수 있으며, 사이드카 프록시를 실행하고 관리하는 성능 부하가 발생할 수 있다.

### sidecarless service mesh pattern

컨트롤 플레인이 사이드카 프록시의 네트워크 통신을 관리/제어할 수 있다면, 왜 주 컨테이너의 클라이언트 컴포넌트는 관리하지 못하냐? 에서 시작.

단, 마이크로 서비스를 구현하는 각 기술 스택이 컨트롤 플레인 API와 각 네트워크 통신 계층별로 요구하는 네트워크 통신 로직을 지원해야 함.

GCP의 traffic director : API xDS를 통해 Enovy 사이드카 프록시를 제어하는 컨트롤 플레인 역할을 함.

xDS 프로토콜이 중요.

## 서비스 조합 패턴

서비스 오케스트레이션, 서비스 코레오그래피, 사가 패턴

### Service orchestration pattern

대개 동기 통신 방식, 스테이트리스

서비스 연계를 통해 다시 전달. Apache Camel 같은 걸 사용할 수도 있음.

상태를 저장하지 않는 방식으로 구현할 수 있을 때만 적용하자 + 조합 로직에서 호출하는 서비스를 되도록 적게 유지하는 것이 좋다.

### Service choreography pattern

조합 로직을 단일 서비스에 집중해서 구현하지 않고 여러 서비스에 나누어 만들고 싶을 수 있음.

메시지 브로커 기반으로 여러 서비스가 비동기 메시징을 통신

서비스는 서로 느슨하게 결합하며, 서비스 오케스트레이션에 비해 서비스를 추가하거나 빼는 것이 훨씬 쉽다.

### Saga pattern

서비스 간 상호작용을 트랜잭션으로 동작하게 해야할 때가 있음 (distributed transaction)

여러 하위 트랜잭션 및 compensating transaction으로 만들어져 있음.

SEC(Saga Execution Coordinator)를 사용하거나 사용하지 않을 수도 - 단, 모든 로그가 잘 기록되어야 한다.

가능하면 사가 프레임워크나 워크플로 엔진을 사용하자. 
