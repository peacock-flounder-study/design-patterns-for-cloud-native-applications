# Chapter 6. 스트림 프로세싱 패턴
## 6.1. 스트림이란?
- 시간 순서에 따라 정렬된 일련의 연속적인 이벤트
- StockStream 은 JSON 으로 구성되며 구조적으로 symbol, price, volume 이 들어간다.

## 6.2. 스트림 프로세싱이란?
- 이벤트를 소비해서 다른 이벤트 포맷으로 변환하는 무상태 서비스부터 낮은 지연시간과 높은 신뢰성을 보장하기 위해 메모리에 상태 데이터를 저장하고 처리하는 복잡한 서비스가 이에 해당한다.
- 스트림 프로세싱 어플리케이션을 만들때는 무상태로 할지 상태로 할지가 설계에 큰 영향을 미친다.

## 6.3. 스트리밍 데이터 프로세싱 패턴
- 실시간 이벤트들의 변환, 필터링, 어그리게이션, 의미 있는 연속적인 이벤트 탐지 등을 통해 의미 있는 결과를 도출하는데 중점을 두고 있다.
- 영구 데이터 스토어를 많이 사용하지 않아야한다.

### 6.3.1. 변환 패턴
- 어떻게 동작할까요?
	- 특정 데이터형태를 원하는 데이터 형태로 변환시킨다음 넘긴다.
- 어떻게 사용할수 있나요?
	- 메시지 변환
		- 전통적인 프로그래밍 언어를 사용해서 데이터 매핑을 수행하여 변환할수도 있다.
		- Mustache 와 같은 간단한 텍스트 템플릿을 사용해서 템플릿을 만들고 이벤트를 생성할수 있다.
	- 프로토콜 전환
		- 서로 다른 메시지 브로커를 사용해서 호환이 안되는 경우
- 고려해야할 사항들
	- 무상태 변환의 경우, 아무 문제 없이 쉽게 확장 가능하다.
		- 개인 경험: 실제로는 Partition 같은 Queue Level 의 퍼포먼스 제약때문에 큐가 가득차서 확장이 불가능한 경우가 발생한다. 이럴 경우때문에 초기 Partition 개수를 잘 지정하는게 굉장히 중요하다.

### 6.3.2. 필터와 한계값 패턴
- 어떻게 동작할까요?
	- 적적히 원하는 패턴을 통해서 걸러서 원하는데이터만 처리한다.
- 어떻게 사용할 수 있나요?
	- 분류별로 이벤트 걸러내기
	- 시나리오: 경고를 위한 한ㄴ계값 적용
- 고려해야할 사항들
	- 관계 없거나 낮은 우선순위 이벤트를 버림으로써 부하를 줄일수도 있다.
	- 최신 메시지 브로커들은 이런 기능을 기본적으로 제공한다.
	- 필터는 무상태 어플리케이션으로 만들수 있다.


### 6.3.3. 윈도우드 어그리게이션 패턴
- 어떻게 동작할까요?
	- 윈도우가 어떻게 동작하는지를 이해해야한다.
	- 길이 기반 슬라이딩, 길이 기반 배치, 시간 기반 슬라이딩, 시간 기반 배치
- 어떻게 사용할수 있나요?
	- 모니터링 분야와 같이 데이터가 일부 유실되어도 관계없는 경우에는 이 패턴을 적용할수 있다.
	- 신뢰성이 필요하다면 별도의 처리가 필요하다.
		- 시간에 따른 이벤트 종합
		- 길이별로 구간을 나누고 이벤트 종합
- 고려해야할 사항들
	- 상태를 가지기 때문에 시스탬 장애 또는 재시작 등으로 인한 이벤트 유실이 발생하면 무결성을 보장할수 없다.
	- 무결성을 보장해야한다면 별도의 추가적인 처리를 해서 시스템의 장애 또는 재시작을 대비해야한다.
	- 높은 정확도와 효율성을 모두 만족하는 모든 종류의 어그리게이션을 만드는 것은 불가능하다.
	- 윈도우 없이도 어그리게이션을 처리할 수 있다. 하지만 이러면 언젠가는 가용한 시스템 메모리가 없어진다.
	- 바닥부터 만들기보다는 라이브러리를 쓰는게 좋다.
		- Esper, Siddhi 같은 스트림 처리 라이브러리 또는 클라우드 네이티브 스트림 처리 프로세서를 사용하는 것이 좋다.
			- Esper: https://velog.io/@thinkp92/%EC%97%90%EC%8A%A4%ED%8D%BCEsper
				- https://esper.sourceforge.net/esper-0.7.5/doc/reference/en/html_single/index.html
				- 자바계열은 참... 문서를 볼떄마다 쉽지 않다. 이런 방식이 좋은 측면이 있긴 하지만 개인적으로는 비선호 한다.
			- Siddhi: https://github.com/siddhi-io/siddhi

### 6.3.4. 스트림 조인 패턴
- 어떻게 동작할까요?
	- 합칠 이벤트를 식별할수 있는 조건을 정의한다.
	- 얼마나 많은 이벤트를 기다려야할지 결정하는 버퍼를 정의해야한다.
- 어떻게 사용할수 있나요?
	- 버퍼에 합칠 이벤트들을 저장하고 있기 때문에 스트림 조인 패턴은 상태를 가진다.
	- 중요한 비지니스 데이터를 다루지 않는다면(이벤트가 유실되도 된다면), 쉽게 쓸수 있다.
	- 이벤트 유실이 발생하면 안된다면 신뢰성 패턴과 함께 사용해서 시스템 장애나 재시작의 경우에도 이벤트가 유실되지 않도록 해야한다. 
	- 확산 및 조합
		- 같은 이벤트를 동시에 서로 다른 작업을 수행하고 그 결과를 조합함으로써 모든 이벤트를 단일 이벤트처럼 만들수 있다.
	- 여러 종류의 이벤트 조인
- 고려해야할 사항들
	- 조인은 상태 관리가 필요하다. 조인 작업을 제대로 수행하려면 반드시 필요한 이벤트가 도착할 때까지 기다려야한다. 이벤트가 유실되어서는 안되는 경우 반드시 신뢰성 패턴을 함께 사용해서 시스템에 장애가 발생하거나 재시작하는 경우에도 이벤트를 저장하고 사용할 수 있도록 해야한다.
	- 확산과 조합 같은 경우에는 메시지 브로커에서 이벤트를 바로 읽어와서 이벤트들을 성공적으로 조합할 때까지 응답을 미룰 수 있다.
	- 아주 긴 시간동안 여러 이벤트를 합치는 것은 상당히 어렵다. 샤드를 잘 설계해서 조인을 병렬적으로 처리하고 관련된 이벤트들이 같은 샤드에 저장될 것임을 보장해두는게 좋다.

### 6.3.5. 임시적인 이벤트 정렬 패턴
- 어떻게 동작할까요?
	- 비결정적 유한 상태 기계처럼 동작한다.
- 어떻게 사용할수 있나요?
	- 이벤트 순차 발생 탐지
	- 이벤트가 발생하지 않음을 탐지
- 고려해야할 사항들
	- 신뢰성 패턴을 써야한다.
	- 이벤트 순서가 중요한 경우가 있다.

### 6.3.6. 머신 러너 패턴
- 어떻게 동작할까요?
	- 미리 정의된 머신러닝 모델
	- 온라인 머신러닝 모델
- 어떻게 사용할 수 있나요?
	- 미리 정의한 머신러닝 모델로 결과 예측하기
	- 데이터를 통한 지속적인 학습 모델
- 고려해야할 사항들
	- 미리 정의된 머신러닝 모델은 구현하기도 훨씬 쉽고 데이터만 충분하다면 높은 정확도를 보인다
	- 온라인 머신러닝 모델은 새로 학습한 내용을 메모리에 저장하기 때문에 신뢰성을 보장하기 위해서 추가적인 작업을 해주어야한다.
### 6.3.7. 스트리밍 데이터 프로세싱 패턴 정리


| 패턴          | 사용하면 좋은 경우                                                                                                    | 사용해서는 안되는 경우                                                                                         | 이점                                                                                |
| ----------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| 변환          | - 이벤트 포맷이나 구조, 프로토콜을 바꾸어야 하는 경우<br>- 이벤트의 데이터 일부를 추가, 수정 또는 삭제해야 하는 경우<br>- 서드파티 시스템에서 현재 사용하는 이벤트를 지원하지 않을 때 | - 이벤트를 소비하는 시스템이 이벤트를 파악하고 그대로 사용할 수 있는 경우                                                           | - 호환되지 않는 시스템과 이벤트를 주고받을 수 있음<br>- 관련 정보만 포함시킴으로써 이벤트 크기를 줄일 수 있음                 |
| 필터와 한계값     | - 이벤트 처리에 이벤트의 일부만 사용할 경우                                                                                     | - 이벤트 처리에 모든 이벤트를 사용할 경우                                                                             | - 이벤트 일부만 사용함으로써 시스템에 가해지는 부하를 줄일 수 있음                                            |
| 윈도우드 어그리게이션 | - 시간 간격 또는 길이에 따라 이벤트들을 나누고 조합해야할 경우<br>- 총합, 최솟값, 최댓값, 평균, 표준편차, 이벤트 개수 등의 작업을 처리해야 할 경우                     | - 이벤트의 중앙값 찾기와 같이 고정된 크기의 메모리 공간에서 처리할 수 없는 작업인 경우<br>- 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우              | - 이벤트를 나누어 처리함으로써 시스템의 부하를 줄일 수 있음<br>- 데이터에 대한 요약을 제공함으로써 전체 데이터보다 더 쉽게 이해할 수 있음 |
| 스트림 조인      | - 두 개 이상의 이벤트 스트림의 이벤트들을 합쳐야 하는 경우<br>- 병렬 처리를 위해 나눈 이벤트들을 다시 합쳐야 하는 경우                                       | - 합쳐야 할 이벤트들이 가까운 시간 간격 내에 도착하지 않는 경우<br>- 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우                           | - 서로 연관된 이벤트들을 처리할 수 있음<br>- 이벤트의 동기화 처리가 가능함                                     |
| 임시적인 이벤트 정렬 | - 이벤트 발생 순서를 알아내야할 경우<br>- 이벤트가 발생하지 않았음을 알아내야 할 경우                                                           | - 유한 상태 기계에서 이벤트 발생 순서를 정의할 수 없는 경우<br>- 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우<br>- 이벤트가 순서에 맞지 않게 도착하는 경우 | - 이벤트 도착 순서에 따라 복잡한 조건들을 탐지할 수 있음                                                 |
| 머신 러너       | - 실시간 예측 작업이 필요한 경우<br>- 이벤트에 대한 분류, 군집, 회귀분석 등의 작업이 필요한 경우                                                   | - 모델을 사용하여 값을 정확하게 예측할 수 없는 경우<br>- 머신러닝 모델을 만들기 위한 과거 데이터가 충분하지 않은 경우                               | - 자동화된 의사 결정 시스템을 만들 수 있음<br>- 합리적인 추론 기능 제공                                      |

## 6.4. 확장성 및 성능 최적화 패턴

### 6.4.1. 순차 수송 패턴
- 이벤트를 다양한 분류로 나누고 병렬 처리하는 방식으로 확장한다.
- 어떻게 동작할까요?
	- 메시지 브로커나 이벤트 큐는 이벤트들을 나누고 하위 스트림으로 나누며 이벤트들을 저장해서 단일 스트림으로 다시 합칠때까지 보관할수 있다.
- 어떻게 사용할 수 있나요?
	- 스트림 처리 어플리케이션의 확장
	- 스트림 처리 분할
- 고려해야 할 사항들
	- 이벤트를 여러 하위 스트림으로 나누면 각각의 하위 스트림은 서로다른 클라우드 네이티브 어플리케이션을 통해 처리할 수 있으며 그 과 정에서 이벤트가 걸러지고 삭제된다.
	- 이벤트가 연속적이지 않게 된다.
	- 이벤트를 합칠때는 순차 이벤트가 끝났다는 메시지를 보낸다.
	- 스트림 처리 마이크로 서비스들이 병목 지점이 된다면 스트림의 수를 확장훌 수 있도록 설계하는 것이 좋다.

### 6.4.2. 버퍼 이벤트 순차 정렬 패턴
-  어떻게 동작할까요?
	- 이벤트에 순차 증가하는 값을 기록한다.
	- 이벤트를 시각 기준으로 정렬한다면 이런 최적화는 어렵다.
	- K-slack, AQ-K slack
		- https://github.com/siddhi-io/siddhi-execution-reorder
- 어떻게 사용할수 있나요?
	- 분산 생성된 이벤트들 순차 정렬
	- 같은 원천에서 생성한 이벤트들을 재정렬
- 고려해야 할 사항들
	- 어그리게이션이나 이벤트의 순번을 탐지해야할때 좋음
	- 시스템의 병목이 될수 있다.
	- 단일원천 이벤트일 경우 높은 정확도로 재정렬 가능

### 6.4.3. 오류 수정 패턴
- 빠진 메시지나 이벤트가 뒤늦게 도착하면 이를 토대로 분석 내용을 수정하고 다시 알려준다.
- 어떻게 동작할까요?
	- 보든 이벤트가 순서대로 도착할 때까지 기다리기보다는 어그리게이션이나 이벤트 순서 탐지를 이벤트가 도착하는 대로 처리해서 결과를 만든다.
	- 나중에 빠진 이벤트를 채원 헌는다. 순간적으로 정확하지 않을수 있지만, 나중에 정확한 내용으로 정정된다.
- 어떻게 사용할 수 있나요?
	- 결과를 최신 정보로 업데이트하기
	- 이전에 만든 의사 결정 데이터 수정
- 고려해야할 사항들
	- 초기에 빠르게 만든 데이터를 유용하게 사용할수 있으며
	- 정정된 데이터도 유용하고, 수정가능해야한다.
	- 만약 데이터가 오류 수정을 지원하지 않으면 버퍼 이벤트 순차 정렬 패턴과 같이 지연시킬수 밖에 없다.
	- 대부분은 버퍼링하게 되면 메모리에 저장되게 되기 때문에 얼마나 기다릴지를 균형점을 찾아야한다.
	- 오류 수정은 이전 결과나 내보낸 데이터를 기억해야하기 때문에 신뢰성 패턴을 지원해야한다.

### 6.4.4. 워터마크 패턴
- 어떻게 동작할까요?
	- 워터마크 생성기가 주기적으로 워터마크 이벤트를 생성해서 이를 특수하게 처리한다.
	- 이런 워터마크를 받으면 워터마크에 연결된 이벤트들을 처리하게 된다. 이는 결국 순번을 처리할수 있게 한다.
- 어떻게 사용할 수 있나요?
	- 시간 기반 동기화된 여러 이벤트 소스로부터 생성된 이벤트들 동기화
	- 동기화되지 않은 입력 소스로부터 생성된 이벤트들 동기화하기
- 고려해야할 사항들
	- 네트워크 지연 등으로 이벤트 도착시각이 생성시각과 큰 차이가 발생할것이라는 것을 알때
	- 입력 시스템 들이 시간 동기화가 맞지 않는 상황
	- 여러 스트림간 발생할수 있는 시간 동기화문제만 해결할수 있다. 언제나 모든상황에서 더 정확하다고 봊아할수 없다.
	- 복잡도를 높이기 때문에 반드시 필요할때만 사용해야한다.
	- 가능하다면 큐가 지원할때만 사용해야한다. Apache Flink 는 지원한다.

### 6.4.5. 확장성 및 성능 최적화 패턴 정리


| 패턴           | 사용하면 좋은 경우                                                                                                     | 사용해서는 안되는 경우                                                                                                       | 이점                                                                               |
| ------------ | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| 순차 수송        | - 스트림 프로세싱 어플리케이션의 확장성이 필요한 경우<br>- 스트림을 분할해서 각 스트림을 서로 다른 방식으로 처리해야 하는 경우<br>이벤트들을 병렬로 처리한 다음 원래 순서로 합쳐야하는 경우 | - 스트림 처리 어플리케이션이 전체 이벤트를 처리할 수 있는 충분한 능력이 있는 경우                                                                    | - 스트림 처리 어플리케이션의 확장성을 제공<br>이벤트를 병렬로 처리한 경우 이벤트를 원래 순서로 합칠 수 있음                  |
| 버퍼 이벤트 순차 정렬 | - 이벤트를 순번 또는 생성 시각 기준으로 정렬해야하는 경우<br>- 순서에 맞지 않는 이벤트들을 정렬해서 합치고 하나의 이벤트 스트림으로 만들어야 하는 경우                       | - 이미 정렬된 여러 이벤트 스트림을 다시 합쳐야하는 경우<br>- 분산된 소스로부터 생성된 이벤트들의 실제 순서를 알아야하는 경우<br>- 어플리케이션에서 신뢰성 패턴을 사용할 수 없는 경우        | - 이벤트를 순서대로 정렬해야 하는 모든 어플리케이션 앞에 적용할 수 있음                                        |
| 오류 수정        | - 이전에 생성한 결과를 수정해야 하는 경우<br>- 어그리게이션 추정치를 더 빨리 만들어야하는 경우<br>- 이벤트 순서를 추정해서 먼저 처리한 다음 나중에 이 내용을 수정해야 하는 경우      | - 출력 이벤트를 사용하는 다운 스트림이 지속적인 이벤트 변경을 처리할 수 없는 경우                                                                    | - 추정치를 더 빠르게 만들고 데이터가 더 많아지면 이 추정치를 수정할 수 있음                                     |
| 워터마크         | - 동기화가 맞지 않는 이벤트 스트림들에 대한 어그리게이션 작업을 처리해야 하는 경우<br>- 분산 시스템에서 생성된 이벤트들의 순서를 정렬해야 하는 경우                         | - 이베트 소스 또는 그와 가까운 시스템이 워터마크 이벤트를 생성해서 넣을 수 없는 경우<br>- 중간 시스템이 워터마크 이벤트를 그대로 전달할 수 없는 경우<br>- 네트워크 대역폭이 중요한 자원인 경우 | - 여러 스트림 간 이벤트들을 주기적으로 동기화할 수 있음<br>- 네트워크 또는 중간 시스템의 이벤트 처리로 인한 지연 문제를 해결할 수 있음 |
## 6.5. 신뢰성 패턴
### 6.5.1. 재생 패턴
- 어떻게 동작할까요?
	- 시스템이 동작을 멈춘 경우, 이전의 이벤트들을 다시 보낸다.
	- 시스템의 상태를 다시 만들려면 데이터를 만들어내는 시스템은 다시 이벤트를 만들수 있게 저장하고 있어야한다.
	- Kafka NATS 와 같이 이벤트를 전달해도 이벤트를 삭ㄱ제하지 않는 로그 기반 메시지 브로커를 사용해서 달성할수 있다.
	- 아니면 메시지 브로커의 도움 없이 별도의 DB에 저장해두고 어디까지 처리했는지 이벤트 순번을 가져와서 할수 있다.
- 어떻게 사용할 수 있나요?
	- 시스템 상태가 저장되지 않은 상태에서 이벤트를 재생하고 복구
	- 시스템이 상태를 저장하는 상황에서 이벤트를 재생하고 상태를 복구
- 고려해야할 사항들
	- 이벤트를 중복처리하게 될수 있다.
	- 이벤트가 유실될수 있으니 유실되지 않는 것을 명확하게 보장해주어야 한다.


### 6.5.2. 주기적 상태 스냅숏 저장 패턴
- 이벤트를 처리할때마다 상태를 저장하는건 현실적이지 않다.
- 주기적으로 상태를 저장해서 복구 가능하게 한다.
- 어떻게 동작할까요?
	- 주기적으로 현재 상태에 대한 사본을 만든다.
	- ActivMQ 와 같은 표준 브로커를 사용할 경우 상태 스냅숏을 저장한 다음 메시지 브로커에 처리 상황에 대한 응답을 보내야만 한다.
	- 최소 1번 전달을 보장할수 있다.
- 어떻게 사용할 수 있나요?
	- 장애를 복구할때 스냅숏을 가져온다음 스냅숏을 기준으로 이후의 이벤트들을 처리하면 된다.
		- 이전의 이벤트들은 버리면 된다.
- 고려해야할 사항들
	- 시스템 장애 상황에서도 절대 유실해서는 안되는 주용한 데이터를 처리하는 경우에만 이 패턴을 적용한다.
	- 현실적으로 이벤트량이 너무 많으면 안된다. 적당한 간격을 조절해야한다.
	- 상태 스냅숏을 만들고 스토어에 저장할 때는 쓰레드나 그와 비슷한 기술을 사용해서 이벤트를 처리하는 작업을 중단하지 않고 비동기 처리해야한다.
	- 상태 스냅숏의 주기가 짧다고 해서 크게 이득을 보는건 아니다.

### 6.5.3. 이중화 노드 장애 극복 기능 패턴
- 어떻게 동작할까요
	- 백업 마이크로서비스를 병렬로 실행한다.
	- 주 서비스가 동작을 중지하면 부 서비스가 주 서비스로 승격되고 이벤트 처리 결과를 종속 시스템으로 전달한다.
	- 시간이 지나고 재시작한 부 서비스의 상태는 주 서비스의 상태와 똑같아지며 다시 장애가 발생하였을 때 주 서비스가 될 수 있는 요건을 갖춘다.
- 어떻게 사용할 수 있나요?
	- 시스템 장애로 인한 운용 중단 시간이나  지연 시간의 증가가 문제가 될 때 사용하면 좋다.
- 고려해야 할 사항들
	- 낮은 지연 시간이 어플리케이션의 주요 요구사항일 경우에만 이 패턴을 사용해야한다.
	- 주 서비스와 부 서비스 간 네트워크 단절이 발생할 경우 출력 결과를 전달할 수 없다는 위험성이 있다.
	- 제 3의 시스템을 도입해서 리더를 선출하고 관리할 수 있어야한다.
	- 양쪽 마이크로서비스가 동시에 동작을 멈출수도 있다는걸 유념해야한다.

### 6.5.4. 신뢰성 패턴 정리

| 패턴             | 사용하면 좋은 경우                                                                                                                   | 사용해서는 안 되는 경우                                                                                                                                          | 이점                                                                                              |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
| 재생             | - 시스템 상태가 최근 이벤트에 의해 결정되는 경우<br>- 이전에 처리한 이벤트에 접근해서 상태 복구가 가능한 경우<br>- 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우           | - 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>- 종속 시스템이 중복 이벤트를 처리할 수 없는 경우<br>- 시스템이 상태 복구에 시간이 소요되어서는 안 되는 경우<br>- 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정되는 경우 | - 대량의 스냅숏을 저장하지 않고도 상태를 복구할 수 있음                                                                |
| 주기적 상태 스냅숏 저장  | - 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정되는 경우<br>- 이전에 처리한 이벤트에 접근해서 상태 복구가 가능한 경우<br>- 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우 | - 시스템 상태가 최근 처리한 이벤트에만 영향을 받는 경우<br>- 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>- 시스템의 상태 복구에 시간이 소요되어서는 안되는 경우                                         | - 상태를 더 빠르게 복구할 수 있음<br>- 더 긴, 더 큰 장애의 경우에도 시스템 복구가 가능함<br>- 종속 어플리케이션이 중복 이벤트를 처리하지 않도록 할 수 있음 |
| 다중 노드 장애 극복 기능 | - 어플리케이션 상태 복구에 시간이 걸려서는 안되는 경우<br>- 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정 되는 경우<br>- 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우  | - 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>- 시스템 상태 복구에 시간이 소요되어도 문제가 없는 경우                                                                            | - 저 지연, 고가용성 어플리케이션을 구현할 수 있음<br>- 종속 어플리케이션이 중복 이벤트를 처리하지 않도록 할 수 있음                           |

## 6.6. 사용 기술
- 스트림 처리는 마이크로서비스 형태로 설계할수도 있고, 스트림 프로세싱 시스템을 사용하는 형태로 배포할수도 있다.
- CEP 엔진: Complex Event Processing Engine
### 6.6.1. 에스퍼

### 6.6.2. Siddhi
- 좀 찾아보니까 uber 에서 쓰려고 한듯
	- https://medium.com/garantibbva-teknoloji/using-siddhi-as-cep-engine-5bea80ebde3d

### 6.6.3. ksqlDB
- 카프카의 일부로서 제공됨

### 6.6.4. Apache Spark
- 배치 작업에서 강점을 보인다.
- Mesos, Yarn, K8s 에서 동작한다.

### 6.6.5. Apache Flink
- 변환, 필터링, 한계값, 윈도우드 어그리게이션, 조인, 임시 이벤트 순차 정렬, 그래프 프로세싱 같은 다양한 스트리밍 프로세싱을 지원한다.

### 6.6.6. Amazon Kinesis

### 6.6.7. Azure Stream Analytics

### 6.6.8. Google Dataflow
- Apache Beam SDK 나 SQL 질의, GUI 를 통해 스트림 프로세싱 로직을 정의할수 있다.

### 6.6.9. 스트림 프로세싱 기술 정리

| 스트림-프로세싱 기술  | 사용하면 좋은 경우                                                                                                                                      | 사용해서는 안 되는 경우                                                                                               |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 에스퍼          | - 클라우드 네이티브 어플리케이션에 스트리밍 프로세싱 로직을 내장할 경우<br>- 변환, 필터와 한계값, 윈도우드 어그리게이션, 조인, 임시 이벤트 순차 정렬 패턴을 사용하는 경우                                            | - 독립적인 어플리케이션으로 사용해야 할 경우<br>- 머신러닝 모델을 사용하는 경우<br>- 내장 신뢰성 기능이 필요한 경우                                      |
| Siddhi       | - 클라우드 네이티브 어플리케이션에 스트림 프로세싱 로직을 내장할 경우<br>- 독립적인 클라우드 네이티브 어플리케이션 형태로 사용할 경우<br>- 변환, 필터와 한계값, 윈도우드 어그리게이션, 조인, 임시 이벤트 순차 정렬, 머신러닝 패턴을 사용하는 경우 | - 높은 확장성이 요구되는 경우                                                                                           |
| ksqlDB       | - 인프라스트럭쳐에서 카프카를 사용하는 경우<br>- 변환, 필터와 한계값, 윈도우드 어그리게이션, 조인 패턴을 사용하는 경우<br>- 입력 이벤트에 대해 구체화된 뷰 패턴을 적용해야 하는 경우                                    | - 인프라스트럭쳐에서 카프카를 사용하지 않는 경우<br>- 임시 이벤트 순차 정렬 또는 머신러닝 패턴을 사용해야 하는 경우                                        |
| 아파치 스파크      | - 스트림 및 배치 프로세싱 둘 다 필요한 경우<br>- 변환, 필터와 한계값, 윈도우드 어그리게이션, 조인, 머신러닝 패턴을 사용하는 경우                                                                  | - 스트림 프로세싱에 가벼운 시스템을 사용해야 하는 경우<br>- 임시 이벤트 순차 정렬 패턴이 필요한 경우<br>- 클라우드 네이티브 어플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우 |
| 아파트 플링크      | - 변환, 필터와 한계값, 윈도우드 어그리게이션, 조인, 임시 이벤트 순차 정렬, 그래프 프로세싱이 필요한 경우<br>- 높은 확장성과 고가용성이 필요한 경우                                                        | - 스트림 프로세싱에 가벼운 시스템을 사용해야 하는 경우<br>- 클라우드 네이티브 어플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우                              |
| 아마존 키네시스     | - AWS 에서 Flink를 사용하는 경우                                                                                                                         |                                                                                                             |
| 에저 스트림 애널리틱스 |                                                                                                                                                 |                                                                                                             |
| 구글 데이터플로     |                                                                                                                                                 |                                                                                                             |

## 6.7. 테스팅
- 전통적인 유닛테스트 및 통합 테스트 코드를 작성해야한다.
- 어플리케이션 상태를 어떻게 다룰것인가
	- 신뢰성 패턴을 사용한다면 이벤트 처리 결과를 올바르게 잘 만드는지 테스트 해야한다.
	- 워터마크 패턴을 사용해서 테스트 마지막에 워터마크를 발행해서 이벤트 처리를 제대로 끝냈다는 것을 인식하면 된다.
- 윈도우드 어그리게이션이나 임시 순차 정렬 패턴과 같이 시간 제한이 있다면, test가 flaky 해진다. flaky 해지는걸 막기 위해서 오차범위를 만들고, 이벤트 생성 시간을 기준으로 처리하도록 만드는게 좋다.

## 6.8. 보안
- 메시지 브로커를 안전하게 만드는게 중요하다.

## 6.9. 관측 가능성 및 모니터링
- 적절한 모니터링이 없으면 장애때까지 문제를 발견 못한다.
- 메모리 소비를 반드시 모니터링 한다.
- 주기적 스냅샷을 가지고 이를 모니터링 해서 확인한다.

## 6.10. 데브옵스
- 스냅샷의 크기와 저장 빈도를 잘 정해야한다.
- 스냅샷은 암호화 하고 정보 보호를 하는게 중요하다.
- 이벤트 스키마와 스냅숏에 하위 호환성을 유지하는게 중요하다.
