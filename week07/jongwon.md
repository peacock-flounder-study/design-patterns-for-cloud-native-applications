## 6.1 스트림이란?
- 이벤트 주도 아키텍처 패턴에서 발전한 형태
- 이벤트를 그때그때 분석해서 의미있는 정보를 추출하고 실시간으로 작업을 처리하는 데 중점
- 이벤트 주도 아키텍처 패턴이 없다면 스트림 처리 패턴도 구현할 수 없음

- 스트림이란 시간 순서에 따라 정렬된 일련의 연속적인 이벤트
- 각 스트림들은 서로를 고유하게 구분할 수 있는 이름, 버전으로 구성된 식별자를 가짐. `StockStream 1.0`
- 스트림의 모든 이벤트는 같은 메시지 포맷과 구조를 지님
- 스트림 버전을 통해 안전하게 스트림 구조를 변경하고 시간이 지남에 따라 스트림을 조금씩 발전시킬 수 있음

## 6.2 스트림 프로세싱이란?
- 스트림 프로세싱이란 연속적인 이벤트들에 작업을 수행하는 것
- 간단하게는 이벤트를 소비해서 다른 이벤트 포맷으로 변환하는 무상태 서비스부터 낮은 지연 시간과 높은 신뢰성을 보장하기 위해 메모리에 상태 데이터를 저장하고 처리하는 복잡한 서비스
- 스트림 프로세싱은 이벤트 생성 순서대로 처리. 이전 이벤트를 기억하고 의사결정에 이를 활용하기도 함

- 스트림 프로세싱 애플리케이션 만들 때는 애플리케이션의 무상태나 상태 특성이 설계에 아주 큰 영향을 미침
- 따라서 상태 관리를 위해 다른 유형의 패턴을 사용

## 6.3 스트리밍 데이터 프로세싱 패턴
- 실시간 이벤트 변환이나 필터링, 애그리게이션, 의미있는 연속적인 이벤트 탐지 등을 통해 의미있는 결과 도출하는 데 중점을 둔다
- 이런 기능을 통해 이벤트를 그때그때 빠르게 처리 가능

- 성능 고려할 때 가장 중요한 점 중 하나는 영구 데이터스토어를 많이 쓰지 말 것
- 데이터 스토어에 접근하기 위해 소요되는 시간과 이때 발생할 수 있는 잠재적인 경합으로 인해 처리 지연 시간에 엄청난 영향이 발생할 수도 있음
- 물론 경우에 따라 영구 데이터 스토어를 사용해야 할 수도 있지만, 경험의 법칙(rule of thumb)에 따르면 사용하지 않는 게 좋다

### 6.3.1 변환 패턴
- transformation pattern은 이벤트 소스의 이벤트를 변환해서 다른 포맷이나 구조, 프로토콜을 사용하는 다른 시스템에 발행

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115170628.png)

- 이벤트를 다른 이벤트로 변환
- 이런 변환은 이벤트 정보만 가지고 하는 경우가 대부분
- 경우에 따라 윈도우드 애그리게이션이나 다른 유형 패턴을 쓰기도 함
#### 어떻게 사용할 수 있나요
- 아무 언어나 구현
- 서비스 버스, 스트림 프로세서와 같은 시스템에도 적용
#### 메시지 변환
- 전통적인 프로그래밍 언어 or 데이터 매핑을 수행하는 전용 애플리케이션으로
- Apache Camel, KSQL, 아마존 키네시스, 애저 스트림 애널리틱스

- 프로토콜 전환
    - 서로 다른 브로커를 쓰면 호환이 안 될 수 있음
    - AMQP -> Kafka 등의 직렬화 등도 할 때도 있음

#### 고려해야 할 사항들
- 서로 다른 팀과 함께 애플리케이션 만들거나, 서드파티 애플리케이션 사용할 때, 애플리케이션의 이벤트 변환할 때 사용
- 무상태 변환은 쉽게 확장 가능
- 상태 저장 및 관리가 필요한 경우 쉽게 수평 확장이 어려움
    - 순차 수송 패턴으로 애플리케이션을 나누고 확장 가능
### 6.3.2 필터와 한계값 패턴
- 조건으로 거르거나 한계값 이내의 값을 가진 이벤트만 허용
- filters and thresholds pattern
#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115174038.png)
- 이벤트를 걸러낼 수 있는 조건 제공
- 하나 이상 조건을 사용하기도 함

#### 어떻게 사용할 수 있나요
- 분류별로 이벤트 걸러내기
    - 특정 유형의 이벤트만 처리
    - 구독 필터를 쓸 수도 있지만 이럴 수 없는 경우 중간에 뭔가를 두고 이벤트를 걸러내고 관련 이벤트만 발행되도록 함
- 시나리오: 경고를 위한 한계 값 적용
    - 모든 이벤트를 다 처리하는 건 자원 문제가 있음
    - 한계값을 기준으로 아주 중요한 데이터만 걸러내서 처리
    - 은행의 경우 금액이 큰 트랜잭션만 검사
#### 고려해야 할 사항들
- 카프카와 같은 최신 메시지 브로커는 이런 필터 기능을 제공해서 토픽을 구독할 때 필터 조건을 지정 가능
    - -> 카프카에 이런 기능이 있나요? 검색했는데도 못 찾았음
- 따라서 별도 컨테이너로 걸러낼 필요가 없음
- 서드파티 시스템에 발행하는 경우 별도 필터링 구현이 필요할 수 있음

#### 관련 패턴들
- 다른 거랑 같이 쓴다~

### 6.3.3 윈도우드 애그리게이션 패턴
- windowed aggregation pattern
- 조건에 따른 이벤트 집합을 분석
- 총합, 최솟값, 최댓값, 평균값, 표준 편차, 개수 등

- 윈도우는 시간 또는 이벤트 개수로 지정
- 슬라이딩 또는 배칭으로 동작하면서 윈도우에 이벤트를 어떻게 더하고 제거할지 결정
- 이 패턴은 데이털르 그때그때 애그리게이션 하면서 시간이 촉박한 비즈니스 결정사항을 수초 이내에 만들어야 할 때 유용하게 사용
#### 어떻게 동작할까요
- 애그리게이션 작업은 윈도우 안에서 수행되어, 애그리게이션에 사용될 이벤트 수는 윈도우에 의해 제한된다
- 애그리게이션 결과는 추가 처리 작업을 위해 다시 스트림 형태로 내보낸다.

- 윈도우에는 이벤트가 추가되거나 제거됨
- 윈도우는 이벤트가 추가되거나 제거될 때마다 윈도우 내의 모든 이벤트에 대한 애그리게이션 결과를 내보냄
- 구현 최적화를 위해 이벤트를 도착할 때마다 이벤트를 추가하지 않고, 슬라이딩 간격을 지정ㅈ해서 윈도우가 얼마나 자주 움직일지 정의할 수도 있음
- 이렇게 하면 1분 단위로 움직이는 슬라이딩 윈도우에 1초 간격의 슬라이딩 인터벌을 지정해서 1초마다 윈도우가 움직이도록 할 수 있음
- 움직일 때 이벤트를 더하고 뺌 -> 애그리게이션 결과도 초 단위로 나온다.

![](files/Pasted%20image%2020251115201724.png)

- 애그리게이션 결과가 나오는 시점은 윈도우 유형에 따라 다름
- 10 사이즈 배치 윈도우는 매 10개의 이벤트마다 나옴
- 5분 단위로 1초마다 움직이는 윈도우는 매초 마다 나옴

- `group by`, `having`, `order by`, `limit` 등의 연산자로 애그리게이션 결과를 필드 단위로 묶거나 필터, 정렬, 결과 수 제한도 가능

#### 어떻게 사용할 수 있나요
- 상태를 사용한다
- 모니터링 등 데이터가 일부 유실되어도 관계없는 경우 아무 클라우드 네이티브 애플리케이션에 이 패턴 적용해도 상관없음
- 그러나 신뢰성이 중요하면 신뢰성 패턴과 함께 사용

- 시간에 따른 이벤트 종합
    - 시간 간격 별로 이벤트를 모아야 할 때 사용
    - 최근 10분 동안 발생한 트랜잭션 금액 합계를 구해서 상위 10명의 금액 사용자를 알아내기

```sql
select userName, sum(transactionValue) as totalTransaction 
from InputStream 
window time (10 min, 1 sec) 
group by userName 
order by totalTransaction desc 
limit 10
```

- 길이별로 구간을 나누고 이벤트 종합
    - 어떤 경우에는 이벤트 개수가 이벤트 종합에 중요한 기준
    - 서버 측에서 세 번 연속 요청이 거부되면 경고한다 -> 시간으로 판단 불가능
    - 아래 질의는 모든 이벤트가 단일 서버에서 생성되었다고 가정
    - 그렇지 않은 경우 순차 수송 패턴 등을 사용해서 질의를 나누고 여러 서버에서 실행되도록 해야함
    - 신뢰성이 크게 필요하지 않다면 윈도우 상태를 저장할 필요는 없고, 신뢰할 수 있는 패턴을 사용하지 않아도 무방하다
```sql
select serverId, sum(isRequestRejected) as totalRejectedRequests 
from InputStream 
window length (3) 
having totalRejectedRequests == 3
```

#### 고려해야 할 사항들
- 상태를 가진다
- 따라서 시스템 장애 또는 재시작으로 유실이 발생하면 애그리게이션 결과의 무결성을 보장할 수 없다
- 결과가 아주 중요하지 않다면 큰 문제가 되지 않는다
- 그러나 아주 중요하다면 신뢰성 패턴과 함께 상태 복구 방법이 필요

- 높은 정확도와 효율성을 만족하는 모든 종류의 애그리게이션을 만드는 것도 불가능
- 평균을 구하는 윈도우는 만들 수 있지만 중앙값을 만드는 윈도우는 그럴 수 없다
- 평균 값은 윈도우 내 이벤트 합, 개수만 알면 되지만 중간값은 모든 이벤트를 알아야만 한다.

![](files/Pasted%20image%2020251115202348.png)

- 윈도우란 이벤트 집합이므로 확장성은 샤딩을 통해 이벤트를 나눔으로써 효과적으로 구현 가능

- 물론 윈도우 없이 애그리게이션 구현도 가능
- 윈도우 크기가 시작 시점부터 지금까지인
- 단, 공간 복잡도 제한으로 언젠간 한계가 온다.

- 이를 바닥부터 혼자 구현하는 건 시간도 오래 걸리고 오류도 많다
- Esper, Siddhi 등의 라이브러리나 스트림 처리 프로세서 쓰는 게 좋다

#### 관련 패턴들
- 변환 패턴
    - 다른 데이터 포맷으로 바꿀 때
- 신뢰성 패턴
    - 시스템 장애 상태에서도 윈도우 및 애그리게이션 상태를 저장하고 복구
- 순차 수송 패턴
    - 샤드 키 기반으로 나누고 병렬 처리
    - 확장하고, 서로 다른 유형의 이벤트를 독립적으로 애그리게이션하고, 이벤트 유형별 애그리게이션 결과 만들기
- 서비스 오케스트레이션 패턴
    - 샤드 키 기반으로 나눠서 처리
- 스트림 조인 패턴
    - 다른 샤드에서의 애그리게이션 결과 합치기

### 6.3.4 스트림 조인 패턴
- stream join pattern

#### 어떻게 동작할까요
- SQL 조인처럼 서로 다른 스키마를 가지는 여러 이벤트 합치기
- 간단한 비교 연산자 써서 같은 ID 값 가지는 이벤트를 합치거나, 더 복잡한 조건 사용

-  다른 이벤트 스트림으로부터 관련 이벤트가 도착할 때까지 얼마나 많이 기다릴지를 결정하는 버퍼를 정의
- 대부분의 스트림 프로세싱 시스템은 이전에 배운 윈도우로 버퍼 간격을 정의

![](files/Pasted%20image%2020251115202830.png)

- 변환 패턴을 사용해서 합친 이벤트들의 속성 값 또는 데이터를 다른 포맷으로 변환하기도 한다.

#### 어떻게 사용할 수 있나요
- 버퍼에 합칠 이벤트들을 저장해놓으므로 상태를 가짐
- 유실이 문제없다면 아무렇게나 사용 가능
- 그러나 이벤트 유실이 발생하면 안 되는 경우 항상 신뢰성 패턴과 함께 사용해서 시스템 장애나 재시작의 경우에도 유실되지 않도록 하기

- 확산 및 조합
    - 같은 이벤트에 동시에 서로 다른 작업을 수행하고, 그 결과를 조합함으로써 모든 이벤트를 단일 이벤트처럼 만들 수 있다.
    - 대출 이벤트가 있고, 신용도 검사, 주소 검사, 신원정보 조회 등을 해야함
    - 병렬로 할 수 있지만 승인하기 위해선 세 가지 결과가 모두 필요
    - 결과로 나오는 데이터는 모두 대출 ID를 가지고 있으므로 해당 ID를 가진 이벤트를 하나로 합칠 수 있음
    - 결과가 일단 나와야하므로 결과에 성공 실패 여부가 담겨야하고, 오류나 네트워크 문제로 이벤트를 보내지 않는 경우도 처리할 수 있는 방법 마련해야 함
    - 버퍼 간격을 정의해서 유실된 이벤트를 찾고 결과를 버리거나, 가능하다면 부분 결과만 가지고 의사 결정 데이터 만들기
    - 위 케이스는 승인을 거절하거나 데이터를 다시 처리하도록 요청하거나
- 여러 종류의 이벤트 조인
    - 주가 정보를 저장하고, 트윗에 회사 이름이 올라오면 주가 이벤트랑 합쳐서 처리하는 등 여러 종류의 이벤트를 조인 가능
    - inner join, left outer, full outer 등의 조인 가능
    - outer join은 이벤트를 찾을 수 없으면 이벤트 속성을 null로 대체

![](files/Pasted%20image%2020251115204437.png)
#### 고려해야 할 사항들
- 상태 관리가 필요
- 조인 작업을 제대로 수행하려면 반드시 필요한 이벤트가 도착할 때까지 기다려야 함
- 이벤트가 유실되거나 안 되는 경우 반드시 신뢰성 패턴을 함께 사용해서 시스템에 장애가 발생하거나 재시작하는 경우에도 이벤트를 저장하고 사용할 수 있게
- 단, 확산과 조합 같이 단순한 사용의 경우 브로커에서 이벤트를 바로 읽어와서 이벤트를 성공적으로 조합할 때까지 응답을 미룰 수 있다
- 이런 방법을 사용하면 필요할 때 이벤트를 가져오면 되므로 시스템 장애나 재시작의 경우에도 이벤트 유실이 발생하지 않음

- 아주 긴 시간 동안 여러 이벤트를 합치는 건 상당히 어렵다
- 기간이 길어질수록 요구하는 저장 공간 크기와 처리 시간이 길어진다
- 이 때는 순차 수송 패턴 사용해서 이벤트들을 조합할 속성에 따라 샤드로 나누고 처리하는 게 좋다
- 조인 연산을 병렬로 처리할 수 있고, 관련 이벤트들이 같은 샤드에 저장될 것임을 보장하기 때문에 성공적으로 조인 연산 수행 가능

#### 관련 패턴들
- 변환 패턴
    - 결과 이벤트를 만들기 위해 여러 이벤트 속성을 사용하고 반환
- 신뢰성 패턴
    - 시스템 장애 상황에서도 상태 저장하고 관리
- 순차 수송 패턴
    - 관련 이벤트를 같은 샤드 단위로 나눠서 처리해 조인 연산을 확장

### 6.3.5 임시적인 이벤트 정렬 패턴
- temporal event ordering pattern
- 스트림 프로세싱 분야에서만 사용하는 패턴
- 이벤트 도착 순서대로 패턴을 분석하고 이벤트 발생 여부를 탐지
- 다양한 시스템에서 발생하는 이벤트를 가지고 특정 이벤트가 발생했는지 여부를 파악할 때도 이 패턴을 사용

#### 어떻게 동작할까요
- 비결정적 유한 상태 기계처럼 동작
- 상태가 입력되는 이벤트와 현재 상태에 따라 바뀐다
- 상태 변화는 상태 그래프로 표현할 수 있고 상태 변화는 성공 또는 실패 상태에 도달할 때까지 계속된다
- 성공 상태에 도달하면 사용자에게 기대하던 이벤트가 순서대로 발생했음을 알린다

![](files/Pasted%20image%2020251115205008.png)

- 이 패턴을 사용해서 이벤트가 다른 이벤트 뒤에 순서대로 나타나는지, 다른 이벤트들 사이에 무작위로 나타내는지 등도 탐지 가능
- 상태 변화와 타임 아웃을 함께 사용해서 이벤트가 발생하지 않았는지도 탐지 가능

- 위에서 설명한 주가 모니터링은 이벤트 발생 순서를 반복해서 탐지 필요
- 매 이벤트 도착 시마다 새로운 상태 기계를 새로 만들고, 초기 상태부터 시작
#### 어떻게 사용할 수 있나요
- 신뢰성 패턴과 함께 데이터 유실 방지 간으
- 도착 순서가 아주 중요해 버퍼를 이용한 이벤트 정렬을 같이 사용해서 이벤트를 처리하기 전 순서대로 도착하도록 만드는 게 좋다

- 이벤트 순차 발생 탐지
    - 미리 정의한 순서대로 이벤트 발생 탐지
    - 미국 내에서 트랜잭션이 발생하고 세 시간 이내에 미국 외의 지역에서 트랜잭션 발생 등

![](files/Pasted%20image%2020251115205210.png)

- 이벤트가 발생하지 않음을 탐지
    - 기대하던 이벤트가 발생하지 않는 경우를 탐지
    - 이런 경우 타이머가 필요

![](files/Pasted%20image%2020251115205203.png)

#### 고려해야 할 사항들
- 신뢰성 패턴을 통해 시스템 장애나 재시작 상황에서도 상태 저장 및 관리가 필요
- 상태 기계를 관리할 수 있도록 충분한 메모리 공간 필요
- 순차 수송 패턴으로 이벤트를 여러 노드에 분산하고 확장해서 병렬로 처리
- 물론 관련 이벤트들이 같은 노드로 분산된다는 것을 보장해야 병렬 처리가 가능

- 또 다른 점은 이벤트가 생성된 순서대로 전달되어야한다는 것
- 이벤트의 상대적인 순서를 항상 알아낼 수는 없기에 이벤트가 생성된 시간을 기록하고 이를 토대로 이벤트를 재배치할 수 있다면 어긋난 순서를 바로잡을 수 있다

- 이 또한 바닥부터 구현하기 보다는 다른 기능을 사용
    - 애저 스트리밍 애널리틱스, 아파치 스파크, 아파치 플링크, 에스퍼, Siddhi 등

#### 관련 패턴들
- 변환 패턴
    - 일련의 이벤트들을 가지고 의미있는 데이터 만들 때
- 신뢰성 패턴
    - 장애 대비
- 순차 수송 패턴
    - 연관 이벤트를 동일한 샤드로 재분배해 병렬 처리
- 버퍼를 이용한 이벤트 정렬 패턴
    - 이 패턴이 올바르게 동작하도록 생성 시간 기준으로 정렬

### 6.3.6 머신 러너 패턴
- 데이터를 통한 실시간 예측, 자동화된 의사 결정에 머신러닝 모델을 사용
- 온라인 머신러닝 모델은 미리 생성하지 않고 예측과 동시에 새로운 이벤트를 통한 지속적인 학습을 통해 클라우드 네이티브 애플리케이션을 더 똑똑하게 만들 수 있다.

#### 어떻게 동작할까요
- 예측 모델을 두 가지 방법으로 만들 수 있다
- 미리 정의한 모델 사용 vs 온라인 머신러닝 모델 사용

- 미리 정의된 머신러닝 모델
    - PMML(Predictive Model Markup Language)와 같은 기술로 미리 정의된 모델을 불러와서 사용
    - 별도 클라우드 네이티브 애플리케이션을 만들고 실행해서 API로 호출하기도 함
    - 미리 정의되어있으므로 예측 정확성을 향상시키려면 주기적으로 성능 향상시키고 변경한 모델을 적용해줘야 함
- 온라인 머신러닝 모델
    - 어떤 모델은 예측을 위해 주어지는 정보 자체를 토대로 모델 스스로 향상
    - 이전 예측 결과를 스스로 피드백함으로써 스스로 학습
    - 이런 모델들 역시 애플리케이션에 내장할 수도, 별도의 마이크로서비스로 만들 수도 있음

![](files/Pasted%20image%2020251115214043.png)

#### 어떻게 사용할 수 있나요
- 하나는 별도의 마이크로서비스로 배포하고 서비스를 호출
- 다른 서비스 호출과 큰 차이 없음
- 애플리케이션에 머신러닝 모델을 내장하는 것도 하나의 방법

- 미리 정의한 머신러닝 모델로 결과 예측하기
    - 과거 데이터가 아주 풍부하고, 따라서 새로운 이벤트로 인한 머신러닝 모델이 변경되는 경우가 없는 경우 사용하기 좋음

![](files/Pasted%20image%2020251115214151.png)

- 데이터를 통한 지속적인 학습 모델
    - 과거에 축적된 데이터보다 앞으로 얻게 될 데이터가 훨씬 더 많은 경우 지속적으로 학습할 수 있는 온라인 모델을 쓰는 게 좋다
    - 혹은 같은 데이터여도 다른 조건에 의해 예측이 달라질 수 있는 경우 지속적으로 모델 수정하는 게 좋음

![](files/Pasted%20image%2020251115214239.png)

#### 고려해야 할 사항들
- 미리 정의한 모델은 구현도 쉽고 데이터만 충분하면 높은 정확도를 보인다
- 물론 데이터의 새로운 경향을 반영하지는 못한다
- 새로운 데이터를 반영하고 싶다면 온라인 머신러닝 알고리즘이 더 좋음
- 단, 온라인 모델은 정확도가 들쭉날쭉 할 수 있음
- 가능하면 미리 정의한 머신러닝 모델과 온라인 머신러닝 모델을 함께 사용하는 게 좋음
    - 온라인 머신러닝 모델 정확도가 향상될 때까지 미리 정의된 모델을 사용

- 미리 정의된 머신러닝 모델을 쓰는 경우 주기적으로 모델을 변경
- 애플리케이션에 모델을 내장하면 새로운 모델 배포가 더 쉬움

- 온라인 머신러닝 모델은 새로 학습한 내용을 메모리에 저장
- 신뢰성 패턴을 사용해서 복구 가능하게 만드는 게 좋다

#### 관련 패턴들
- 변환 패턴
    - 머신러닝 모델이 예측한 데이터를 다른 포맷으로 변경
- 신뢰성 패턴
    - 온라인 머신러닝이 학습한 상태를 저장 및 복구

### 6.3.7 스트리밍 데이터 프로세싱 패턴 정리

| 패턴          | 사용하면 좋은 경우                                                                                                   | 사용해서는 안 되는 경우                                                                                         | 이점                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| 변환          | • 이벤트 포맷이나 구조, 프로토콜을 바꿔야 하는 경우<br>• 이벤트의 데이터 입부를 추가, 수정 또는 삭제해야 하는 경우<br>• 서드파티 시스템에서 현재 사용하는 이벤트를 지원하지 않을 때 | • 이벤트를 소비하는 시스템이 이 벤트를 파악하고 그대로 사용할 수 있는 경우                                                           | • 호환되지 않는 시스템과 이벤트를 주고받을 수 있음<br>• 관련 정보만 포함시킴으로써 이 벤트 크기를 줄일 수 있음               |
| 필터와 한계잣     | • 이벤트 처리에 이벤트의 입부만 사용할 경우                                                                                    | • 이벤트 처리에 모든 이벤트를 사용할 경우                                                                              | • 이벤트 입부만 사용함으로써 시스템에 가해지는 부하를 줄일 수 있음                                           |
| 윈도우 애그리게이션  | • 시간 간격 또는 길이에 따라 이 벤트를 나누고 조합해야 할 경우<br>• 총합, 최소값, 최댓값, 평균, 표준 편차, 이벤트 개수 등의 작업을 처리해야 할 경우                  | • 이벤트의 중요한 첫 기와 같이 고정된 크기의 메모리 공간에서 처리할 수 없는 작업인 경우<br>• 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우              | • 이벤트를 나누어 처리함으로써 시스템의 부하를 줄일 수 있음<br>• 데이터에 대한 요약을 제공함으로 전체 데이터보다 더 쉽게 이해할 수 있음 |
| 스트림 조인      | • 두 개 이상의 이벤트 스트림의 이벤트들을 합처야 하는 경우<br>• 병렬 처리를 위해 나는 이벤트들을 다시 합처야 하는 경우                                      | • 합처야 할 이벤트들이 가까운 시간 간격 내에 도착하지 않는 경우<br>• 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우                            | • 서로 연관된 이벤트들을 처리할 수 있음<br>• 이벤트의 동기화 처리가 가능함                                    |
| 임시적인 이벤트 정렬 | • 이벤트 발생 순서를 알아야 할 경우<br>• 이벤트가 발생되지 않음을 알 아야 할 경우                                                           | • 유한 상태 기계에서 이벤트 발생 순서를 정의할 수 없는 경우<br>• 신뢰성 패턴을 사용하지 못하며 높은 정확도가 필요한 경우<br>• 이벤트가 순서에 맞지 않게 도 착하는 경우 | • 이벤트 도착 순서에 따라 목장 한 조건을 탐지할 수 있음                                                |
| 머신 러너       | • 실시간 예측 작업이 필요한 경우<br>• 이벤트에 대한 분류, 군집, 회귀 분석 등의 작업이 필요한 경우                                                 | • 모델을 사용하여 갖는 정확하게 예측할 수 없는 경우<br>• 머신러닝 모델을 만들기 위한 과거 데이터가 충분하지 않는 경우                                | • 자동화된 의사 결정 시스템을 만들 수 있음<br>• 합리적인 추론 기능 제공                                     |

## 6.3.4 확장성 및 성능 최적화 패턴
- 독특한 확장성 및 성능 요구사항을 지님
- 순서를 지켜야 한다거나 등
- 또한 대개 메모리에 상태를 저장해 정확도를 해치지 않으면서 확장할 수 있는 전략이 필요

### 6.4.1 순차 수송 패턴
- sequential convey pattern
- 이벤트를 다양한 분류로 나누고, 병렬로 처리하는 방식
- 이벤트 순서를 영구 저장해 나중에 다시 합칠 수 있으므로 원래 순서를 보장함
#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115214553.png)

- 컨베이어 벨트를 따라 이벤트를 옮기고 분류
- 특성이나 값에 따라 그룹을 나누고 이를 병렬로 처리
- 고객의 등급, 주문 금액 크기에 따라 물건 배송 시간을 다르게 보장 등
- 이런 경우 기준에 따라 이벤트를 여러 유형으로 나누고 병렬로 처리해 당일 배송, 익일 배송, 주중 배송과 같은 다양한 배송 형태를 보장

![](files/Pasted%20image%2020251115214649.png)
- 각 이벤트는 분리하기 전 순번을 매김
- 이런 경우 병렬로 처리하면서 작업을 이벤트 순서대로 처리 가능
- 이 순번을 가지고 병렬 처리한 이벤트 스트림을 다시 합칠 때 다시 순서대로 정렬 간으

- 메시지 브로커, 이벤트 큐가 이 패턴을 구현할 때 중요한 역할을 맡음
- 메시지 브로커나 이벤트 큐는 이벤트를 나누고, 하위 스트림으로 나누고 이벤트를 젖아해 단일 스트림으로 다시 합칠 때까지 보관할 수 있다

#### 어떻게 사용할 수 있나요

- 스트림 처리 애플리케이션 확장
    - 이를 이용해 CPU, 메모리, 네트워크 대역폭 등 제약을 극복하고 더 낮은 지연 시간과 높은 처리량으로 처리할 수 있게 해줌
    - 이벤트 내용을 압축 풀고 복호화해야하는 경우 PCU를 많이 씀
    - 아래처럼 여러 스트림으로 나누고 병렬로 처리함으로써 지연시간을 제거하고 빠르게 큐에 저장 가능
    - 혹은 이벤트 처리를 위해서 고객 ID를 데이터 스토어 검색해야 하는 경우 지연 시간이 크게 발생함
    - 캐싱할 수 있지만 결국 공간이 한정되므로 모든 데이터를 캐싱할 수 없음. 캐시 미스로 지연 발생
    - 순차 수송 패턴으로 고객 ID의 해시 값에 기반에 여러 하위 스트림으로 나눌 수 있음
    - 이렇게 하면 캐시 적중률을 늘릴 수 있음

![](files/Pasted%20image%2020251115214824.png)

- 스트림 처리 분할
    - 이벤트 스트림을 유형별로 나누고 병렬로 처리
    - 고객 등급에 따라 서로 다른 마이크로 서비스를 적용해 별도 할인 적용

![](files/Pasted%20image%2020251115214819.png)

#### 고려해야 할 사항들
- 의미있는 스트림 처리를 위해서는 이벤트 속성 값에 따라 이벤트 분류할 수 있어야 함
- 고객 ID, 상품 ID와 같은 단일 속성 값만으로 이벤트를 분류할 수 있지만 대개 여러 속성 값을 조합해야만 서로 연관된 이벤트 분류가 가능

- 이벤트를 여러 하위 스트림으로 나누면 각 하위스트림은 서로 다른 클라우드 네이티브 애플리케이션을 통해 처리 가능, 그 과정에서 이벤트가 걸러지거나 삭제될 수 있음
- 이 과정에서 더 이상 이벤트 순번이 연속적이지 않게 됨
- 이 경우 다시 합칠 때 모든 순번이 다 있지 않다는 사실에 유의

- 이벤트를 다시 합치는 더 좋은 방법은 순차 이벤트가 끝났다는 메시지(end of sequence message)를 보내주는 것
- 이벤트를 처리하는 각 애플리케이션이 주기적으로 가장 마지막으로 처리한 이벤트의 ID를 보내는 것
- 이를 토대로 도착하지 않은 이벤트는 제거되었음을 알 수 있음

- 순번을 토대로 다시 이벤트를 합칠 수 없는 경우 이벤트들을 합쳐서 단일 토픽으로 다시 발행할 수 있음

- 스트림 처리 MS가 병목이 된다면 스트림 수를 확장해 설계하는 게 좋다
- 이벤트 분류하는 방법을 바꿔서 부하가 심한 하위스트림을 더 많은 하위스트림으로 쪼갠다거나
- 애플리케이션의 상태를 하위 스트림을 처리하는 애플리케이션으로 이전하는 작업도 필요

- 어느 정도의 이벤트 처리 속도가 나오는지 관찰하는 것도 필요
- 아주 높은 처리 성능과 낮은 지연속도가 요구된다면 이벤트에 순번을 추가하고 이 순번을 토대로 처리된 이벤트를 다시 합치는 작업 자체가 병목이 될 수 있음
- 이 경우 꼭 정렬이 필요한지 고민

#### 관련 패턴들
- 생산자-소비자 및 발행자 구독자 패턴
    - 순차 수송 패턴 구현할 때 사용 가능
- 버퍼 이벤트 순차 정렬 패턴
    - 여러 이벤트 스트림을 합쳐서 순서대로 정렬할 때 사용
- 주기적인 상태 스냅숏 저장 패턴
    - 하위 스트림을 처리하는 애플리케이션의 상태를 저장해 확장 가능하게 만들기

### 6.4.2 버퍼 이벤트 순차 정렬 패턴
- 이벤트는 네트워크 지연, 연결 재시도로 순서가 맞지 않을 수 있음
- buffered event ordering pattern으로 정렬 가능
- 시각 또는 생성 순서대로 정렬
#### 어떻게 동작할까요
- 이벤트를 순서대로 정렬하기 위해서는 이벤트에 순차로 증가하는 값을 기록해야 함
- 순번, 혹은 시각
- 순번은 계속 증가하는 값이며 고유함이 보장되어야함
- 하지만 시각은 고유하지 않을 수 있음

![](files/Pasted%20image%2020251115215513.png)

- 단, 위 케이스처럼 9번 이벤트가 누락될 수도 있음
- 이벤트 처리가 끝났다는 메시지를 보내면 어떤 이벤트가 누락되었는지 빠르게 파악 가능
- 시각 기준으로 정렬하면 이런 방식의 최적화는 어려움
- 중복되거나 빠진 시각값이 많기 때문
- 마지막으로 전달받은 시각 값과 타임아웃 사용해서 이벤트를 정렬하는 것이 일반적

- 시각 또는 순번을 통해 순서에서 벗어난 이벤트를 탐지한 경우 타임아웃 시간을 조절해 문제 발생 소지를 줄일 필요가 있다.
- 기록된 시작 값이 700초인 이벤트를 전달받은 다음 시각 값이 650초인 이벤트를 받으면 이벤트에 대한 타임아웃 값을 최소 50초로 재조정해야 함
- 자세한 건 K-slack, AQ-Kslack 등의 알고리즘 참고
#### 어떻게 사용할 수 있나요
- 분산 생성된 이벤트들 순차 정렬
    - 여러 곳에서 만들어진 이벤트들은 네트워크 또는 중간 시스템으로 인한 지연으로 순서에 맞지 않게 도착하는 경우가 많다
    - 이런 경우 이벤트가 생성된 시각을 사용해야 한다
    - 이벤트를 가져와서 정렬 후 다음 후속 시스템에 이벤트를 전달
    - 물론, 시각 동기화는 필요
- 같은 원천에서 생성한 이벤트들을 재정렬
    - 성능 목표를 달성하기 위해서 이벤트를 병렬 분산해서 처리해야 할 수도 있다
    - 같은 곳에서 생성하면 순번 매기기가 쉬우므로 고유한 순번 사용하는 게 좋다

#### 고려해야 할 사항들
- 시간에 따른 이벤트 애그리게이션이나 이벤트 순번 탐지가 필요할 때 쓰면 좋다
- 그렇지 않으면 지연 시간이 추가되고 시스템의 병목 지점이 될 수 있음

- 단일 원천에서 생성된 경우 높은 정확도로 재정렬 가능하다
- 이벤트가 분산되어 생성되는 경우 각 원천들의 시각이 동기화되었는지 알기 어려워 보장이 어렵다
- 그래서 단일 원천에서는 항상 고유한 이벤트 순번을 쓰는 게 좋다.
- 더 효과적, 지연도 짧음

- 먼저 생성된 이벤트가 더 늦게 도착하는 경우 어긋난 상태로 전달할지 제거할지 결정해야 함
- 최신 데이터만 중요하면 버리는 게 좋음
- 그러나 부정 사용 감지 등 이벤트가 다 필요한 경우 이벤트를 버려서는 안 된다.

- 버퍼 이벤트 순차 정렬 패턴을 사용하면 이벤트를 버퍼를 저장해야만 아직 도착하지 않은 오래된 이벤트를 기다릴 수 있다
- 즉, MS가 상태를 가진다
- 신뢰성 패턴으로 상태 복구가 필요

#### 관련 패턴들
- 임시 이벤트 순차 정렬 패턴 및 윈도우드 애그리게이션 패턴
    - 이벤트를 순서대로 처리할 수 있어 더 정확한 결과 만들 수 있음
- 신뢰성 패턴
    - 이벤트 순차 정렬을 위해 버퍼 사용 -> 상태 복구

### 6.4.3 오류 수정 패턴
- cause correction pattern
- 이벤트 분석 결과를 최대한 빠르게 처리하고 이후 빠진 이벤트가 뒤늦게 도착하면 이를 토대로 수정해서 알려줌
- 정확도는 약간 떨어지지만 낮은 지연 속도를 지님
#### 어떻게 동작할까요
- 윈도우드 애그리게이션 패턴이나 임시 이벤트 순차 정렬 패턴과 함께 사용
- 모든 이벤트가 순서대로 도착할 때까지 기다리지 않고 일단 이벤트가 도착하는 대로 결과를 만든다
- 나중에 도착한 이벤트를 발견하면 이를 반영해 다시 알려줌
- 이 패턴을 사용하려면 다운스트림 애플리케이션이 전달받은 이벤트가 나중에 더 정확한 내용으로 부분적으로 업데이트 될 수 있다는 점을 알아야만한다.

#### 어떻게 사용할 수 있나요
- 결과를 최신 정보로 업데이트하기
    - 이 패턴은 최대한 빠르게 결과를 받아보고자 할 때 많이 사용
    - 실시간으로 결과를 화면에 보여줄 대 많이 사용
    - 1분 동안 발생한 주문 건 수 추적 등

![](files/Pasted%20image%2020251115223534.png)

- 이전에 만든 의사 결정 데이터 수정
    - 의사 결정 데이터를 빠르게 만든 후 상황이 바뀌면 보상 이벤트를 보내서 의사 결정 내용에 대한 수정 작업을 하도록 만들어야 할 때도 있음
    - 사용자가 요청해서 택시를 최대한 빠르게 보내야하는 상황
    - 사용자가 택시를 요청하면 해당 지역의 모든 택시에 이 내용을 전달하고, 어느 택시 하나가 수용하면 나머지 모든 택시에 사용자 요청이 처리되었음을 알린다
    - 이 과정에서 여러 택시가 요청을 수용했지만 네트워크 지연으로 늦게 알 수도 있음
    - 이 경우 수정 이벤트를 보내서 다른 택시에 할당된 요청 사항을 취소하도록 만들기

#### 고려해야 할 사항들
- 초기에 빠르게 만든 데이터도 유용하고, 나중에 수정할 수 있는 경우에만 이 패턴을 사용
- 오류 수정을 지원하지 않는다면 버퍼 이벤트 순차 정렬 등 의사 결정을 이벤트가 도착할 때가지 지연시키는 패턴을 쓸 수밖에 없다.
- 대부분의 경우 이벤트가 늦게 도착하는 경우를 대비하기 위해서 메모리에 계속 저장함
- 얼마나 기다릴지 + 메모리는 충분한지 고민 필요

- 오류  수정은 이전에 계산한 결과나 내보낸 데이터를 다 기억해야만 하기 때문에, 신뢰성 패턴을 사용해서 상태를 저장하고 시스템 장애나 재시작 상황에서 복구가 가능해야 함

#### 관련 패턴들
- 신뢰성 패턴
    - 이전에 만든 결과 데이터 복구
- 버퍼 이벤트 순차 정렬 패턴
    - 오류 수정을 지원하지 않는 경우 대신 사용
- 임시 이벤트 순차 정렬 패턴 및 윈도우드 애그리게이션 패턴
    - 오류 수정 패턴과 함께 빠르게 결과 받고, 나중에 오류 수정

### 6.4.4 워터마크 패턴
- watermark pattern
- 이벤트 스트림을 통해 메쉬 구조 형태로 서로 연결된 여러 MS 간 스트림 처리를 주기적으로 정렬해야 하는 경우 사용
- 정렬을 통해 모든 MS가 특정 이벤트보다 먼저 도착한 이벤트를 전부 다 처리했는지 확인할 수 있음
- 이때 참조하는 특정 이벤트를 일반적으로 워터마크 이벤트라고 부름
- 이 패턴을 통해 시스템 시간 없이 여러 MS 동기화 가능
#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115223936.png)

- 워터마크 생성기가 주기적으로 워터마크 이벤트 생성해서 외부 입력 지점으로 보내야 함
- 이 이벤트는 아주 특별한 것으로 MS는 이 이벤트를 의존하는 시스템에 반드시 전달해야 함
- 이벤트를 소비하는 중간 MS들이 여러 이벤트 사이에서 같은 위치에 이 워터맡크 이벤트를 다시 전달할 수 있도록 해야함
    - 정확히 같은 위치에

- 입력 시스템이 시간 기반으로 동기화되어 있다면 각 입력 시스템이 독립적으로 워터마크 이벤트를 생성하도록 만들 수 있음

- 이런 방법을 쓰면 모든 워터마크 이벤트 마다 이벤트 처리가 동기화된다는 것을 보장

- 만약 입력 시스템 간 시간 기반 동기화가 불가능하다면 전역 카운터 등을 도입해 이벤트 순번을 만ㄷ들 수 있음
- 이 경우 여러 스트림에서 워터마크 이벤트가 순차적으로 생성되고 처리될 수 있음


#### 어떻게 사용할 수 있나요
- 여러 입력 소스 시스템으로부터 이벤트들이 제때 도착하지 않거나 네트워크 지연, 처리 시간 등으로 이벤트 도착 시간에 영향을 주는 경우 사용
- 어떤 입력 시스템의 이벤트는 빨리 도착하고, 다른 스트림의 이벤트는 늦게 도착한다면 여러 스트림 간 이벤트 분석에 영향을 줄 수 있음
- 이벤트 처리를 주기적으로 동기화해서 오류를 줄이고자 할 때 쓰면 좋음

- 시간 기반 동기화된 여러 이벤트 소스로부터 생성된 이벤트들 동기화
    - 더 정확한 집계 결과를 만들기 위해 워터마크로 이벤트 그룹들을 동기화
    - 여러 서버로부터 값을 읽어서 처리하고 결과를 만든다고 하면
        - 이벤트를 만든느 각 서버는 입력 스트림에 주기적으로 워터마크 이벤트 만들어서 보냄
    - 각 애그리게이션 작업 결과가 더 정확해지고 네트워크 지연 등 외부 요인에 영향을 받는 경우가 줄어든다
    - 이 경우 동기화를 위해 이벤트가 생성된 시각을 사용하지는 않는다
        - 어떤 입력 스트림은 아주 오랫동안 이벤트를 생성하지 않을 수도 있으니까

![](files/Pasted%20image%2020251115224404.png)
- 동기화되지 않은 입력 소스로부터 생성된 이벤트들 동기화화기
    - 분산된 입력 소스로부터 이벤트를 받으면 여러 이유로 늦게 도착할 수 있음
    - 이런 상황에서 동기화하려면 중앙 서버에 전역 카운터를 도입해 센서가 읽어 들인 값을 이벤트로 만들기 전 전역 카운터에서 이벤트 순번을 주기적으로 가져가도록 만들 수 있음
    - 이렇게 가져간 순번에 기반해 주기적으로 워터마크 이벤트를 만들어 이벤트들을 동기화하고, 각 이벤트 순번에 생성 시각을 기록해 워터마크 이벤트 사이에 있는 이벤트들의 상대적인 순서를 알아낼 수 있음

![](files/Pasted%20image%2020251115224419.png)

#### 고려해야 할 사항들
- 네트워크 지연 등으로 이벤트 도착 시각이 생성 시각과 큰 차이가 발생할 것이란 걸 아거나, 입력 시스템들이 시간 동기화가 맞지 않는 상황에서만 쓰는 게 좋다
- 그게 아니면 이 패턴을 써도 큰 이점을 보지 못함
- 시간 기반 동기화가 잘 되어있는 경우 생성 시각 기록하고 버퍼 이벤트 순차 정렬 패턴 쓰는 게 더 좋음

- 이 패턴은 여러 스트림 간 발생할 수 있는 시간 기반 동기화 문제만 해결할 수 있음
- 이 패턴을 쓴다고 모든 상황에서 더 정확한 계산 결과를 도출할 수 있다고 보장할 수 있음
- 그리고, 이벤트 그룹 내에서는 여전히 순서가 맞지 않을 수 있음

- 이벤트를 실제 생성된 시각 근거해서 처리하거나 이벤트 간 상대적 정렬이 필요한 게 아니면 안 쓰는 게 좋다
- 정말 필요한 게 아니면 복잡도만 늘린다.

- 가능하다면 아파치 플링크처럼 이런 기능을 기본 제공하는 스트림 처리 시스템을 쓰기
- 부정 사용 탐지, audit 등 이벤트 순서가 아주 중요한 경우에만 사용하기

#### 관련 패턴들
- 버퍼 이벤트 순차 정렬 패턴 및 오류 수정 패턴
    - 이벤트 도착 시각이 네트워크 지연, 다른 처리 시스템으로 인해 영향을 받지 않는 경우 이 패턴들 대신 사용
- 임시 이벤트 순차 정렬 패턴 및 윈도우드 애그리게이션 패턴
    - 워터마크 패턴과 함께 사용해 이벤트를 순서대로 정렬하고 결과를 더 정확하게 만들기
- 주기적 상태 스냅숏 저장 패턴
    - 주기적 상태 스냅숏 패턴에서 필수 패턴으로 여러 스트림 동기화하고 주기적으로 상태 스냅숏을 만들어서 저장할 때 사용

### 6.4.5 확장성 및 성능 최적화 패턴

| 패턴           | 사용하면 좋은 경우                                                                                                       | 사용해서는 안 되는 경우                                                                                                      | 이점                                                                               |
| ------------ | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| 순차 수송        | • 스트림 프로세싱 애플리케이션의 확장성이 필요한 경우<br>• 스트림을 분할해서 각 스트림을 서로 다른 방식으로 처리해야 하는 경우<br>• 이벤트를 병렬로 처리한 다음 원래 순서로 합치야 하는 경우 | • 스트림 처리 애플리케이션이 전체 이벤트를 처리할 수 있는 충분한 능력이 있는 경우                                                                    | • 스트림 처리 애플리케이션의 확장성을 제공<br>• 이벤트를 병렬로 처리한 경우 이벤트 원래 순서로 합칠 수 있음                 |
| 버퍼 이벤트 순차 정렬 | • 이벤트를 순번 또는 생성 시각 기준으로 정렬해야 하는 경우<br>• 순서에 맞지 않는 이벤트를 정렬해서 합치고 하나의 이벤트 스트림으로 만들어야 하는 경우                         | • 임의 정렬된 여러 이벤트 스트림의 실제 순서를 알아야 하는 경우<br>• 분산된 소스로부터 생성된 이벤트들의 실제 순서를 알아야 하는 경우<br>• 애플리케이션에서 신뢰성 패턴을 사용할 수 있는 경우  | • 이벤트를 순서대로 정렬해야 하는 모든 애플리케이션 앞에 적용할 수 있음                                        |
| 오류 수정        | • 이전에 상황한 결과를 수정해야 하는 경우<br>• 애그리게이션 추정치를 더 빨리 만들어야 하는 경우<br>• 이벤트 순서를 추정해서 먼저 처리한 다음에 이 내용을 수정해야 하는 경우          | • 중력 이벤트 사용하는 다운스트림 시스템이 자속적인 이벤트 변경을 처리할 수 없는 경우                                                                  | • 추정치를 더 빨르게 만들고 데이터가 더 많아지면 이 추정치를 수정할 수 있음                                     |
| 워터마크         | • 동기화가 맞지 않는 이벤트 소트림들에 대한 애그리게이션 작업을 처리해야 하는 경우<br>• 분산 시스템에서 생성된 이벤트들의 순서를 정렬해야 하는 경우                           | • 이벤트 소스 또는 그와 가까운 시스템이 워터마크 이벤트를 생성해서 보낼 수 없는 경우<br>• 중간 시스템이 워터마크 이벤트를 그대로 전달할 수 없는 경우<br>• 네트워크 대역폭이 중요한 자원인 경우 | • 여러 스트림 간 이벤트들을 주기적으로 동기화할 수 있음<br>• 네트워크 또는 중간 시스템의 이벤트 처리로 인한 지연 문제를 해결할 수 있음 |

## 6.5 신뢰성 패턴
- 대부분 클라우드 네이티브 스트림 프로세싱 애플리케이션은 자신의 상태를 메모리에 저장하므로 낮은 지연과 높은 처리량으로 처리
- 때문에 신뢰성이 중요하다
- reliability pattern을 통해 시스템 장애나 재시작에도 상태 보존 가능

- 또한 신뢰성 패턴은 최소 한 번 , 정확히 한 번 처리 패턴 구현에도 큰 도움이 된다
### 6.5.1 재생 패턴
- 애플리케이션 상태가 최근에 처리된 이벤트에 따라 바뀐다면 replay pattern을 사용해서 과거 이벤트를 재생해 상태 복구 가능
#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115225151.png)
- 시스템이 도작을 멈춘 경우 이 전의 이벤트들을 다시 보낸다
- 얼마나 많은 과거의 이벤트를 보낼지는 어떻게 사용하는지에 따라 다르다
- 과거 3분간의 데이터만 모아서 처리했다면 과거의 최소 3분간 데이터를 보낸다
- 상태를 주기적으로 저장한다면 마지막으로 저장한 이후 이벤트만 보낸다

- 시스템 상태를 다시 만들려면 데이터를 만들어내는 시스템은 이벤트를 가져간 뒤에도 계속 이벤트를 저장하고 있어야 한다
- 일반적인 메시지 브로커는 이벤트를 가져가면 삭제하므로 내구성 구독이나 소비한 이벤트에 대해서 다른 방식으로 응답을 보내지 않는 이상 이 패턴에서는 사용할 수 없다

- 이 패턴에서는 카프카나 NATS와 같이 마이크로서비스에 이벤트를 전달해도 삭제하지 않는 로그 기반 메시지 브로커를 사용하면 된다
- 이런 메시지 브로커는 마지막으로 처리한 이벤트 순번을 사용해서 그 이후 이벤트를 가져와서 처리할 수 있다
- 관계형 데이터베이스나 NoSQL, 파일 시스템 등을 사용할 수도 있다.

#### 어떻게 사용할 수 있나요
- 시스템 상태가 저장되지 않은 상태에서 이벤트를 재생하고 복구
    - 최근 1분간 구매 주문에 대한 집계를 내는 애플리케이션을 생각해보자
    - 1분 단위 배치 작업을 실행하므로 각 1분이 끝나면 마이크로서비스는 집계 결과를 만들고 상태를 초기화
    - 내구성 토픽 구독을 사용해서 이벤트를 가져오면 1분 단위 배치 작업이 끝날 때까지 응답을 미룰 수 있다
    - 작업이 끝나고 응답을 보내면 그제서야 브로커가 이벤트를 삭제
    - 혹은 오류를 찾기 위해 로그 파일을 분석하는 무상태 서비스가 있다고 해보자
    - 로그 분석 후 파일을 다른 폴더로 옮긴다고 하면 분석이 끝나지 않은 로그는 폴더에 남아있으므로 모든 이벤트 처리를 보장할 수 있다
- 시스템이 상태를 저장하는 상황에서 이벤트를 재생하고 상태를 복구
    - 최근 1시간 기온 평균을 계산하는 서비스
    - 집계 상태를 매 1분마다 데이터 스토어에 저장하면 스토어로부터 상태를 읽어와서 복구하고 그 이후 이벤트를 가져와서 재생할 수 있음

#### 고려해야 할 사항들
- 재생 패턴으로 상태 복구할 수 있지만 그 과정에서 이벤트 중복 처리가 발생할 수 있다
- 이 경우 의존 시스템은 멱등해야한다

- 재생 패턴을 쓸 때 몇몇 이벤트가 유실될 수도 있다
- 이벤트 소스에서 최근 2분간 발생한 이벤트를 버퍼에 저장해 필요한 경우 다시 발행한다면
- 2분 이후에 재시작하면 이미 버퍼를 비운 뒤라 날라간다
- 이벤트 소스가 더 긴 시간 동안 이벤트를 저장할 수 있는 경우에만 사용
- 또한 상태를 영구 저장해야 한다면 이 패턴을 주기적 상태 스냅숏 저장 패턴과 함께 쓰는 게 좋다
#### 관련 패턴들
- 발행자-구독자 패턴
    - 내구성 구독을 통해 시스템이 복구된 후 이벤트를 재생할 때 사용
- 주기적 상태 스냅숏 저장 패턴
    - 재생 패턴과 함께 사용해 상태 복구하고 전체 상태 복구 시간을 줄일 수 있다

### 6.5.2 주기적 상태 스냅숏 저장 패턴
- 상태를 매 이벤트 처리마다 저장하는 건 현실적인 방법이 아니다
- 엄청나게 긴 지연 시간이 발생할 수 잇음
- periodic snapshot state persistence pattern을 사용하면 주기적으로 상태를 저장해 시스템 장애나 재시작에 대응하고 상태 복구할 수 있다.
#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115225227.png)
- 주기적으로 현재 상태에 대한 사본 만들고 이벤트를 처리하기 전에 스토어에 상태 사본 저장
- 장애 상황에서도 이벤트가 유실되지 않고 최소 한 번을 보장하려면 이벤트를 읽어올 때 메시지 브로커를 써야함
- 카프카 같은 로그 기반 메시지 브로커 쓰면 상태 스냅숏 저장할 때 이벤트 순번도 함께 저장할 수 있다
- 이를 통해 순번을 토대로 메시지 브로커로부터 이벤트를 읽어올 수 있다.

- 액티브 MQ와 같은 표준 메시지 브로커 슬 때는 상태 스냅숏 저장한 다음 메시지 브로커에 처리 응답을 보내야 한다
- 그래야 응답하지 않은 이벤트를 브로커가 가지고 있다

- 이 패턴을 쓰면 최소 한 번을 보장할 수 있다
- 대신, 이벤트 중복 전달은 가능

![](files/Pasted%20image%2020251115225235.png)

![](files/Pasted%20image%2020251115225246.png)

- 종속 시스템이 중복 이벤트를 처리할 수 없다면 출력 스트림의 이벤트에 새로운 순번을 매겨야 함
- 이를 통해 종속 시스템은 중복 이벤트를 처리하지 않고 그냥 버릴 수 있다.

- 주기적으로 상태 저장하지 않고 워터마크 패턴처럼 이벤트를 동기화할 때마다 상태 스냅숏 저장하는 것도 가능
- 이렇게 하면 워터마크 이전 이벤트가 전부 처리되고 그에 대한 상태가 저장됨을 보장할 수 있다.
#### 어떻게 사용할 수 있나요
- 데이터를 메모리에 저장하고 처리하면 이벤트를 처리할 때마다 상태를 스토어에 저장하지 않고 상태를 저장할 수 있다.

- 최근 10분 동안 계속 주가가 상승하는지 탐지하는 애플리케이션이 있다면
- 마지막으로 주가가 떨어진 시점을 기억하고, 주가가 계속 오르는지 살펴본다
- 카프카 토픽을 사용할 때 이벤트를 읽어온다면 현재 값은 물론 마지막으로 처리한 이벤트의 순번과 마지막으로 주가가 하락한 시각도 기억해야 함
- 이 세 가지 정보가 MSdㅢ 상태가 된다.

#### 고려해야 할 사항들
- 절대 유실해서는 안 되는 중요한 데이터를 처리할 때만 이 패턴 사용
- 그렇지 않은데 이 패턴을 사용하면 운영만 더 힘들어진다.

- 만약 저장한 애플리케이션 상태가 하루 전이라면 상태 복구를 위해 재생해야하는 이벤트 양이 너무 많아 현실적으로 어렵다
- 이런 경우 주기적 상태 스냅숏 저장 패턴을 쓰는 게 좋다.

- 어떤 경우 상태 그 자체가 아주 크고 읽고 쓰는 데 오래 걸릴 수 있다
- 이런 경우 증분 스냅숏을 사용해서 차이점만 기록할 수 있다
- 서비스가 재시작하면 증분 스냅숏을 재생해서 상태를 복구할 수 있다.

- 상태를 저장할 때는 저장 작업이 이벤트 처리 작업을 중단하지 않게 해야한다
- 주기는 너무 짧거나 길지 않게 해야한다.

#### 관련 패턴들
- 임시 이벤트 순차 정렬 패턴 및 윈도우드 애그리게이션 패턴
    - 스냅숏 패턴과 함께 써 신뢰성 구현
- 재생 패턴
    - 마지막 상태 스냅숏으로 복구 후 재생 패턴으로 유실된 이벤트 처리
- 워터마크 패턴
    - 여러 마이크로 서비스 간 상태 스냅숏 동기화

### 6.5.3 이중화 노드 장애 극복 기능 패턴
- 저 지연 서비스는 장애가 발생했을 때 수 분 에 걸쳐 재시작하고 상태를 복구할 만큼 여유롭지 않다
- 이런 경우 여러 개를 한꺼번에 실행해 장애를 극복하도록 하는 게 운영 차원에서 더 좋다
- 이렇게 마이크로서비스를 여러 노드로 실행하는 걸 two-node failover pattern이라고 한다.

#### 어떻게 동작할까요
![](files/Pasted%20image%2020251115225254.png)
- 백업 마이크로서비스를 병렬 실행
- 마이크로서비스를 배포할 때 우선 리더를 뽑음
    - 주키퍼를 쓰거나 다른 서비스를 써서
- 두 마이크로서비스는 모든 이벤트를 처리
- 같은 토픽을 구독해서 같은 이벤트를 처리 -> 발행자-구독자 패턴
- 양쪽 마이크로서비스가 같은 이벤트를 처리하므로 두 서비스는 같은 상태를 유지
- 단, 주 서비스만 종속 시스템 측으로 이벤트 처리 결과를 전송하고 부 서비스로도 출력 결과를 보내준다
- 부 서비스는 주 서비스의 출력 결과와 자신의 결과를 비교하고, 이미 처리한 이벤트 결과는 버린다.
- 주 서비스가 동작을 중지하면 부 서비스는 주 서비스로 승격되고 이벤트 처리 결과를 종속 시스템으로 전송
- 부 서비스는 주서비스가 마지막으로 어떤 이벤트를 처리했는지 알고 있음
- 새로운 이벤트(D)를 처리하고 발행하기 전에 우선 출력되지 않은 이벤트(C)를 종속 시스템으로 전달

- 나중에 문제가 생긴 서비스가 다시 시작하면 부서비스로 동작하기 시작
- 이벤트를 받아 처리하고, 현재 주 서비스가 만든 처리 결과에 따라 해당 처리 결과를 버린다.

- 시간이 지나면 재시작한 부서비스의 상태는 주 서비스의 상태와 같아져 다시 장애가 발생했을 때 주 서비스가 될 수 있는 요건을 갖춘다
- 주기적 상태 스냅숏 저장 패턴을 쓰면 더 빠르게 상태 복구가 가능하고, 전반적인 가용성을 올릴 수 있다.

#### 어떻게 사용할 수 있나요
- 시스템 장애로 인한 운용 중단 시간이나 지연 시간의 증가가 문제될 때 사용하면 좋다
- 이를 사용하면 빠르게 부 서비스로 전환할 수 있고, 어떤 이벤트도 유실되지 않음을 보장할 수 있다.

#### 고려해야 할 사항들
- 낮은 지연시간이 주요 요구사항인 경우에만 스기
- 그 외 패턴에서는 주기적 상태 스냅숏 패턴이 더 좋다
- 구현도 어렵고 장애 동안 서비스가 불가능해도 큰 문제가 없다면 굳이 아키텍처에 복잡도 증가시킬 필요가 없음

- 이 패턴에서는 양측 마이크로서비스가 모두 안정적인 네트워크 연결을 가진다고 가정
- 주 서비스가 출력을 부 서비스로도 전달해야 함
- 주 서비스와 부 서비스 간 네트워크 단절이 발생할 경우 출력 결과를 전달할 수 없다는 위험성도 있음
- 이 경우 제 3의 시스템을 도입해 리더 선출 및 관리가 필요함
- 아니면 양쪽 서비스가 모두 주 서비스가 되어 다운스트림에 출력을 보낼 수 있다.

- 그리고 양쪽 마이크로서비스가 동시에 동작을 멈추는 것도 가능하다
- 이 경우 상태가 유실될 수 있음
- 이를 방지하기 위해 주기적 상태 스냅숏 저장 패턴이나 재생 패턴으로 상태 복구가 필요

- 두 개의 노드를 사용해도 처리량이 늘지는 않는다
- 확장성이 필요하다면 순차 수송 패턴을 사용하고, 각 병렬 처리 시스템을 주 서비스와 부 서비스로 짝을 지어 배포함으로써 확장성 및 장애 극복 기능을 동시에 만족 가능

#### 관련 패턴들
- 주기적 상태 스냅숏 저장 패턴 및 재생 패턴
    - 이 패턴과 함께 사용해 재시작할 때 상태를 복구할 수 있다
- 순차 수송 패턴
    - 확장성을 위해서
- 발행자-구독자 패턴
    - 주, 부 서비스가 같은 이벤트를 받아서 처리하기 위해서 사용
### 6.5.4 신뢰성 패턴 정리
| 패턴             | 사용하면 좋은 경우                                                                                                                   | 사용해서는 안 되는 경우                                                                                                                                          | 이점                                                                                             |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| 재생             | • 시스템 상태가 최근 이벤트에 의해 결정되는 경우<br>• 이전에 처리한 이벤트에 집중해서 상태 복구가 가능한 경우<br>• 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우           | • 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>• 중속 시스템이 중복 이벤트를 처리할 수 없는 경우<br>• 시스템이 상태 복구에 시간이 소요되어서는 안 되는 경우<br>• 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정되는 경우 | • 대량의 스냅숏을 저장하지 않고도 상태를 복구할 수 있음                                                               |
| 주기적 상태 복구 자장   | • 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정되는 경우<br>• 이전에 처리한 이벤트에 집중해서 상태 복구가 가능한 경우<br>• 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우 | • 시스템 상태가 최근 처리한 이벤트만 영향을 받는 경우<br>• 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>• 시스템의 상태 복구에 시간이 소요되어도 문제가 없는 경우                                        | • 상태를 더 빠르게 복구할 수 있음<br>• 더 긴 더 큰 장애의 경우에도 시스템 복구가 가능함<br>• 중속 애플리케이션이 중복 이벤트를 처리하지 않도록 할 수 있음 |
| 다중 노드 장에 극극 기능 | • 애플리케이션 상태 복구에 시간이 걸려서는 안 되는 경우<br>• 시스템의 상태가 장시간에 걸쳐 처리된 이벤트에 의해 결정되는 경우<br>• 스토어나 파일 시스템, 로그 기반 메시지 브로커를 통해 데이터를 처리하는 경우  | • 이전에 처리한 이벤트에 다시 접근할 수 있다고 보장할 수 없는 경우<br>• 시스템의 상태 복구에 시간이 소요되어도 문제가 없는 경우                                                                           | • 저 자신, 고가용성 애플리케이션을 구현할 수 있음<br>• 중속 애플리케이션이 중복 이벤트를 처리하지 않도록 할 수 있음                          |

## 6.6 사용 기술
- 마이크로서비스 형태로 설계할 수도 있고, 스트림 프로세싱 시스템을 쓸 수도 있음
- 간단한 건 마이크로서비스로 개발해도 좋지만 복잡한 건 기존 기술을 쓰는 게 좋다
### 6.6.1 에스퍼
- GPL v2 라이센스를 따르는 이벤트 처리 라이브러리
- 자바나 닷넷 기반에서 스트림 처리 로직 구현할 때 사용

- 다양한 프로세싱 로직을 자체 제공해 복잡도를 낮출 수 있다
- 스트림 프로세싱 로직 설정을 위한 질의 언어도 지원
- 마이크로서비스 내에서 혹은 서버리스 기능으로 스트림 프로세싱 로직 구현할 때 쓰면 좋다

### 6.6.2 Siddhi
- 자바 기반 스트림 프로세싱 라이브러리 및 마이크로서비스
- 아파치 라이센스 2.0
- 라이브러리 형태로 에스퍼처럼 마이크로서비스와 함께 배포해서 스트림 프로세싱 로직 처리할 수 있음
- SQL을 통해 스트림 프로세싱 로직을 정의할 수 있고 변환, 필터링, 한계값, ~~ 다양한 구현 가능
- 마이크로서비스 또는 서버리스 형태로 스트림 프로세싱 로직 구현할 때 사용

- 주기적 상태 스냅숏 저장이나 이중화 노드 장애 극복 기능 패턴과 같은 신뢰성 패턴을 지원하는 독립적으로 실행 가능한 마이크로서비스 형태로 스트림 프로세싱 로직을 실행하고 싶다면 Siddhi를 사용할 수 있다.
- Siddhi 질의 언어로 어디에서 이벤트를 가져오고, 어떻게 처리하고, 어디로 발행할 것인지, 어떻게 배포할 것인지 설정할 수 있다.

### 6.6.3 ksqlDB
- 스트림 프로세싱 및 데이터베이스 시스템으로 카프카의 일부로 제공됨
- 분산 이벤트 처리를 위한 메시지 브로커로 카프카를 쓸 때 사용 가능
- 규칙을 정의해 카프카 스트림으로부터 이벤트를 읽어와서 처리하고 발행
- 변환, 필터링, 한계값, 윈도우드 애그리게이션, 조인 등 지원
- 구체화된 뷰 패턴도 적용할 수 있어 필요할 때마다 질의를 처리하는 것도 가능
    - 필요할 때마다 데이터를 가져올 수 있어서 관계형 DB처럼 모데링할 수 있어서 아주 유용하다
- 카프카를 쓸 때, 구체화된 뷰 패턴으로 이벤트 로그에 대한 질의 처리가 필요할 때 좋다

### 6.6.4 아파치 스파크
- 빅데이터, 스트림 프로세싱 플랫폼으로 아파치 라이센스 2.0
- Meos, 하둡 얀, 쿠머 환경에서 동작
- 배치 작업에서 강점을 보이지만 스트림 프로세싱 패턴도 지원

- 질의문, 구조적 프로그래밍 방식 모두 지원
- 자바, 스칼라, 파이썬 등의 언어로 스트림 처리 및 배치 작업 모두 구현 가능
- 주기적으로 스토어에 데이터를 백업해 신뢰성도 제공
- 주로 배치 작업을 처리하면서 가끔 스트림 처리를 해야한다면 좋은 선택지
### 6.6.5 아파치 플링크
- 완전한 형태의 스트림 프로세싱 플랫폼, 아파치 2.0
- 쿠버네티스, Knative, AWS lambda 등에서 실행 가능
- 여러 스트림 프로세싱 패턴 지원
- 이벤트 딱 한번만 처리 보장, 워터마크를 통한 데이터 프로세싱 지원, 스냅숏을 S3나 GCS, HDFS 같은 스토어에 저장해 신뢰성도 보장
- 간단한 질의 언어로 스트림 프로세싱 로직을 정의
- Table API를 제공해 선언적 데이터 처리가 가능
- 더 세부적인 구성을 위해 데이터 스트림 및 스트림 프로세싱 API를 자바로 제공
- 대규모 스트림 프로세싱 작업에 높은 확장성, 고가용성이 필요하다면 쓰면 좋다.

### 6.6.6 아마존 키네시스
- AWS에서 제공하는 확장 가능한 관리형 스트리밍 프로세싱 서비스
- SQL 또는 플링크 기반 데이터 프로세싱 지원
- 사용자가 고유한 클라우드 네이티브 애플리케이션 만들어서 아마존 람다나 EC2에서 실행도 가능
- SQL 모드에서는 변환, 필터링, 한계값, 윈도우드 애그리게이션, 조인 패턴 지원
- 플링크 모드에서는 모든 스트림 프로세싱 기능 지원
- 비디오 스트림 처리도 가능

### 6.6.7 애저 스트림 애널리틱스
- 확장 가능한 스트림 분석 플랫폼
- SQL 질의, GUI를 통한 스트림 프로세싱 로직정의
- 변환, 필터링, 한계값, 윈도우드 애그리게이션, 조인, 임시 이벤트 순차 정렬, 머신러닝 등
- 클라우드 환경과 에지 노드 모두에서 스트림 프로세싱 질의를 실행할 수 있는 하이브리드 구조도 지원

### 6.6.8 구글 데이터플로
- 구글이 제공하는 확장 가능한 스트림 프로세싱 플랫폼
- 아파치 빔 SDK, SQL 질의, GUI를 통해 스트림 프로세싱 로직 정의
- 아파치 빔 SDK를 쓰면 아파치 플링크와 같은 온프레미스 스트림 프로세싱 시스템에 스트림 프로세싱 로직을 구현하고 배포할 수 있음

### 6.6.9 스트림 프로세싱 기술 정리

| 스트림-프로세싱 기술  | 사용하면 좋은 경우                                                                                                                                     | 사용해서는 안 되는 경우                                                                                               |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| Esper        | • 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장할 경우<br>• 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인, 임시 이벤트 순차 정열 패턴을 사용하는 경우                                             | • 독립적인 애플리케이션으로 사용해야 할 경우<br>• 머신러닝 모델을 사용하는 경우<br>• 내장 신뢰성 기능이 필요한 경우                                      |
| Siddhi       | • 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장할 경우<br>• 독립적인 클라우드 네이티브 애플리케이션 형태로 사용할 경우<br>• 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인, 임시 이벤트 순차 정열, 머신러닝 패턴을 사용하는 경우 | • 높은 확장성이 요구되는 경우                                                                                           |
| ksqlDB       | • 인프라스트럭처에서 카프카를 사용하는 경우<br>• 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인 패턴을 사용하는 경우<br>• 임력 이벤트에 대해 구체화된 뷰 패턴을 적용해야 하는 경우                                    | • 인프라스트럭처에서 카프카를 사용하지 않는 경우<br>• 임시 이벤트 순차 정열 또는 머신러닝 패턴을 사용해야 하는 경우                                        |
| 0마치 스파크      | • 스트림 및 배치 프로세싱 둘 다 필요한 경우<br>• 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인, 머신러닝 패턴을 사용하는 경우                                                                  | • 스트림 프로세싱에 가벼운 시스템을 사용해야 하는 경우<br>• 임시 이벤트 순차 정열 패턴이 필요한 경우<br>• 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우 |
| 0마치 플링크      | • 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인, 임시 이벤트 순차 정열, 그래프 프로세싱이 필요한 경우<br>• 높은 확장성과 고가용성이 필요한 경우                                                        | • 스트림 프로세싱에 가벼운 시스템을 사용해야 하는 경우<br>• 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우                              |
| 아마존 키네시스     | • AWS에서 플랫폼을 사용하는 경우<br>• 변환, 필터와 한계잣, 윈도우 애그리게이션, 조인, 임시 이벤트 순차 정열, 그래프 프로세싱이 필요한 경우                                                          | • AWS가 아닌 다른 환경에서 실행하는 경우<br>• 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우                                    |
| 에지 스트림 애널리틱스 | • 변환, 필터와 한계잣, 조인, 임시 이벤트 순차 정열, 머신러닝 패턴을 사용하는 경우<br>• 스트림 프로세싱 질임을 클라우드 및 에지 노드 모두에서 실행해야 하는 경우                                               | • 에지차가 아닌 다른 환경에서 실행하는 경우<br>• 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우                                    |
| 구글 데이터플로우    | • 변환, 필터와 한계잣, 조인, 임시 이벤트 순차 정열, 머신러닝 패턴을 사용하는 경우<br>• 온프레미스 스트림 프로세싱 시스템에서 스트림 프로세싱 로직 실행이 가능해야 하는 경우                                         | • 구글 클라우드가 아닌 다른 환경에서 실행하는 경우<br>• 클라우드 네이티브 애플리케이션에 스트림 프로세싱 로직을 내장해야 하는 경우                                |

## 6.7 테스팅
- 전통적인 방식의 유닛 테스트, 통합 테스트 작성하는 게 좋음
- 비동기 방식으로 동작하므로 이벤트 주도 아키텍처에서 다룬 테스팅 방식을 함께 사용하는 것도 좋은 방법

- 애플리케이션 상태를 어떻게 다룰지가 중요하다
- 신뢰성 패턴을 사용한다면 장애 상황에서도 올바른 결과를 만들어내는지 테스트해봐야한다
- 상태를 미리 정의하고 테스트하기 위해서 워터마크 패턴을 사용해 각 테스트 마지막에 워터마크 이벤트 발행해서 상태 저장하고 이벤트 처리를 제대로 끝냈다는 사실을 확인할 수 있다.

- 윈도우드 애그리게이션이나 임시 이벤트 순차 정렬 패턴 등 시간 제한이 있는 패턴 테스트할 때는 네트워크 지연이나 상태 변동으로 인해 각 테스트 사이클별로 애플리케이션이 다른 결과 만들어낼 수도 있다
- 오차 범위내에 결과가 있는지 검증하는 게 아니라 이런 경우 애플리케이션을 수정해서 이벤트가 생성된 시각을 기준으로 이벤트를 처리하도록 하는 게 좋다
- 그러면 동일한 결과를 만들어낼 수 있다

## 6.8 보안
- 메시지 브로커 또는 다른 시스템과 안전한 연결 사용, 데이터 암호화
- 단, 애플리케이션 수준에서 보안 정책을 적용하는 게 불가능하다면 바운디드컨텍스트를 API로 제공하거나 메시지 브로커를 안전하게 만들고 이벤트를 소비
- 전체 스트림 프로세싱 시스템을 정의한 뒤 바운디드 컨텍스트 내에 포함시키기

## 6.9 관측 가능성 및 모니터링
- 상태 + 비동기로 적절한 모니터링 없으면 시스템 장애 전에 문제를 발견 못하는 경우도 많다

- 상태가 있으므로 메모리 소비 정도를 반드시 모니터링
- 5분 크기 윈도우가 있는데, 이벤트가 대량으로 발생하면 메모리가 부족해질 수도 있음
- 모니터링 + load shedding 등의 기술로 이런 상황을 막을 수 있음
- 물론 계속 다량으로 발생하면 스트림을 나누거나 재설계해서 부하를 견딜 수 있게 해야한다.

- 상태를 가지는 시스템은 주기적 상태 스냅숏 저장 패턴으로 상태 복구 가능
- 이 패턴을 사용할 때는 스냅숏들을 모니터링해서 제대로 저장되었는지, 오래된 스냅숏은 없는지 계속 확인해야 함
- 스냅숏이 크면 기록에도 오래 걸리고 이벤트 전달할 때 쓰는 대역폭에도 영향을 줄 수 있다
- 따라서 스냅숏 크기, 기록 시간, 네트워크 대역폭, CPU, 메모리 등 모니터링이 필요하다.

- 로직 문제나 네트워크 지연으로 순서가 바뀔 수 있다
- 처리하는 이벤트가 발생된 시각들을 모니터링해서 이를 미리 파악할 수 있다
- 이를 위해 버퍼 이벤트 순차 정렬, 오류 수정, 워터마크 패턴 등 사용

- 사건 ID 등을 사용해서 이벤트 추적하고 로그 남기면 운영 도중 문제가 생겼을 때 쉽게 해결할 수 있다

## 6.10 데브옵스
- 첫 단계는 적절한 신뢰성 패턴 고르는 것
- 패턴 고르면 빠르고 안전한 상태 저장 및 복구를 위한 상태 스토어 고르기
- 적절한 스냅숏 크기 + 저장 빈도 결정
- 스냅숏 저장으로 인한 지연 최소화가 핵심
- 데브옵스 일환으로 불필요하거나 중복된 스냅숏 모니터링 및 제거도 필요
- 스냅숏은 암호화

- 이벤트에 민감 정보 있으면 암호화 + 보호
- 이벤트나 스냅숏이 더 이상 필요없어지면 즉시 삭제
- 가능하면 바운디드 컨텍스트 사용해서 API나 메시지 브로커 토픽을 통해 전체 애플리케이션을 외부 위험으로부터 안전하게 보호

- 비동기는 문제 분석이 어려워 분산 추적, 로깅, 모니터링 등을 통해 적절한 관측 가능성,  모니터링 필요
- CI/CD도 아주 중요
- 매끄러운 배포를 위해 이벤트 스키마, 스냅숏에 대한 하위호환성 유지
- 많은 변화가 있는 경우 최신 애플리케이션이 안정화될 때까지 두 가지 버전의 애플리케이션 동시에 운영
- 개발, 검증, 운영 환경 등 여러 환경을 유지해 운영 환경에 대한 영향 최소화
