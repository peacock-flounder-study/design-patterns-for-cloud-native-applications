# 6. 스트림 프로세싱 패턴
이벤트를 그 때마다 분석해서 의미있는 정보를 추출하고 실시간으로 작업을 처리하는 데 중점
이벤트 주도 아키텍처 패턴에서 발전된 형태

### 스트림이란?
- 시간 순서에 따라 정렬된 일련의 연속적인 이벤트
  - 서로를 고유하게 구분할 수 있는 이름 및 버전으로 구성된 식별자를 가짐
  - stockstream과 같은 메시지 포맷 구조를 가지며 json 구성
- 스트림 프로세싱
  - 이벤트를 소비해서 다른 이벤트 포맷으로 변환하는 서비스나 메모리에 상태 데이터를 저장하고 처리하는 서비스
  - 이벤트가 생성된 순서대로 처리
  - 스트림 프로세싱의 경우 애플리케이션 무상태 또는 상태적인 특성이 설계에 큰 영향을 미침
 
### 스트림 데이터 프로세싱 패턴
- 실시간 이벤트들의 변환이나 필터링, 애그리게이션, 의미있는 연속적 이벤트 탐지 등 의미있는 결과를 도출하는데 중점을 두는 패턴.
- 성능 상으로 고려할 점은 영구 데이터 스토어를 많이 사용하지 않는 것임
    - 데이터 스토어에 접근하는 시간과 잠재적인 경합 등이 처리 지연시간에 영향을 줄 수 있음

**변환 패턴**
- 이벤트 소스 이벤트들을 변환하여 다른 포맷이나 구조, 프로토콜을 사용하는 다른 시스템에 발행하는 구조
    - 메시지를 서비스 버스나 아파치 카멜, KSQL, aws kinesis, 애저 스트림 애널리틱스 등을 통해 변환할 수도 있음.
    -   json 포맷의 이벤트를 택시 승하차 정보를 xml 로 만들어 데이터를 분석해야하는 경우
    -   <img width="527" height="297" alt="Screenshot 2025-11-20 at 7 37 25 PM" src="https://github.com/user-attachments/assets/0643835d-e986-4541-8269-4da6eaa23dfd" />

- 프로토콜 전환
  - 협력사나 서드파티와 함께 일하는 경우 서로 다른 메시지 브로커끼리 호환하기 위해 역직렬화/직렬화 할 수 있는 라이브러리를 사용
- 무상태 변환의 경우 애플리케이션 확장이 용이하나 상태를 저장하고 관리(예: 한 시간동안의 평균 기온을 계산하는 windowed aggregation pattern)해야하는 경우 수평확장이 어렵고 순차 수송 패턴을 사용하여 확장해야함

**필터와 한계값 패턴**

- 이벤트를 특정 조건 기준으로 거르거나 한계값 이내의 값을 가진 이벤트만 허용해야하는 경우
    - 문자열이나 정규표현식, 비교연산자 등으로 체크
    - 특정 유형의 이벤트를 걸러내거나 부정사용 탐지 등 경고알림을 위한 한계값 적용에 활용할수도 있음
- 현실적으로 모든 이벤트를 소화하기 어렵기 때문에 연관 이벤트만 걸러서 처리하고 부하를 줄일 수 있음

**windowed aggregation 패턴**

- 조건에 따른 이벤트 집합을 분석하는 패턴으로, sum,min,max,avg,cnt 등이 있으며 윈도우는 애그리게이션에 사용할 이벤트 집합을 정의함
    - 윈도우는 슬라이딩이나 배칭으로 동작
    - 그때마다 애그리게이션해서 비즈니스 결정사항을 수 초 내 만들 때 유용
    - 길이기반 슬라이딩/배치, 시간 기반 슬라이딩/배치 등 기본 윈도우 동작 방식과 윈도우가 동작하는 방식을 알고 있어야함
        - 시간 기반 슬라이딩 윈도우의 경우 마지막 1분간 발생한 이벤트만 처리
            - 윈도우에 이벤트가 추가되거나 제거될 때마다 애그리게이션 결과가 나옴
            - 1분 단위로 움직이는 슬라이딩 윈도우에 1초 간격의 인터벌을 지정하면 1초에 한번씩 윈도우가 움직여서 이전 이벤트들이 윈도우에 추가되고, 시간이 지난 이벤트는 제거됨
            - <img width="520" height="465" alt="Screenshot 2025-11-20 at 7 38 39 PM" src="https://github.com/user-attachments/assets/a7b1a5bf-61f6-4b25-97cb-a2409a44c647" />
        - 애그리게이션 작업은 어떤 윈도우에도 적용될 수 있으며 결과가 나오는 시점은 윈도우 유형에 따라 다름 (10개 size 배치는 매 10개 이벤트마다 나오고 5분 단위 1초 움직이는 슬라이딩 윈도우는 매 초마다 결과가 나오는 방식)
- windowed aggregation 패턴은 상태를 저장하므로 모니터링 분야와 같이 데이터가 일부 유실되어도 상관없는 경우 사용

- 시간 간격 별로 이벤트를 모을 때도 사용됨
    - 예 : 트랜잭션 부정 사용 탐지
    - 최근 10분 동안 발생한 트랜잭션 합계를 구해 상위 10명의 금액 사용자를 알아내는 방식
        - 10분 단위 윈도우를 1초 단위로 슬라이딩 간격을 지정하고, 윈도우에서는 트랜잭션 금액의 합을 사용자 별로 묶어 정렬하면 됨
        - <img width="544" height="155" alt="Screenshot 2025-11-20 at 7 40 09 PM" src="https://github.com/user-attachments/assets/48dcb8a8-c3ce-484f-9b57-ecb65cb90486" />

            
- 이벤트 개수가 중요한 경우는 길이 기반 슬라이딩 윈도우를 사용함
    - 예: 서버 측 세 번 연속 요청 거부되면 경고를 받는 경우
    - <img width="569" height="129" alt="Screenshot 2025-11-20 at 7 40 47 PM" src="https://github.com/user-attachments/assets/d4ba15ed-8403-4836-be5d-50d173196451" />
        
- 이 패턴의 경우 상태를 가지기 때문에 이벤트 유실이 발생하면 애그리게이션 결과의 무결성을 보장할 수 없음
    - 결과가 아주 중요하다면 신뢰할 수 있는 패턴을 함께 사용해서 시스템 장애나 재시작 때 상태를 다시 만들어 복구할 수 있어야함
- 또한 높은 정확도나 효율성 둘 다 만족하는 모든 종류의 애그리게이션을 만드는 건 불가능하다는 것도 유념해야함
<img width="627" height="198" alt="Screenshot 2025-11-20 at 7 40 58 PM" src="https://github.com/user-attachments/assets/f5c56ea6-18b4-47ab-b956-9a6ab40cd813" />


- 평균값과 달리 중앙값은 모든 이벤트를 검사해야하므로 공간이 많이 필요하여 애그리게이션을 처리하는 노드의 확장이 필요함
    - 확장성은 샤딩을 통해 이벤트를 나나누어 구현할 수 있음
- 다만 이 패턴은 바닥부터 구현하기엔 시간이 오래걸리므로 Esper나 Siddhi같은 스트림 처리 라이브러리나 프로세서를 사용하는 것이 좋음

**스트림 조인 패턴**

- SQL 테이블 조인 연산과 비슷하게 서로 다른 스키마를 가진 여러 스트림의 이벤트를 합칠 때 사용
- 합쳐야하는 이벤트를 식별하는 조건 정의가 필요함 (같은 id 값을 가진다거나)
    - 또한 얼마나 이벤트를 기다릴지에 대한 버퍼 정의도 필요함 (윈도우 버퍼)
- <img width="565" height="226" alt="Screenshot 2025-11-20 at 7 41 52 PM" src="https://github.com/user-attachments/assets/02931351-c13a-49d7-8052-ef7ca551b79e" />

        
- 버퍼에 합쳐야하는 이벤트를 저장하고 있기 때문에 스트림 조인 패턴도 상태가 있음
- 확산 및 조합
    - 같은 이벤트에 동시에 서로 다른 작업을 수행한 뒤 조합하면 단일 이벤트처럼 만들 수 있음
        - 예: 대출 애플리케이션 처리
        - 신용도 검사, 주소 검사, 신원정보 조회를 병렬로 작업하여 같은 대출 id를 가진 이벤트를 하나의 대출 이벤트로 합치기
- 여러 종류의 이벤트 조인
    - 예: 특정 트윗이 올라온 경우 관련 주식 가격을 알아내야하는 케이스
        - 윈도우를 사용하여 주가 스트림으로부터 최신 주식 가격을 모두 저장
        - ‘애플’ 트윗이 올라오면 윈도우에 저장된 주가 이벤트와 합쳐 처리
    - join 연산은 SQL과 유사하게 inner, left-outer, lite-outer, ful-outer 등을 사용
    - <img width="568" height="252" alt="Screenshot 2025-11-20 at 7 42 00 PM" src="https://github.com/user-attachments/assets/4ea292ec-1f91-432d-a6f8-e05028cf00a0" />

                
- join은 상태 관리가 필요하므로 신뢰성 패턴과 함께 사용해야함
    - 다만 확산과 조합의 경우는 각 이벤트들이 성공적으로 조합될 때까지 응답을 미룰 수 있으므로 메시지 브로커에서 필요할 때 이벤트를 가져올 수 있어 시스템 재시작이나 장애에도 이벤트 유실이 발생하지 않음

**임시적 이벤트 정렬 패턴**

- 스트림 프로세싱 분야에서만 사용하는 패턴으로, 이벤트가 도착하는 순서를 토대로 패턴을 분석하고 발생 여부를 탐지
- 애플리케이션 상태가 입력되는 이벤트와 현재 상태에 따라 바뀌는 패턴
    - <img width="571" height="172" alt="Screenshot 2025-11-20 at 7 42 09 PM" src="https://github.com/user-attachments/assets/055fdab9-5c00-43de-9c0a-5c42f18cba06" />         
    - 예: 주가가 상승하다 한 번 떨어지면 바로 알림
- 이 패턴은 또한 이벤트가 다른 이벤트 뒤에 순서대로 나오는지, 무작위로 나오는지도 알 수 있고, 타임아웃을 사용해 이벤트가 발생하지 않은 것도 감지할 수 있음
- 이벤트 순차 발생 탐지
    - 미리 정의한 순서대로 이벤트가 발생하는지 여부를 탐지
        - 예: 신용카드 사기 행위 탐지
        - 미국 내에 트랜잭션이 발생하고나서 외국에서 발생하는 경우 등
        - <img width="545" height="199" alt="Screenshot 2025-11-20 at 7 42 23 PM" src="https://github.com/user-attachments/assets/a22ea517-b521-4fcd-ab0e-a42bffe05b68" />
                
- 이벤트 미발생 탐지
    - 1분 동안 상태가 변경되지 않고 유지되는 경우 이벤트가 발생하지 않으면 감지
    - 상태가 변경되면 타이머를 중지하고 초기화
- 이벤트가 생성된 순서대로 전달되어야하므로 생성시간을 기록해야함
- 아파치 spark, flink, 에스퍼 등의 시스템을 사용


**머신러너 패턴**

- 데이터를 통한 실시간 예측과 자동화된 의사결정 구현에 머신러닝 모델을 사용
    - 미리 정의된 머신러닝 모델을 사용하거나
        - 아파치 스파크, 텐서플로, 파이썬 등으로 모델을 미리 만들어두면 PMML(predictive model makeup language)와 같은 기술을사용하여 질의를 통해 예측 결과를 생성할 수 있음
    - 온라인 머신러닝을 사용함
        - 정보 자체를 토대로 모델 스스로를 향상하는 모델로, 피드백을 통해 스스로 학습하기도 함
- 미리 정의된 머신러닝 모델은 충분한 데이터가 있으면 높은 정확도를 보이지만 최신 경향을 반영하지는 못함
- 온라인 머신러닝 모델은 정확도는 들쭉날쭉하나 새로운 데이터 반영이 빠름


---


### 확장성 및 성능 최적화 패턴

- 스트림을 처리하는 애플리케이션은 이벤트를 처리하는 동안에도 이벤트 순서를 지켜야하고, 대개 상태를 저장하므로 정확도를 해치지 않으면서 이벤트를 처리하는 확장 전략이 필요함

**순차 수송 패턴(sequential convoy pattern)**

- 이벤트를 다양한 분류로 나누고 병렬로 처리하는 방식으로 확장
- 또한 이벤트 순서를 영구 저장하므로 추후에도 순서가 보장됨
<img width="616" height="378" alt="Screenshot 2025-11-20 at 7 43 51 PM" src="https://github.com/user-attachments/assets/d8d134dc-10e0-455e-8ed4-2737a2f6266b" />


- 예: 고객 등급과 주문금액에 따라 물건 배송시간을 다르게 보장해주는 쇼핑몰
    - 이벤트 분리 전에 순번을 매겨서 스트림을 나누어 병렬처리할 때도 작업을 순서대로 할 수 있음
    -  <img width="581" height="240" alt="Screenshot 2025-11-20 at 7 43 59 PM" src="https://github.com/user-attachments/assets/0e78485a-9fc1-47d9-9752-e11d54683214" />
       
    - 이 순번을 가지고 이벤트를 다시 합칠 때도 순서대로 정렬할 수 있음
- 스트림 처리 애플리케이션 확장
    - 순차 수송 패턴으로 이벤트를 더 낮은 지연시간과 높은 throughput으로 처리할 수 있게 해줌
    - <img width="563" height="199" alt="Screenshot 2025-11-20 at 7 44 05 PM" src="https://github.com/user-attachments/assets/ffe7002f-1f00-4585-92b0-1f95d711b85b" />        
    - 각 이벤트를 고객 ID의 해시 값에 기반해서 여러 하위 스트림으로 나누고, 같은 고객 ID 이벤트는 같은 msa 서비스에서 처리하게하면 캐시 적중률을 높여 데이터 스토어 검색이 추가되는 등 처리 시간에 영향을 주는 기능이 있어도 지연시간을 줄일 수 있음.
- 스트림 처리 분할
    - 이벤트 스트림을 유형별로 나누고 병렬로 서로 다른 작업을 처리할 수 있음
- 다만 의미있는 스트림 처리를 위해서는 이벤트 속성 값에 따라 이벤트를 분류할 수 있어야함
    - 이벤트를 여러개로 나누면 이벤트가 필터링되거나 삭제되어 이벤트 순번이 연속적이지 않을 수 있음
    - 들어오는 이벤트 순번을 확인하고 어떤 이벤트가 제거되었는지 체크하는 방법도 필요
        - 이벤트를 다시 합치는 더 좋은 방법은 주기적으로 가장 마지막으로 처리한 이벤트 ID 를 보내는 것임
    - 순번으로 이벤트를 합칠 수 없으면 이벤트를 단일 토픽으로 다시 발행하는 방법도 있음

**버퍼 이벤트 순차 정렬 패턴**

- 네트워크 지연이나 retry 등으로 인해 순서에 맞지않게 도착하면 해당 패턴으로 이벤트를 정렬할 수 있음
- 순차적으로 증가하는 값을 사용하여 고유 순번을 매겨야함
<img width="568" height="140" alt="Screenshot 2025-11-20 at 7 44 19 PM" src="https://github.com/user-attachments/assets/9f497545-ce84-438a-bc8b-b37ab662a63c" />          
- 이벤트 시각 기준으로 하면 중복이 발생할 수 있어 고유한 방식으로 최적화하기 어려움
    - 마지막으로 전달받은 시각과 타임아웃 값으로 이벤트를 정렬하는 게 일반적임
- 만약 순서에서 벗어난 이벤트를 탐지하면 timeout 시간을 조절해서 문제가 발생할 소지를 줄여야함
    - 700s인 이벤트를 전달받고 난 다음 시각값이 650s면 타임아웃 값은 최소 50s로 재조정하는 방식 (K-slack, AQ-K slack 알고리즘)
 

**오류 수정 패턴**
**워터마크 패턴**

**신뢰성 패턴**
**재생 패턴**
**주기적 상태 스냅숏 저장 패턴**
**이중화 노드 장애 극복 기능 패턴**

### 사용 기술들

에스퍼
Siddhi
ksqlDB
아파치 스파크 
아파치 플링크
아마존 키네시스
애저 스트림 애널리틱스
구글 데이터 플로

### 테스팅 / 보안 / 
### 관측 가능성 및 모니터링 / 데브옵스


