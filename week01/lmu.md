# Chapter 1. 클라우드 네이티브 어플리케이션이란?
## 1.1. 클라우드 네이티브의 개념
- CNCF에서 제시한 개념
	- 클라우드 네이티브 기술은 퍼블릭, 프라이빗, 하이브리드 클라우드와 같은 실행 환경에서 그 크기를 자유롭게 조절할 수 있는 어플리케이션을 만들고 실행할수 있는 능력을 제공해준다. 컨테이너, 서비스 메시, 마이크로서비스, 불변 인프라스트럭쳐 선언적 API를 활용하여 구현할수 있다. 이 기술들을 통해 관리와 관찰이 쉽고 탈력성있는 느슨하게 결합된 시스템을 만들수 있다. 강력한 자동화와 더불어 엔지니어들이 최소한의 노력으로 많은 영향을 미칠 수 있는 변경 작업을 더 자주 할 수 있도록 만들어준다.

### 1.1.1. 마이크로서비스로 구성하는 설계
- 마이크로서비스
- 서비스 지향 아키텍쳐: Service-Oriented Architecture (SOA)
	- 특정 비지니스 기능을 지원하는 서비스를 조합하여 소프트웨어 어플리케이션을 만드는 모듈성 개념을 선보였다.
	- 복잡한 표준과 메시지를 사용하였고, 중앙 집중화된 모놀리식 컴포넌트를 아키텍쳐에 포함했다.
	- ESB (엔터프라이즈 서비스 버스)로 알려진 중앙 집중형 모놀리식 통합 계층을 사용해 하나로 묶는다.
	- 대표적으로 간단한 온라인 쇼핑몰
- 마이크로서비스는 외부 시스템과 연결하거나 또는 파사드라 불리는 간단한 인터페이스를 제공한다.
- 마이크로서비스는 데이터 베이스를 함께 사용하지 않으며, 외부에서는 오직 서비스 인터페이스를 통해서만 데이터에 접근할 수 있다.

#### 개인 생각
- 마이크로서비스를 띄우는 식으로만 나오는데 어려운점이 있다. 
- 실제로 현재 운영하는 어플리케이션중 일부는 디비를 쉐어하는데, 이는 성능과 직결되어 있다.
- DB에서는 비용이 매우 가볍더라도 API로는 매우 어려울수 있다.
	- 예를 틀어 디비 전체에서 특정 조건을 만족하는 데이터의 개수를 찾아서 메트릭으로 변환하여 대시보드를 구성하는 컴포넌트가 있다고 하면, 이를 마이크로서비스로만 만들려면, API서버를 통해서 특정 조건의 개수를 구하는 것을 짜고, 이 API를 통해서 데이터를 가져와서 메트릭화 해야하는데 현실적으로 개발비용이 있다.
		- 물론 API로 만들어둔다면 나중에 메트릭을 신뢰하지 못할 경우 API를 직접 쳐보면서 조회할수 있지만, 이는 DB 쿼리로 해봐도 동일하다.

### 1.1.2. 컨테이너와 컨테이너 오케스트레이션
- 컨테이너란?
	- 컨테이너 레지스트리
	- 컨테이너 인스턴스
	- VM은 hypervisor
	- VM보다 가볍다.
- 왜 컨테이너 오케스트레이션이 필요한가?
	- 제공해주는 기능
		- 자동화된 프로비저닝: 자동으로 컨테이너 인스턴스를 생성하고 배포한다.
		- 고가용성: 컨테이너가 실행 도중 중단될 경우 자동으로 컨테이너 인스턴스를 다시 생성한다.
		- 크기 조절: 요구 조건에 따라 컨테이너 인스턴스 수를 늘리거나 줄여서 어플리케이션 크기를 조절한다.
		- 자원 관리: 컨테이너에 적절한 자원을 할당해준다.
		- 서비스 인터페이스 및 부하 분산: 컨테이너를 외부 시스템에서도 접근할 수 있도록 만들어주며 시스템에 주어지는 부하를 컨테이너에 고루 분산합니다.
		- 기저 네트워크 추상화: 오버레이 네트워크를 제공하여 컨테이너 간 통신을 가능하게 한다.
		- 서비스 검색: 서비스 이름으로 서비스를 찾을 수 있는 내장 기능을 제공한다.
		- 컨트롤 플레인: 컨테이너 시스템을 관리하고 모니터링할 수 있는 시스템을 제공한다.
		- 어피니티: 필요에 따라 컨테이너를 가까이, 또는 서로 멀리 배치함으로써 가용성 또는 목표 성능을 달성할 수 있도록 한다.
		- 상태 모니터링: 오류나 실행 중단을 자동으로 탐지하고 스스로 복구할 수 있도록 만든다.
		- 롤링 업그레이드: 시스템을 중단하지 않고도 컨테이너들을 점진적으로 업그레이드할 수 있다.
		- 요소화 및 격리: 네임스페이스와 같은 논리적 구분 방법을 제공하여 여러 어플리케이션 도메인을 요소화하고 서로 격리한다.
- 쿠버네티스
	- 어플리케이션 구조를 표준화한다.
	- Pod는 기본 단위
	- service 부하분산
	- replicaset 지정한 파드수를 정의 관리
	- Deployment는 어플리케이션에 대한 변경사항을 처리하고 반영
- 서버리스
- 가상 머신

### 1.1.3. 개발 라이프사이클을 자동화하기
- 자동화: 개발 라이프사이클에서 수동으로 직접하는 것들을 자동화하는 것
	- 통합테스트, 빌드, 릴리즈, 설정 관리, 인프라스트럭쳐 관리, 지속적 동합, 지속적 전달/배포
- CI를 제일 먼저, CD, CD를 하면서 설정관리
- 여러 실행 환경을 구성할떄 코드형 인프라스트럭쳐

### 1.1.4. 동적 관리
- 오토스케일링: 어플리케이션 인스턴스 크기나 수를 트래픽이나 부하 등에 따라 늘리거나 줄인다.
- 고가용성: 오류나 실행 중단 등의 이상을 감지할 경우 현재 어플리케이션 인스턴스가 실행되고 있던 데이터 센터에 새로운 인스턴스를 만들거나 다른 데이터 센터로 트래픽을 보낸다.
- 자원 최적화: 고정된 비용을 미리 지불하는 방식이 아닌, 실시간 요구에 따라 동적으로 크기를 조절하고 비용 등을 청구하는 방법으로 자원을 최적으로 사용한다.
- 관측 가능성: 로그, 메트릭 등의 클라우드 네이티브 어플리케이션 정보를 중앙에서 수잡하고 제공한다.
- 서비스 품질: 단말 간 부안, 스로틀링, 규정 및 정책 준수, 버전 관리 등
- 중앙 컨트롤 플레인: 클라우드 네이티브 어플리케이션의 모든 부분을 관리할 수 있는 중앙화된 제어 방법을 제공한다.
- 자원 프로비저닝: 어플리케이션별 CPU, 메모리, 스토리지, 네트워크 등의 자원을 할당하고 관리한다.
- 멀티클라우드 지원

## 1.2. 클라우드 네이티브 어플리케이션 개발 방법론
- Twelve-Factor app 개발 방법론은 현실과 맞지 않는 부분이 있다. 특히 개발 주기가 일치하지 않는 부분이 있다.

### 1.2.1. 어플리케이션 설계
- 바운디드 컨텍스트
- 각각의 바운디드 컨텍스트는 마이크로서비스와 1:1 대응 할수도 아닐수도 있다.

### 1.2.2. 어플리케이션 개발
- 독립 코드베이스
- 명시적 의존성
	- 마이크로서비스 코드 수준의 의존성은 반드시 명시적으로 선언해야하며, 다른 서비스들의 의존성과는 별도로 구분해서 관리해야한다.
	- 비 명시적으로 시스템 수준의 라이브러리나 요소 등에 의존해서는 안된다.
- 별도의 설정 관리
	- 단일 코드베이스에 작성한 클라우드 네이티브 어플리케이션은 다양한 환경에 배포할수 있다. 따라서 마이크로서비스 코드와 완전히 별개로 설정이 존재해야한다.
- 독립 테스트
	- 단위 테스트
	- 통합 테스트
- 컨테이너화
	- 컨테이너화가 필수는 아니지만, 컨테이너화를 통해 대부분의 특성과 요구사항을 더 쉽게 구현할수 있다.
	- 컨테이너가 마이크로서비스 코드를 불변으로 만들어 준다.

### 1.2.3. 연결성 및 구성, 그리고 API
- 서비스 주도 상호작용
	- 서비스는 추상화를 통해서 마이크로서비스 간 상호작용을 더 쉽고 편하게 만들어준다.
	- 서비스 메타 정보를 스토어와 레지스트리에 보관할 수 있다.
	- 서비스 오브젝트
- 서비스 간 통신 및 조합
	- 비지니스가 아닌 요소들을 구현
		- 어플리케이션 수준의 보안
		- 회로 차단기, 타임아웃과 백오프등 탄력적 통신
		- 라우팅
		- 메트릭 수집 및 보고
		- 관측 가능성 수집 도구에 정보 전송
- 관리형 API로 기능들을 외부에 제공하기
	- 특정 기능을 관리형 API로 제공하여야한다.
	- API 게이트웨이는 제공하는 기능들에 접근할 수 있는 진입로 역할을 담당하고, 개발자 포털은 API를 둘러싼 생태계 조성에 꼭 필요한 기능이다.

### 1.2.4. 개발, 릴리스, 배포 자동화
- 클라우드 네이티브 어플리케이션을 만드는 과정에서 개발, 릴리스, 배포 또는 전달 과정을 가능화 자동화해야한다.

### 1.2.5. 동적 환경에서 실행
- 어플리케이션이 실행 환경과는 완전히 독립적이며, 개발이나 검증, 운영과 같은 다양한 환경에서 어플리케이션 코드 수정 없이 실행이 가능해야 한다.
	- 로컬, 퍼블릭, 하이브리드, 프라이빗, 멀티 클라우등
- 쿠버네티스를 범용으로 사용할 경우에는, 컨테이너 프로비저닝, 자원 관리, 불변성, 오토스케일링과 같은 동적 환경의 특성을 쿠버네티스가 제공하는 기능만으로 구현할 수 있다.
- 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼은 기본적으로 Stateless process로 간주하고 실행한다.

### 1.2.6. 동적 환경 관리를 위한 컨트롤 플레인
- REST나 RPC API로 제공된다.

### 1.2.7. 관측 가능성 및 모니터링
- 관측가능성: 새로운 코드를 실행하지 않고도 어플리케이션의 상태를 이해하고 설명할 수 있는 능력
- 트러블슈팅, 트랜잭션 기록, 이상 징후 탐지, 비지니스 패턴 식별, 어플리케이션에 대한 통찰력 획득
- 로깅, 메트릭 수집, 추적, 서비스 가상화 등


## 1.3. 클라우드 네이티브 어플리케이션 디자인 패턴
- 클라우드 네이티브 어플리케이션을 만드는 업계에서는 어플리케이션 배포와 전달에 주로 집중하고 있지만, 비지니스 로직을 만들고 통신 패턴을 사용해서 클라우드 네이티브 어플리케이션을 연결하고 구성하는 부분을 별로 신경 쓰지 않는 경향이 있다.

### 1.3.1. 통신 패턴
- 동기 통신
	- request-response
	- rpc
- 비동기 통신
	- message queue
	- publisher-subscriber

### 1.3.2. 연결성 및 조합 패턴
- 연결성: 서비스 간 믿을 수 있고, 안전하며, 찾기 쉽고 관리가 편하며 관측 가능성이 뛰어난 통신 매체
- 조합: 여러 서비스나 시스템을 연결 또는 통합하여 새로운 서비스를 만드는 것


### 1.3.3. 데이터 관리 패턴
- 클라우드 네이티브 어플리케이션은 기본적으로 분산 구조이다.
- 전통적인 모놀리식 어플리케이션에서는 중앙화된 공유 데이터 스토어를 여러 어플리케이션이 함께 사용한다.

### 1.3.4. 이벤트 주도 아키텍처 패턴
- 이벤트 주도 아키텍쳐 (event-driven architecture)

### 1.3.5. 스트림 프로세싱 패턴
- 스트림은 서로 밀접한 관계를 가지며 시간에 따라 지속적으로 유입되는 일련의 이벤트나 데이터들
- 스트림 프로세싱: 스트림을 생산하거나 처리하는 어플리케이션 로직

### 1.3.6. API 관리 및 사용 패턴
