```toc
```

## 1.1 클라우드 네이티브의 개념
- 클라우드 네이티브 아키텍처는 애플리케이션을 만들고 제공하고 관리하는 방법을 크게 바꿨음
- 덕분에 민첩성, 속도, 안정성, 적응성을 가짐

- 클라우드 네이티브의 일반적인 정의는 뭘까?
	- 없다~
	- 사람이나 기관마다 다 다르다
- 그나마 일반적인 정의에 가까운 건 CNCF가 내세운 것
	- 퍼블릭, 프라이빗, 하이브리드 클라우드와 같은 실행 환경에서 그 크기를 자유롭게 조절할 수 있는 애플리케이션을 만들고 실행할 수 있는 능력을 제공
	- 컨테이너, 서비스 메시, MSA, 불변 인프라스트럭처, 선언적 API 등을 활용
	- 덕분에 관리와 관찰이 쉽고 탄력성있는 느슨하게 결합된 시스템을 만들 수 있음
	- 강력한 자동화와 더불어 엔지니어들이 최소한의 노력으로 많은 영향을 미칠 수 있는 변경 작업을 더 자주 할 수 있게 해줌

- [Immutable Infrastructure란 무엇인가? - CNF](https://www.cncf.co.kr/blog/immutable-infrastructure/)
	- 시스템 구성 변경 없이 새 이미지 배포
	- 한 번 배포된 인프라 구성요소는 운영 중에 절대 변경되지 않는다는 원칙에 기반한 인프라 관리

> 클라우드 네이티브란 퍼블릭이나 프라이빗, 하이브리드, 멀티 클라우드와 같은 환경에서 실행할 수 있는 독립적인 비즈니스 기능 중심의 마이크로서비스들을 느슨하게 결합하여, 크기 조절이 가 능하고 탄력적이며 관리와 관찰이 용이한 자동화된 소프트웨어 애플리케이션을 만드는 것을 의미 한다.

### 1.1.1 마이크로서비스로 구성하는 설계
- 클라우드 네이티브 애플리케이션은 독립적으로 만들어진 서비스들을 느슨하게 결합하는 것으로 설계됨
- 클라우드 네이티브 애플리케이션에서 MS는 없어서는 안 될 필수 요소
- MSA 모르고 클라우드 네이티브 애플리케이션을 만든다는 것은 불가능에 가까움

- MSA는 소프트웨어 애플리케이션을 만드는 방법
- 그 전에는 모놀리식 애플리케이션을 많이 만들어왔는데 근본적으로 복잡하고 크기 조절이 어렵고 유지보수 비용이 많이 들고 개발의 민첩성이 떨어짐
- 모놀리식 애플리케이션은 다른 모놀리식 애플리케이션과 전용 프로토콜을 사용하며 통신하고, 단일 DB 함께 쓰는 경우가 많음

- SOA(Service-Oriented Architecture)는 기존 모놀리식 애플리케이션 아키텍처의 한계를 해결할 수 있는 더 나은 아키텍처로 부각됨
- 특정 비즈니스 기능을 지원하는 서비스를 조합해 소프트웨어 애플리케이션을 만드는 모듈성 개념을 선보임
- 복잡한 표준과 메시지 포맷을 사용, 중앙 집중화된 모놀리식 컴포넌트를 아키텍처에 포함

- SOA 기반 애플리케이션은 웹 서비스와 같이 여러 서비스를 만들고 개방형 표준과 ESB(Enterprise Service Bus)로 알려진 중앙 집중형 모놀리식 통합 계층을 사용해 묶었다
- API 관리 계층을 두고 소프트웨어 애플리케이션에서 제공하는 기능을 API로 제공

![](files/Pasted%20image%2020250906153706.png)

- 많은 엔터프라이즈 시스템이 이런 구조로 설계되고 만들어짐
- 이 역시 근본적인 복잡성과 한계 때문에 민첩성이 떨어지고 크기 조절이 어렵고
- 내부 의존성 때문에 서비스를 독립적으로 개발하고 배포하기 어려움
- 중앙 집중화 형태라 신뢰성도 떨어지고 여러 기술을 동시에 사용하는 것도 어려움

- 다만 MSA는 좀 더 잘 만들어진 비즈니스 중심의 서비스 도입, ESB 같은 중앙화 컴포넌트 제거 -> SOA 한계를 뛰어넘음
- 비즈니스 핵심 기능을 구현한 독립적인 서비스들로 구성됨
- 각 서비스는 개별 팀에서 독립적으로 개발하고 배포하고 관리

![](files/Pasted%20image%2020250906154539.png)

- ESB 대신 MSA는 서로 알아서 통신
- 이런 통신 기능은 MS 구현에 꼭 필요
- 따라서 MSA를 일컬어 잘 정의된 엔드포인트들을 단순한 연결 수단으로 연결했다고 표현하기도 함
- MS는 외부 시스템과 연결하거나 다른 시스템에서 사용할 수 있는 파사드라 불리는 간단한 인터페이스를 제공하기도 함

- MS는 DB 같이 사용 안 하고 오직 서비스 인터페이스를 통해서만 데이터에 접근
- 각 MS는 탄력성과 보안성 등 수많은 기본 요건을 충족시킬 수 있는 서비스 간 통신 기능과 비즈니스 로직을 구현해야 함
- 클라우드 네이티브 애플리케이션이 MS 조합으로 만들어지다 보니 MS 아키텍처에 적용되는 대부분의 개념이 클라우드 네이티브에도 동일하게 적용됨

### 1.1.2 컨테이너와 컨테이너 오케스트레이션

#### 컨테이너란?
- 컨테이너는 컨테이너 전용 파일 시스템을 통해 컨테이너 이미지를 제공받음
- 컨테이너 이미지는 애플리케이션 코드와 의존성 라이브러리, 실행 환경 등 애플리케이션 실행에 필요한 모든 것을 가지고 있는 이진 데이터
- 수정이 불가능하며, 컨테이너 레지스트리라는 스토어에 주로 보관
- 컨테이너는 컨테이너 이미지를 통해 컨테이너 인스턴스라고 불리는 프로세스를 만들어서 실행
- 컨테이너 인스턴스는 컨테이너 런타임 엔진에서 실행됨

- VM은 하이퍼바이저를 통해 호스트의 CPU나 메모리 같은 컴퓨팅 자원을 사용해 게스트 운영체제를 실행
- 하지만 컨테이너는 컨테이너 런타임 엔진에서 실행하며, 호스트의 커널, 프로세서, 메모리를 다른 컨테이너와 함께 사용
- 훨씬 가벼우면서도 분리된 프로세스 환경

![](files/Pasted%20image%2020250906154928.png)

- 애플리케이션을 컨테이너 환경에서 실행할 수 있도록 만드는 것을 컨테이너화라고 부름
- 컨테이너는 마이크로서비스를 캡슐화하여 독립적이고 자율적인 서비스로 만드는 핵심 기술
- 컨테이너화된 마이크로서비스는 다른 마이크로서비스를 전혀 방해하지 않고 다른 서비스로 대체되거나 업그레이드될 수 있음
- VM에 비해 효율적이고 훨씬 가볍고, 불필요한 실행 환경 설정 등을 제거할 수 있음

- 그렇다면 컨테이너 라이프사이클은 어떻게 관리? -> 컨테이너 오케스트레이션
#### 왜 컨테이너 오케스트레이션이 필요한가?
- 각 컨테이너를 수동으로 직접 관리하는 건 불가능에 가까움
- 그래서 컨테이너 오케스트레이션이 필요함
	- 자동화된 프로비저닝
		- 자동으로 컨테이너 인스턴스 생성하고 배포
	- 고가용성
		- 컨테이너가 실행 도중 중단될 경우 자동으로 컨테이너 인스턴스를 다시 생성
	- 크기 조절
		- 요구 조건에 따라 컨테이너 인스턴스 수를 늘리거나 줄여서 애플리케이션 크기를 조절
	- 자원 관리
		- 컨테이너에 적절한 자원 할당
	- 서비스 인터페이스 및 부하 분산
		- 컨테이너를 외부 시스템에서도 접근할 수 있게 해줌
		- 서비스에 주어지는 부하를 여러 컨테이너에 고루 분산
	- 기저 네트워크 추상화
		- 오버레이 네트워크를 제공해 컨테이너 간 통신이 가능하게 만들어줌
	- 서비스 검색
		- 서비스 이름으로 서비스를 찾을 수 있는 내장 기능을 제공
	- 컨트롤 플레인
		- 컨테이너 시스템을 관리하고 모니터링할 수 있는 시스템을 제공
	- 어피니티
		- 필요에 따라 컨테이너를 가까이 또는 서로 멀리 배치해 가용성 또는 목표 성능 달성에 도움
	- 상태 모니터링
		- 오류나 실행 중단을 자동으로 탐지하고 스스로 복구
	- 롤링 업그레이드
		- 시스템을 중단하지 않고 컨테이너를 점진적으로 업그레이드
	- 요소화 및 격리
		- 네임스페이스 등 논리적인 구분 방법을 제공해 여러 애플리케이션 도메인을 요소화하고 격리

#### 쿠버네티스
- 자동화된 배포, 크기 조절, 장애 복구, 네트워크 등 컨테이너 관리에 필요한 수많은 기능을 제공해 컨테이너들을 쉽게 관리할 수 있는 추상화된 계층 제공
- 애플리케이션 워크로드를 이식이 쉽고 크기 조절이 자유롭고 확장이 쉽도록 만들어줌

![](files/Pasted%20image%2020250906155857.png)

- 쿠버 클러스터는 실제 물리적 서버 또는 가상 머신들로 노드를 구성
- 노드들 중 적어도 하나는 컨트롤 플레인 노드가 되어야 함. 그 외에 여러 워커 노드가 있음
- 컨트롤 플레인 노드는 애플리케이션 인스턴스를 스케줄링하고 관리
- 쿠버 관리하는 노드를 쿠버 컨트롤 플레인이라고 지칭

- 쿠버 API 서버는 컨트롤 플레인 노드들과 워커 노드들 사이의 모든 통신을 도맡음
- 특정 애플리케이션 워크로드가 워커 노드에서 실행되어야하는 경우 쿠버 스케줄러가 각 워커 노드의 가용 자원과 정책을 고려해 워크로드에 적당한 노드를 지정
- 각 쿠버 노드에는 노드 상태를 관리하는 `kubelet`이라는 에이전트가 실행됨
- `kubelet`은 쿠버 API 서버와 직접 통신해 해야 할 일을 전달받고 현재 노드의 상태를 알려줌

- pod은 주어진 노드에서 실행되는 애플리케이션 실행환경을 의미하는 가장 기본적인 배포 단위
- 하나의 파드에서 한 개 이상의 컨테이너를 실행
- 각 파드는 쿠버 클러스터 내에 고유한 IP 주소 할당 받음

- 그 외에 서비스, Deployment, ReplicaSet 등 여러 추상화 요소로 배포와 관리가 쉽게 만들어줌
- 서비스는 여러 pod을 하나의 네트워크 서비스로 묶어주고
- 레플리카셋은 파드 수를 지정하고 관리
- Deployment는 애플리케이션에 대한 변경 사항을 처리하고 이를 레플리카셋이나 파드에 반영

#### 서버리스
- 특정 MS는 서버리스로 구현 가능
- 서버리스 플랫폼에서 동작하며, 필요한 관리 기능, 네트워크, 탄력성, 확장성, 보안 등의 요소를 제공
- AWS Lambda나 Azure Function, Google Cloud Function 등
- 부하에 따라 자동으로 인스턴스 크기를 조절, 여러 프로그래밍 언어를 지원, 탄력적인 네트워크, 보안성, 관측 가능성 등

- 특정 시간에 부하가 몰리거나 배치 작업을 처리하는 경우, 이벤트 드리븐 아키텍처 등에서 적합

- 서버리스 플랫폼을 쓰면 실제로는 컨테이너로 실행되지만 개발자는 이를 알지 못함
- 비즈니스 로직만 구현하고 서버리스 플랫폼에 전달하면 됨

#### 가상 머신
- 컨테이너 없이 MS를 실행할 수도 있음
- 반드시 컨테이너를 써야하는 건 아니지만 컨테이너를 쓰지 않으면 VM에서 실행하므로 실행 및 관리가 더 복잡해짐

### 1.1.3 개발 라이프사이클을 자동화하기
![](files/Pasted%20image%2020250906160940.png)

- 클라우드 네이티브 애플리케이션 배포할 때 무엇보다 중요한 건 민첩성, 속도 그리고 안전성
- 클라우드 네이티브 애플리케이션의 개발 라이프사이클을 훑어보고 각 단계를 자동화해보자

- 통합 테스트, 빌드, 릴리스, 설정 관리, 인프라스트럭쳐 관리, CI/CD 등

- 코드를 푸시하면 CI 단계 시작
- 코드 빌드, 테스트, 문제가 없으면 바이너리 형태로 패키징
- CI 도구는 변경된 코드에 대해 애플리케이션 빌드하고, 자동으로 단위 테스트 실행 후 발견한 오류들을 표시

- 빌드 결과물을 각각 다른 환경에 배포하는 상황에서 CD 단계가 등장
- 설정 관리 도구를 통해 각 환경에 알맞게 빌드한 결과물을 골라서 해당 설정과 잘 맞는 환경에 배포
- 배포하기 전에 여러 테스트를 병렬로 실행하기도 함
- 배포를 자동화할 수도 있고, 승인 과정을 거쳐 수동으로 하기도 함

- 승인을 통한 수동 배포를 지속적 전달이라고 지칭
- 지속적 배포는 승인이나 수동 작업 없이 변경된 코드를 자동으로 배포

- 여러 환경 구성할 때 IaC 주로 사용
- 수동으로 인프라를 구성하지 않고 명세만으로 필요한 환경 찍어낼 수 있음
- 여러 환경 일관성 쉽게 유지하면서, 빠르고 효율적으로 유지 가능. 관리 부담 줄어든다

- 쿠버 등의 플랫폼에서 reconciliation loop 통해서 배포 상태 관리
- 사람 개입 없이 배포 상태를 알아서 관리하고 유지

### 1.1.4 동적 관리
- 오토스케일링
	- 애플리케이션 인스턴스 크기나 수를 트래픽이나 부하 등에 따라 늘리거나 줄이기
- 고가용성
	- 오류나 실행 중단 등 이상이 생긴 경우 새로운 인스턴스를 만들거나 다른 데이터 센터로 트래픽 보냄
- 자원 최적화
	- 고정된 비용을 미리 지불하지 않고 실시간 요구에 따라 동적으로 크기 조절, 비용 청구
- 관측 가능성
	- 로그, 메트릭 등을 중앙에서 수집하고 제공
- 서비스 품질
	- e2e 보안, 스로틀링, 규정 및 정책 준수(Compliancy), 버전 관리
- 중앙 컨트롤 플레인
	- 모든 부분을 관리할 수 있는 중앙화된 제어 방법 제공
- 자원 프로비저닝
	- 애플리케이션별 CPU, 메모리, 스토리지, 네트워크 등의 자원 할당 및 관리
- 멀티클라우드 지원
	- 프라이빗, 퍼블릭, 하이브리드 등 여러 클라우드 환경에서 애플리케이션 실행하고 관리할 수 있는 기능 제공


## 1.2 클라우드 네이티브 애플리케이션 개발 방법론
- 몇몇 사람들은 [Twelve-Factor app 개발 방법론](https://12factor.net/)이 최고라고 이야기함
	- [AWS 클라이드 네이티브 기반 Twelve Factor 앱 개발 방법 \| Amazon Web Services 한국 블로그](https://aws.amazon.com/ko/blogs/korea/twelve-factor-app-on-cloud-native/)
- 하지만 이는 현실적인 개발과 몇 가지 부분에서 잘 맞지 않음
- 개발주기와 일치하지 않는 부분이 있었음
- 그래서 좀 더 완전하고 정형화된 방법론을 만들었다

기존 12 factor

1. Codebase
	- One codebase tracked in revision control, many deploys
2. Dependencies
	- Explicitly declare and isolate dependencies
3. Config
	- Store config in the environment
4. Backing services
	- Treat backing services as attached resources
 5. Build, release, run
	- Strictly separate build and run stages
 6. Processes
	- Execute the app as one or more stateless processes
 7. Port binding
	- Export services via port binding
 8. Concurrency
	- Scale out via the process model
 9. Disposability
	- Maximize robustness with fast startup and graceful shutdown
 10. Dev/prod parity
	- Keep development, staging, and production as similar as possible
 11. Logs
	- Treat logs as event streams
12. Admin processes
	- Run admin/management tasks as one-off processes

![](files/Pasted%20image%2020250906165607.png)

### 1.2.1 애플리케이션 설계
- 바로 애플리케이션 개발할 수가 없음
- 설계 과정에서 비즈니스 핵심 기능과 외부 의존성 관계 등을 파악해야 함
- 설계 단계에서 비즈니스 기능을 사용 사례별로 자세히 관찰하고 만들고자 하는 MS를 정확히 파악
- DDD 등을 쓸 수도 있음

- DDD는 비즈니스 분야를 파악하고 해당 도메인 내에서 특정 도메인 모델을 적용할 수 있는 경계를 나눔
- 이를 Bounded Context라고 부름
- 각 Bounded Context는 MS와 1:1로 대응할 수도 있고 아닐 수도 있음
- 일반적으로 Bounded Context별로 서비스를 만들고 설계를 진행하면서 애그리게이트 단위로 서비스를 더 잘게 쪼개는 경향이 있음
- 이후에 MS를 정의하고 서비스에 대한 정의, 인터페이스, 통신 방식 결정
### 1.2.2 애플리케이션 개발
#### 독립 코드베이스
- 각 마이크로서비스는 버전 관리 시스템 기반 코드베이스를 가져야 함
- 환경마다 같은 코드베이스를 공유
- 이는 각 MS의 라이프사이클이 시스템의 다른 부분과 완벽하게 독자적으로 진행될 수 있게 해주고
- 의존성도 명시적으로 나눠서 관리

#### 명시적 의존성
- 의존성은 반드시 명시적으로 선언
- 다른 서비스들의 의존성과 별도로 구분해서 관리
- 선언하지 않은 의존성을 가지면 안된다

#### 별도의 설정 관리
- 여러 환경에 배포된 애플리케이션이 다른 설정을 가지려면 코드와 설정이 별개로 존재해야 함
- 코드는 환경의 영향을 받지 않고 설정은 배포하는 환경마다 다름

#### 독립 테스트
- MS는 스스로 검사할 수 있는 테스트 코드가 있어야 함
- MS 내에서 스스로 검증하는 것은 단위테스트라 지칭할 수 있음

- MS는 서로 유기적으로 통신하기에 단위테스트만으로 충분하지 않음.
- 따라서 통합 테스트라 불리는 시스템 전반에 걸친 테스트도 필요
- 여러 MS와 시스템을 묶어서 비즈니스 기능 동작을 테스트

#### 컨테이너화
- 컨테이너화 필수는 아니지만 하면 대부분의 특성 및 요구사항을 더 쉽게 구현 가능
- 의존성, 실행 환경, 설정을 묶어서 단일 패키지로 만드어버릴 수 있음
- 코드를 불변으로 만들어 원하는 시점에 즉각 시작하거나 중지할 수 있고
- 문제가 있는 인스턴스를 버리고 그냥 새로 뛰워버리면 됨
- 이를 위해 MS 자체가 빠르게 시작할 수 있고 종료하기 전 정리할 수 있는 기능을 제공해야 함

### 1.2.3 연결성 및 구성, 그리고 API
- 서비스 간 연결성을 확보하고, API와 서비스 인터페이스 잘 정의하는 게 중요함

#### 서비스 주도 상호작용
- MS는 자신의 기능을 서비스 형태로 외부에 제공
- 사용하는 외부 기능이나 자원들 역시 서비스 형태로 선언 가능
- 이를 지원 서비스(backing service)라고 함

- 서비스 추상화 덕분에 MS 상호작용을 더 쉽고 간편하게 만들어줌
- 필요한 서비스를 동적으로 찾거나
- 서비스 메타 정보를 스토어나 레지스트리에 보관
- 부하 분산 등

- 쿠버 등의 컨테이너 오케스트레이션 플랫폼이 서비스를 최상위로 추상화하는 것도 이런 편리함 때문

- 각 서비스의 기능을 플랫폼이 제공하는 서비스 추상화로 선언할 수 있음
- 대표적인 게 쿠버의 Service Object
- 그 외 DB, MQ 등 애플리케이션에서 사용하는 외부 애플리케이션 역시 서비스로 선언하고 네트워크를 통해 접근해서 사용

#### 서비스 간 통신 및 조합
- 애플리케이션 수준의 보안, 서킷 브레이커, 타임아웃과 백오프를 가지는 재시도 등 탄력적인 통신, 라우팅, 메트릭 수집 및 보고, 관측 가능성 수집 도구에 정보 전송 등도 서비스 간 상호 작용임

- 서비스 개발자로서 서비스 개발에 필요한 이런 기술 스택은 반드시 갖춰야 함
- 비즈니스 로직과 직접 연관성은 없지만 유용한 기능은 애플리케이션이 실행되는 클라우드 서비스 환경에서 제공하는 기능들로 보통 구현함

#### 관리형 API 기능들로 외부에 제공하기
- 특정 기능의 경우 서비스 개념을 확장해서 관리형 API로 제공해야 할 수도 있음
- 보안, 스로틀링, 캐싱, 버전 관리, 과금 계산, 포털 생성 등등

- API Gateway는 기능에 접근할 수 있는 진입로 역할을 하고, 개발자 포털은 API를 둘러싼 생태계 조성에 꼭 필요
- API 관리는 내부 서비스에도 적용됨
- 쿠버에 내장된 기능이 아니므로 별도로 제공해야 함

### 1.2.4 개발, 릴리스, 배포 자동화하기
- 개발, 릴리스, 배포, 전달 과정은 가능한 자동화

### 1.2.5 동적 환경에서 실행
- 애플리케이션이 실행 환경과는 완전히 독립적
- 개발이나 검증, 운영 등 여러 환경에서 코드 수정 없이 실행이 가능해야 함

- 쿠버처럼 추상화된 범용 실행 환경을 사용하면 여러 실행 환경에서 비슷한 방식으로 애플리케이션 배포 및 실행 가능
- 컨테이너 프로비저닝, 자원 관리, 불변성, 오토스케일링 등 모두 쿠버 기능으로 구현 가능

- 쿠버와 같은 컨테이너 오케스트레이션 플랫폼은 애플리케이션을 stateless 프로세스로 간주하고 실행
- 만약 상태를 따로 저장하고 관리해야 한다면 외부에 명시적으로 상태를 저장할 수 있는 외부 스토어 등을 지정해서 애플리케이션과 분리해야 함

### 1.2.6 동적 환경 관리를 위한 컨트롤 플레인
- 동적 환경을 제어할 수 있는 중앙 관리 도구와 컨트롤 플레인을 사용
- 컨트롤 플레인은 애플리케이션을 실행하는 데브옵스와 애플리케이션을 개발하는 개발자들이 상호작용하는 주요 지점
- 클라우드 컨트롤 플레인은 대개 REST나 원격 프로시저 호출 API로 제공됨

### 1.2.7 관측 가능성 및 모니터링
- 관측 가능성이란 새로운 코드를 실행하지 않고도 애플리케이션 상태를 이해하고 설명할 수 있는 능력
- 트러블슈팅, 트랜잭션 기록, 이상 징후 탐지, 비즈니스 패턴 식별, 애플리케이션에 대한 통찰력 등

- 로깅, 메트릭 수집, 추적, 서비스 가상화 등을 할 수 있어야 함
- 직접 도구를 개발해서 쓰기도 하고 클라우드 서비스 형태로 만들어진 도구를 사용할 수도 있음
- 애플리케이션 코드 수준에서는 별도의 에이전트 프로그램을 사용하거나 클라이언트 라이브러리를 도입해서 애플리케이션 코드를 수정하지 않고도 이런 정보를 수집할 수 있음

## 1.3 클라우드 네이티브 애플리케이션 디자인 패턴

### 1.3.1 통신 패턴
- 서비스가 서로 또는 외부와 어떻게 통신하는지

- DB나 MQ 등 외부 서비스나 시스템을 사용해야 할 수도 있음
- 애플리케이션과 외부 서비스 간의 상호작용을 구현하는 것은 흔하지만 여전히 까다롭고 복잡한 작업

- 전통적인 서비스 간 통신 패턴이나 분산 컴퓨팅 분야에서의 기술들을 클라우드 네이티브 애플리케이션 개발 분야에 바로 적용하는 건 쉽지 않음
- 서비스를 자동으로 찾고 확장성을 보장하는 것처럼 클라우드 네이티브 애플리케이션의 속성이나 비즈니스 기능 및 특성과 잘 맞는 통신 패턴 찾는 게 중요함

- 내부 서비스 간 통신은 동기 혹은 비동기로 구현
- 동기에는 요청-응답, RPC
- 비동기에는 MQ나 pub-sub 방식

### 1.3.2 연결성 및 조합 패턴
- MS가 늘어날수록 더 많은 서비스 간 통신
- 이 복잡도를 줄이기 위해서 특정 기능이나 추상화를 도입
- 연결성과 조합 패턴(connectivity and composition pattern)이 중요한 역할을 담당

#### 연결성
- 서비스 간 믿을 수 있고 안전하며, 찾기 쉽고 관리가 편하고 관측 가능성이 뛰어난 통신 매체를 제공
	- 보안이 뛰어나거나 접속이 불안정할 때 재접속 지원 등등
- 비즈니스 로직과는 무관하지만 뛰어난 연결성을 제공

#### 조합
- 여러 서비스나 시스템을 연결, 통합하여 새로운 서비스를 만든다
- 이를 조합 또는 조합 서비스 또는 통합 서비스라고 한다

- SOA에서는 ESB로 시스템을 통합
- 따라서 과도하게 많은 조합 패턴이 쓰이기도 함 (EIP)

- 클라우드 네이티브 분야에서는 이런 중앙화된 조합 계층이 없다
- 서비스 조합은 전부 서비스 개발 과정에서 이루어짐

### 1.3.3 데이터 관리 패턴
- 보통 DB를 주로 사용
- 데이터 관리 역시 중앙화된 방법이 아니라 분산 방식으로 이루어짐
- 클라우드 네이티브 애플리케이션은 각 MS가 자신만의 데이터 스토어를 가지며, 다른 서비스나 외부 시스템 등은 오직 서비스 인터페이스를 통해서만 해당 데이터에 접근
- 이렇게 분산하면 MS 간 데이터 공유나 동기화가 어려워짐
- 따라서 데이터 관리 패턴이 중요함

### 1.3.4 이벤트 주도 아키텍처 패턴
- EDA는 수십 년간 사랑받아 온 방식
- MS를 독립적이고 자율적으로 동작할 수 있도록 만드는 중요한 역할 담당
- EDA는 MS 간 상호작용을 좀 더 느슨하고 유연하게 만들어줌

### 1.3.5 스트림 프로세싱 패턴
- EDA는 한 번에 하나의 이벤트만 처리
- 이벤트끼리 서로 상관관계가 없음
- 스트림은 서로 밀접한 관계를 가지며, 시간에 따라 지속적으로 유입되는 일련의 이벤트나 데이터
- 이런 일련의 이벤트는 애플리케이션이 현재 상태를 계속 저장하고 관리하면서 처리해야 함
- 이는 일반적인 EDA와 다르게 동작함

- 이런 스트림을 생산하거나 처리하는 애플리케이션 로직을 스트림 프로세싱이라고 부름

### 1.3.6 API 관리 및 사용 패턴
- 관리형 서비스나 관리형 API를 통해 외부 시스템이 이런 기능을 사용하는 것을 제어하고, API 등을 통해 사용하고자 하는 기능을 쉽게 찾을 수 있게 만들고 피드백을 제공받을 수 있음

- 보통 별도의 API Gateway를 두고 애플리케이션에 접근할 수 있는 대문처럼 만드는 경우가 많음
- API Gateway는 일반적으로 관리 기능과 개발자 포털을 함께 제공

## 1.4 클라우드 네이티브 애플리케이션 참조 모델
![](files/Pasted%20image%2020250906172159.png)

## 1.5 마치며
