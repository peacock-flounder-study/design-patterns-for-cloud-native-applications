### 1강

### 클라우드 네이티브

**클라우드 네이티브의 개념 (CNCF)**

- 퍼블릭, 프라이빗, 하이브리드 클라우드 같은 멀티 클라우드 환경에서 크기를 자유롭게 조절할 수 있는 애플리케이션을 만들고 실행할 수 있는 능력을 제공
- 독립적인 비즈니스 기능 중심의 마이스크로 서비스들을 느슨하게 결합하여 탄력성 있는 시스템을 만들 수 있으며
- 관리와 관찰이 쉽고 강력한 자동화와 더불어 엔지니어들이 최소한의 리소스로 많은 변경 작업을 할 수 있게 만들어주는 환경

### 마이크로서비스로 구성하는 설계

클라우드 네이티브 애플리케이션에는 독립적으로 만들어진 서비스를 느슨하게 결합하는 마이크로 서비스가 필수 요소

- 기존에는 모놀리식 애플리케이션으로 비즈니스 요구사항을 충족함
- 다만 이 방식은 근본적으로 복잡하고 유지보수 비용이 많이 듦.
- **(SOA -> EBS -> MSA)**
   - SOA(service oriented artchitecture) : 특정 비즈니스 기능을 지원하는 서비스들을 조합하는 모듈 개념의 아키텍처
   - ESB (enterprise service bus) : 중앙집중형 모놀리식으로 서비스 통합 계층을 사용해 서비스들을 한데 묶고 API 관리계층을 두어 API를 제공하는 방식
   - MSA (microservice architecture): 중앙화된 컴포넌트를 제거하고 각 서비스를 독립적으로 개발 및 배

<br>
<br>

---

### 컨테이너와 컨테이너 오케스트레이션

<br>

**컨테이너** 
- 컨테이너는 애플리케이션이 실행되는 데 필요한 환경을 묶어 격리된 공간에서 실행할 수 있는 기술
- 컨테이너 전용 파일시스템을 통해 이미지를 제공받으며, 주로 컨테이너 레지스트리에 이미지를 보관
- 애플리케이션 코드, 의존성 라이브러리, 실행환경 등 애플리케이션 실행에 필요한 모든 데이터를 이미지로 받으며 이 이미지는 수정이 불가능함
- 컨테이너는 이미지를 통해 컨테이너 인스턴스라는 프로세스를 만들고, 컨테이너 런타임 엔진에서 실행된다.

<img width="739" height="409" alt="Screenshot 2025-09-11 at 3 01 29 PM" src="https://github.com/user-attachments/assets/b93aafff-683c-423f-92a8-1ab915201c64" />

- 컨테이너는 런타임 엔진에서 호스트의 커널, 프로세서, 메모리를 다른 컨테이너와 함께 사용함
- VM에서 실행하는 것과 비교했을 때 더 가볍고 분리된 프로세스 환경을 제공
- 이런 컨테이너화를 통해 마이크로서비스를 여러 환경에서 동일하게 실행되도록 할 수 있으며, 마이크로 서비스를 캡슐화하여 독립적이고 자율적인 서비스로 만드는 핵심 기술임

그렇다면 어떻게 실행되는 컨테이너와 라이프사이클을 관리할까?

<br>

**왜 컨테이너 오케스트레이션이 필요한가?**

컨테이너 오케스트레이션은 컨테이너 라이프사이클을 관리하는 체계이며, 각 컨테이너들을 수동으로 직접 관리하는건 불가능하기 때문에 필요

<br>

<오케스트레이션 핵심 기능>

    - 자동화된 프로비저닝
    - HA
    - scaling
    - 자원관리
    - 부하분산 / 서비스 인터페이스
    - 네트워크 추상화 : 오버레이 네트워크 제공하여 컨테이너 간 통신
    - affinity : 컨테이너 간의 배치를 통해 가용성, 목표 성능을 달성할 수 있도록 함
    - service discovery
    - control plane : 시스템 관리 및 모니터링
    - rolling upgrade
    - componentization and isolation :네임스페이스 등으로 도메인을 격리

등의 요소들이 있으며 쿠버네티스가 표준 컨테이너 오케스트레이션 시스템.

### 쿠버네티스

- 자동화된 배포, 크기 조절, 장애복구, 네트워크 등 컨테이너 관리에 필요한 많은 기능들 통해 컨테이너들을 쉽게 관리할 수 있는 추상화된 계층을 제공


<img width="578" height="305" alt="Screenshot 2025-09-11 at 3 05 47 PM" src="https://github.com/user-attachments/assets/4962b5c3-6fbd-4206-9388-aa92c25f5d55" />

- 쿠버네티스는 실제 물리 서버 혹은 VM들로 노드를 구성함
- 이 노드 중 하나는 컨트롤 플레인이 되어야하고, 나머지는 여러 워커 노드들로 구성
    - 컨트롤플레인은 애플리케이션 인스턴스 스케줄링, 관리하는 역할
    - 쿠버네티스 API 서버는 컨트롤 플레인 + 워커 노드 사이의 통신을 담당
    - 쿠버네티스 스케줄러가 워크로드에 적당한 워커 노드를 지정
    - 각 노드에는 **kubelet**이라는 노드 상태를 관리하는 에이전트가 실행됨
        - 쿠버네티스 서버 API와 통신하여 할 일을 전달받고, 현재 노드 상태도 알림
    - 파드 : 노드에 실행되는 애플리케이션 실행환경의 배포단위. (pod 별 고유한 ip주소)
        - 서비스 : 여러 파드를 하나의 네트워크 서비스로 묶은 논리적인 개념
        - 레플리카셋 : 애플리케이션에서 지정한 파드 수를 관리
        - 디플로이먼트 : 애플리케이션 변경사항을 처리하고 파드나 레플리카셋에 반영

**서버리스**

- 서버리스 플랫폼은 필요한 관리 기능이나 네트워크, 탄력성, 확장성, 보안 등의 요소를 제공함
- 플랫폼은 AWS lambda, Azure funtion 등이 있음
- 주로 배치 작업이나 event driven 서비스에 적합
    - 부하에 따라 자동으로 인스턴스 크기를 조정하고 탄력적으로 동작함
    - 내부적으로 컨테이너로 실행됨


**개발 라이프사이클 자동화하기**

클라우드 네이티브 애플리케이션을 배포할 때 중요한 민첩성, 속도, 안전성을 위해 개발 라이프사이클의 각 단계를 **자동화하는 구조**도 필요
- 통합테스트, 빌드, 릴리즈, 설정관리, CI, CD, infrastructure 관리 등
<img width="581" height="267" alt="Screenshot 2025-09-11 at 3 08 48 PM" src="https://github.com/user-attachments/assets/f9449a90-b2aa-4315-a50d-226decf744af" />


<br>
<br>

**동적관리**

- autoscaling : 트래픽이나 부하에 따라 줄이거나 늘림
- HA : 고가용성, 이상을 감지하면 인스턴스를 새로 띄우거나 다른 곳으로 트래픽을 보냄
- resource optimization : 실시간 요구에 따라 동적으로 크기를 조절하여 비용을 청구하는 방식
- observerbility : 로그, 메트릭 등 정보를 중앙에서 수집,제공
- QoS : 보안, 쓰로틀링, 버전관리, 규정 및 정책 준수 등을 지원
- center control plane : 중앙화된 제어방법을 제공
- resource provisioning : 애플리케이션 별 CPU, 메모리, 스토리지, 네트워크 등의 자원을 할당 및 관리
- multicloud support : private, public 등 여러 클라우드 환경에서 애플리케이션 실행 및 관리

<br>
<br>

---

### 클라우드 네이티브 아키텍처 개발 방법론
- Twelve Factor app 개발 방법론은 애플리케이션 개발 주기와 일치하지 않아 더 완전하고 정형화된 방법론 - 클라우드 네이티브 개발 주기를 나누어 처리함.
<img width="586" height="269" alt="Screenshot 2025-09-11 at 3 13 38 PM" src="https://github.com/user-attachments/assets/54a2d6d1-ca01-439a-a24d-6748904ad028" />

**애플리케이션 설계**
- 구현해야할 비즈니스 핵심 기능을 파악하고 설계부터 시작해야함
- 핵심기능과 시스템 간의 의존성을 파악하는 방법론이 필요
- DDD, bounded context

**애플리케이션 개발**
- 독립 코드베이스
- 명시적 의존성
- 별도의 설정 관리
- 독립 테스트

**연결 및 API 구현**

- 마이크로 서비스는 자신의 기능을 서비스로 제공하기 때문에 이 서비스를 동적으로 찾을수도 있고, 레지스트리나 스토어에 보관, 부하분산도 가능해짐. (추상화)
  - 쿠버네티스의 service object
- 서비스 간 통신 및 조합
   - 내부/외부 서비스 간 상호작용
  - circuit breaker, timeout, backoff, retry, routing, 메트릭 등을 고려
- 관리형 API
   - API 게이트웨이 : 보안, 쓰로틀링, 캐싱, 버전관리 등
        
**개발, 릴리즈, 배포 자동화**

- CI/CD,IaC 등을 통해 빌드, 통합테스트, 릴리즈, 배포, 실행 등의 단계를 자동화
    
**동적 환경에서 실행**

- 여러 실행환경에서 비슷한 방식으로 애플리케이션을 배포하고 실행할 수 있음
- 쿠버네티스는 기본적으로 stateless process로 간주하고 실행
- 애플리케이션 상태를 따로 저장해서 관리해야하면 외부 스토어를 지정해서 컨테이너 라이프사이클과 분리해야함
    
**동적환경 관리를 위한 컨트롤 플레인**

- 애플리케이션이 실행될 동적 환경을 제어할 수 있는 중앙 관리 도구와 컨트롤 플레인 사용
- REST AI 나 RCA API로 제공됨

**관측 가능성 및 모니터링**

- 트러블슈팅, 트랜잭션 기록, 비즈니스 패턴 식별 등
- 로깅, 메트릭 수집, 추적, 서비스 가상화 등


<br>
<br>

---

### 클라우드 네이티브 애플리케이션 디자인 패턴

- 비즈니스 로직을 구현하고 외부 서비스가 비즈니스 기능을 사용할 수 있는 방법을 제공
- 여러 패턴들을 통해 배포방법, 크기 조절, 관측 가능성


**통신 패턴(communucation pattern)**

- 애플리케이션과 외부 서비스 간의 상호작용을 구현하는 방식.
- 비즈니스 기능 별로 각 서비스는 DB 나 메시지 브로커와 같은 외부 서비스나 시스템을 사용하게 됨

- 동기 통신 : RPC, 요청-응답
- 비동기 통신 : 메시지 큐, pub/sub 방식

**연결성과 조합 패턴(connectivity and composition pattern)**

내부 서비스 간 통신 복잡도를 줄이기 위한 추상화

- **연결성**
    - 서비스 간 통신 시 보안, 재접속 지원 기능 등을 제공
    - 서비스 메시, 사이드카, 보안, 서비스 검색, 트래픽 라우팅 등
- **조합**
    - 여러 서비스나 시스템을 통합하여 새로운 서비스를 만드는 것
    - 예전에 SOA에서 모든 서비스나 데이터를 ESB로 통합 -> 새로운 조합을 만들 때 ESB가 선택되는 이 EIP(enterprise integration pattern) 구조에서 과도하게 많은 조합 패턴이 사용됐었음.
    - 클라우드 네이티브의 서비스 조합은 모두 서비스 개발 과정에서만 이루어지고, 시스템 구조 상으로는 중앙화된 조합 계층은 없다.

**데이터 관리 패턴**

- 예전에는 중앙화된 공유 데이터 스토어를 애플리케이션이 함께 공유함
- 데이터 관리가 분산되면서 마이크로서비스 간 데이터를 공유하고 동기화하는 문제를 해결하기 위한 패턴
- 데이터 관리 패턴이 중요해짐

- 분산형 데이터 관리, 트랜잭션 처리, 데이터 조합, 사이즈 조절, 캐싱 등

**이벤트 주도 아키텍처 패턴**

- EDA, 비동기 통신 방식은 이벤트 주도 클라우드 네이티브 애플리케이션의 근간
- RPC와 같은 동기 통신에 비해 EDA는 마이크로 서비스 간 상호작용을 좀 더 느슨하고 유연하게 만듦

- 큐, pub/sub, delivery semantic, 이벤트 스키마 등 구현기술과 프로토콜을 다룰 예정

**스트림 프로세싱 패턴**

- EDA는 한 번에 하나의 이벤트만 처리하며, 이벤트 전후 데이터는 상관관계가 없음.
- 스트림은 서로 밀접한 관계를 가지며 시간에 따라 지속적으로 유입되는 이벤트나 데이터를 의미
- 현 상태를 저장하고 관리하며 동시에 확장성과 동시성을 만족해야함

**API 관리 및 사용 패턴** 

- 일정 규모 이상의 아키텍처는 애플리케이션 비즈니스 기능을 내부/외부 시스템에 제공하는 경우가 많음
- 이런 경우 관리형 서비스나 API를 통해 외부 시스템이 기능을 사용하는 것을 제어하고 쉽게 찾을 수 있도록 함

- api gateway
- 관리 기능과 개발자 포털을 함께 제공하는 편


<br>

### 클라우드 네이티브 애플리케이션 참조 모델

<img width="730" height="604" alt="Screenshot 2025-09-11 at 3 36 29 PM" src="https://github.com/user-attachments/assets/b8982be6-6626-4e55-b379-1e8431b2735a" />

### 마치며

- 클라우드 네이티브는 여러 마이크로 서비스들로 구성되며
- 각 마이크로 서비스들은 컨테이너로 패키징되고, 쿠버네티스와 같은 오케스트레이션 도구로 관리됨
- 마이크로 서비스들은 CI/CD를 통해 자동화되고 여러 동적 환경에서 관리되며 모니터링할 수 있음
- 이런 아키텍처 특성 상 애플리케이션 설계부터 관리까지 기존 모놀리식과는 다른 개발방법론이 필요하며
- 클라우드 네이티브 개발환경에서 비즈니스에 맞는 적절한 디자인 패턴을 통해 개발 해야함




